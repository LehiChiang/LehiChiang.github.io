<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lehi J.</title>
  
  <subtitle>modern coder</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-09T11:37:04.079Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lehi Chiang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>秒杀经典TopK问题</title>
    <link href="http://yoursite.com/2020/11/09/%E7%A7%92%E6%9D%80%E7%BB%8F%E5%85%B8TopK%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/11/09/%E7%A7%92%E6%9D%80%E7%BB%8F%E5%85%B8TopK%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-09T03:01:29.000Z</published>
    <updated>2020-11-09T11:37:04.079Z</updated>
    
    <content type="html"><![CDATA[<p class="note note-primary">Top K问题是解决如何在数组中或者数据中获得前K个最大或者最小的元素，是面试时的高频问点。</p><p>问题的具体化形式包括但不限于以下几个：</p><ul><li><h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h4></li><li><h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></h4></li><li><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h4></li></ul><p>解决这一类问题，我们通常有如下几种解题方法：</p><ul><li><p>排序法</p></li><li><p>堆</p></li><li><p>快速查找法</p></li></ul><p>下面对于每种方法给出解题思路，对于这一类问题可以直接套用。</p><div style="color:white"></div><p style="text-indent: 2em;"></p>" srcset="/img/loading.gif<img src alt="image-20200716153831941" style="zoom:50%;display: flex;margin: 0 auto;">]]></content>
    
    
    <summary type="html">Top K问题是解决如何在数组中或者数据中获得前K个最大或者最小的元素，是面试时的高频问点。</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="中级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%BA%A7/"/>
    
    
    <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="堆" scheme="http://yoursite.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>插入区间</title>
    <link href="http://yoursite.com/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</id>
    <published>2020-11-04T03:12:31.000Z</published>
    <updated>2020-11-04T04:06:46.137Z</updated>
    
    <content type="html"><![CDATA[<p class="note note-primary">区间类问题有很多种：区间合并， 区间交集， 区间插入等等。 区间类问题只要的重难点就是找好区间直接重叠或不相交的条件。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>&nbsp;</p><p><strong>示例&nbsp;1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]<strong>输出：</strong>[[1,5],[6,9]]</div></pre></div><p><strong>示例&nbsp;2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<strong>输出：</strong>[[1,2],[3,10],[12,16]]<strong>解释：</strong>这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10]&nbsp;重叠。</div></pre></div><p>&nbsp;</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>刚刚拿到这一题目，我的第一反应是想用之前解决区间问题的思路来解决这一问题。在这一题中，我们要新增一个区间，那么就会有两者插入情况：</p><ol><li>新插入的区间与原数组中的任何一个区间都不重叠，那么这个时候就要找出需要插入的位置；</li><li>薪插入的区间与原数组中的某些区间有重叠，那么这个时候就要考虑区间合并的问题。</li></ol><p>那么，这道题就好解了！设置好遍历区间和新增区间的三种位置关系，然后依次判断是否相交，然后按照区间合并的思路去做。</p><p>但是，当我真正用这种方法来套用这一题时，发现这么做的代码非常冗余，判断条件很多，稍不注意就会有遗漏的地方。归结到问题的本质还是要找出新区间与原区间的关系，确定好这个关系，问题就好解决了。</p><p><strong>下面来介绍一种新的方法。</strong></p><p><em>方法来源：</em></p><p class="note note-primary">    作者：LeetCode-Solution<br>    链接：<a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/</a><br>    来源：力扣（LeetCode）<br></p><p>由于题目中的区间列表已经是按照区间起始排好序的，所以每一个区间的起始都大于前一个期间的起始。那么如果新加入的区间起始大于当前区间的结束，那么说明当前区间与新区间没有交集。那么可以遍历下一个区间了。</p><p>如果新加入的区间起始小于当前区间的结束，那么说明这两个区间是有交集的了，如下图所示：</p><img src="/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/merge.png" srcset="/img/loading.gif" alt="区间插入过程描述" style="zoom:40%;display: flex;margin: 0 auto;"><p><strong>那么我们就要修改新插入区间的区间范围！！！</strong></p><p>怎样修改？它们的交集即为：<br>$$<br>[min(l1, l2), min(r1, r2)]<br>$$<br>它们的并集为：<br>$$<br>[min(l1, l2), max(r1, r2)]<br>$$<br>那么直接就修改新插入的区间范围。</p><p>什么时候将新区间插入到区间列表中呢？当然是第一个满足新插入区间的结尾小于当前区间的起始的时候，说明它们两个无交集。这个时候就可以将新区间插入到列表中了！</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span>        res = []        remove = <span class="hljs-literal">False</span>        left, right = newInterval        <span class="hljs-keyword">for</span> li, ri <span class="hljs-keyword">in</span> intervals:            <span class="hljs-comment"># 新区间和当前区间无交集，直接将当前区间加到结果中</span>            <span class="hljs-keyword">if</span> left &gt; ri:                res.append([li, ri])            <span class="hljs-comment"># 判断新区间是否要插入到列表中的条件</span>            <span class="hljs-keyword">elif</span> li &gt; right:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> remove:                    res.append([left, right])                    remove = <span class="hljs-literal">True</span>                res.append([li, ri])            <span class="hljs-comment"># 新区间和当前区间有交集，进行新区间范围合并</span>            <span class="hljs-keyword">else</span>:                left = min(li, left)                right = max(ri, right)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> remove:            res.append([left, right])        <span class="hljs-keyword">return</span> res</code></pre></div><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组 <code>intervals</code> 的长度，即给定的区间个数。</li><li>空间复杂度：<code>O(n)</code>，除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><p>还可以不另外创造新的存储空间，直接对原列表进行原地修改。</p><p>从头到尾找到重叠的区间，记录重叠区间的索引，方便后续的切片替换。当区间不重叠的时候就可以直接替换掉重复的区间段了。</p><p>代码实现如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span>        <span class="hljs-comment"># 初始状况判断</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> newInterval:            <span class="hljs-keyword">return</span> intervals        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:            <span class="hljs-keyword">return</span> [newInterval]        <span class="hljs-comment"># 已经是起点有序的了</span>        i = <span class="hljs-number">0</span>        intervalsLen = len(intervals)        <span class="hljs-keyword">while</span> i &lt; intervalsLen <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>]:            i += <span class="hljs-number">1</span>        <span class="hljs-comment"># 保存删除之前的位置，最后在这个位置上插入</span>        tempI = i        <span class="hljs-keyword">while</span> i &lt; intervalsLen <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]:            newInterval[<span class="hljs-number">0</span>] = min(newInterval[<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>])            newInterval[<span class="hljs-number">1</span>] = max(newInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>])            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">del</span> intervals[tempI:i]        intervals.insert(tempI, newInterval)        <span class="hljs-keyword">return</span> intervals</code></pre></div></div>]]></content>
    
    
    <summary type="html">又是一道区间问题。</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="困难" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%9B%B0%E9%9A%BE/"/>
    
    
    <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="区间" scheme="http://yoursite.com/tags/%E5%8C%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>两个数组的交集</title>
    <link href="http://yoursite.com/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <id>http://yoursite.com/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</id>
    <published>2020-11-02T02:37:07.000Z</published>
    <updated>2020-11-02T03:24:25.529Z</updated>
    
    <content type="html"><![CDATA[<p class="note note-primary">求解两个数组的交集问题有很多种写法，这里主要介绍两种方法。还有其他的编程语言特色的求解方法。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]<strong>输出：</strong>[2]</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]<strong>输出：</strong>[9,4]</div></pre></div><p>&nbsp;</p><p><strong>说明：</strong></p><ul>    <li>输出结果中的每个元素一定是唯一的。</li>    <li>我们可以不考虑输出结果的顺序。</li></ul><h1 id="方法一（借助哈希）"><a href="#方法一（借助哈希）" class="headerlink" title="方法一（借助哈希）"></a>方法一（借助哈希）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求解两个数组中的交集，首先我们可以去除掉各自列表中的重复元素。去除重复元素这一过程，可以使用<code>set()</code>集合的性质（不能存储重复元素）进行操作。</p><p>得到精简后的数组后，就可以进行元素级别的比较了。遍历长度较小的数组，然后在另一个数组中查找是否存在其中。这种方法有点还是可以有提升的地方。我们可以将查找的时间复杂度降低。即使用Hash来查找。所以在上一步的操作中，可以使用<code>Java</code>的<code>HashSet()</code>去重的同时，来减少查找的时间复杂度。</p><p>最后一步，定义一个结果变量，如果较短数组中的元素在另外一个数组中，则可以直接将元素添加到结果变量中，直到遍历完整个较短数组。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        nums1 = set(nums1)        nums2 = set(nums2)        <span class="hljs-keyword">if</span> len(nums1) &lt; len(nums2):            <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1 <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> nums2]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums2 <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> nums1]</code></pre></div><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：<code>O(m+n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 <code>O(m+n)</code> 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 <code>O(min(m,n))</code> 的时间，因此总时间复杂度是 <code>O(m+n)</code>。</p></li><li><p>空间复杂度：<code>O(m+n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。空间复杂度主要取决于两个集合。</p></li></ul><h1 id="方法二（排序-双指针）"><a href="#方法二（排序-双指针）" class="headerlink" title="方法二（排序+双指针）"></a>方法二（排序+双指针）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种方法的解题思路就比较直接了。借助合并两个有序链表的思想，设置两个指针<code>i</code>和<code>j</code>分别指向两个数组<code>nums1</code>和<code>nums2</code>，如果<code>nums1[i] == nums2[j]</code>那么就是两个列表的交集元素。将元素放到无重复元素的<code>set()</code>中。两个元素不相等的情况下，元素小的那个指针往前移一位，直到两个指针越界。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        nums1.sort()        nums2.sort()        res = set()        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i&lt;len(nums1) <span class="hljs-keyword">and</span> j&lt;len(nums2):            <span class="hljs-keyword">if</span> nums1[i] &lt; nums2[j]:                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums1[i] &gt; nums2[j]:                j += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums1[i] == nums2[j]:                res.add(nums1[i])                i += <span class="hljs-number">1</span>                j += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：<code>O(nlogn)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。排序的时间复杂度级别是 <code>O(nlogn)</code>，双指针寻找交集元素的时间复杂度级别是 <code>O(n)</code>，因此总时间复杂度是 <code>O(nlogn)</code>。</p></li><li><p>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组的长度。在最坏的情况下，两数组的元素都一样。</p></li></ul><h1 id="其他代码示例"><a href="#其他代码示例" class="headerlink" title="其他代码示例"></a>其他代码示例</h1><h2 id="Python-amp-运算符"><a href="#Python-amp-运算符" class="headerlink" title="Python &amp; 运算符"></a>Python &amp; 运算符</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        <span class="hljs-keyword">return</span> list(set(nums1) &amp; set(nums2))</code></pre></div><p>Python语言中的&amp;运算符可以直接求出两列表的交集</p><h2 id="Java-retainAll-方法"><a href="#Java-retainAll-方法" class="headerlink" title="Java retainAll()方法"></a>Java retainAll()方法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    HashSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:nums1)&#123;        list.add(i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:nums2)&#123;        set2.add(i);    &#125;    list.retainAll(set2);    set1.addAll(list);    <span class="hljs-keyword">return</span> set1.stream().mapToInt(i-&gt;i).toArray();&#125;</code></pre></div><p><code>A.retainAll(B)</code>方法的含义：移除<code>A</code>中，不包含在<code>B</code>中的元素。</p></div>]]></content>
    
    
    <summary type="html">介绍求解数组交集的几种方法</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    
    <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="http://yoursite.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数组中的最长山脉</title>
    <link href="http://yoursite.com/2020/10/27/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
    <id>http://yoursite.com/2020/10/27/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</id>
    <published>2020-10-27T08:47:10.000Z</published>
    <updated>2020-10-27T10:04:55.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “<em>山脉”</em>：</p><ul>    <li><code>B.length &gt;= 3</code></li>    <li>存在 <code>0 &lt; i&nbsp;&lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li></ul><p>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）</p><p>给出一个整数数组 <code>A</code>，返回最长 <em>“山脉”</em>&nbsp;的长度。</p><p>如果不含有 “<em>山脉”&nbsp;</em>则返回 <code>0</code>。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>[2,1,4,7,3,2,5]<strong>输出：</strong>5<strong>解释：</strong>最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>[2,2,2]<strong>输出：</strong>0<strong>解释：</strong>不含 “山脉”。</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ol>    <li><code>0 &lt;= A.length &lt;= 10000</code></li>    <li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><h1 id="方法一（动态规划）"><a href="#方法一（动态规划）" class="headerlink" title="方法一（动态规划）"></a>方法一（动态规划）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题的做法可以想到 <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank">674.最长连续递增序列</a><br></p><p><code>dp1</code>: 从左到右记录以这个数为结尾的最长连续递增序列长度</p><p><code>dp2</code>: 从右到左记录以这个数为结尾的最长连续递增序列长度</p><p>最后遍历一遍统计 <code>dp1[i] + dp2[i] - 1</code>为以这个数为山脉最高点的最长长度</p><p><code>nums = [2,1,4,7,3,2,5]</code></p><p><code>dp1 = [1,1,2,3,1,1,2]</code></p><p><code>dp2 = [2,1,1,3,2,1,1]</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestMountain</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        方法一：使用动态规划的思想解决问题</span><span class="hljs-string">        """</span>        la = [<span class="hljs-number">0</span>]*len(A)        lb = [<span class="hljs-number">0</span>]*len(A)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(A)):            <span class="hljs-keyword">if</span> A[i] &gt; A[i<span class="hljs-number">-1</span>]:                la[i] = la[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>         <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(A)<span class="hljs-number">-1</span>)[::<span class="hljs-number">-1</span>]:            <span class="hljs-keyword">if</span> A[j] &gt;A[j+<span class="hljs-number">1</span>]:                lb[j] = lb[j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(A)):            <span class="hljs-keyword">if</span> la[i]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lb[i]&gt;<span class="hljs-number">0</span>:                res = max(res, la[i]+lb[i]+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="方法二（标记法）"><a href="#方法二（标记法）" class="headerlink" title="方法二（标记法）"></a>方法二（标记法）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个变量 <code>increasing</code> 和 <code>decreasing</code>，分别记录每个山脉上升区间的长度以及下降区间的长度。通过遍历，寻找最长的山脉。</p><p>遍历一遍数组，如果遇到连续递增的情况，那么 <code>increasing</code>就加一；如果遇到连续递减的情况，那么 <code>decreasing</code>就减一。</p><p>如果数组中只有一个<em>山</em>的话，那么遍历完一遍之后， <code>increasing</code> 和 <code>decreasing</code>的和加一就是最后的结果。</p><p>为了防止一个数组中出现很多个<em>山</em>的情况，我们在每次的外循环使 <code>increasing</code> 和 <code>decreasing</code>的值清零。</p><p>如果遇到相邻两元素值相同的情况，我们直接跳过即可。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestMountain</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        方法二：使用两个变量increasing和decreasing，分别记录每个山脉上升区间的长度以及下降区间的长度。通过遍历，寻找最长的山脉。</span><span class="hljs-string">        """</span>        maxLength = <span class="hljs-number">0</span>        j = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> j &lt; len(A):            increasing, decreasing = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> j &lt; len(A) <span class="hljs-keyword">and</span> A[j<span class="hljs-number">-1</span>] &lt; A[j]:                j += <span class="hljs-number">1</span>                increasing += <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> j &lt; len(A) <span class="hljs-keyword">and</span> A[j<span class="hljs-number">-1</span>] &gt; A[j]:                j += <span class="hljs-number">1</span>                decreasing += <span class="hljs-number">1</span>                        <span class="hljs-keyword">if</span> increasing &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> decreasing &gt; <span class="hljs-number">0</span>:                maxLength = max(maxLength, increasing + decreasing + <span class="hljs-number">1</span>)            <span class="hljs-keyword">while</span> j &lt; len(A) <span class="hljs-keyword">and</span> A[j<span class="hljs-number">-1</span>] == A[j]:                j += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> maxLength</code></pre></div></div>]]></content>
    
    
    <summary type="html">如何求解数组中的最长”山脉“</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="中级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%BA%A7/"/>
    
    
    <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>划分字母区间问题</title>
    <link href="http://yoursite.com/2020/10/24/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/10/24/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-24T11:09:10.000Z</published>
    <updated>2020-10-27T09:18:12.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>&nbsp;</p><p><strong>示例：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "ababcbacadefegdehijhklij"<strong>输出：</strong>[9,7,8]<strong>解释：</strong>划分结果为 "ababcbaca", "defegde", "hijhklij"。每个字母最多出现在一个片段中。像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>    <li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li></ul><h1 id="方法一（贪心-双指针）"><a href="#方法一（贪心-双指针）" class="headerlink" title="方法一（贪心+双指针）"></a>方法一（贪心+双指针）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。</p><p>想切割，要有首尾两个指针，确定了结尾指针，就能确定下一个切割的开始指针。<br>遍历字符串，如果已扫描部分的所有字符，都只出现在已扫描的范围内，即可做切割。<br></p><p>我们假设变量<code>start</code>和<code>maxIndex</code>为开始和结束的两个标记指针。由于上一步已经得到了每个字符出现的最后索引。所以变遍历每个字母的同时，边求得出现索引最远的字母。这样，就可以确保之前所有的字符的出现位置都小于索引出现最远的字母了。</p><p>如果当前位置<code>i</code>已经等于最远出现的字符索引，那么在这里就可以直接切割，使用<code>maxIndex-start+1</code>来求得每段分割的最长数量，从而达到最多的分割数。</p><p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span><span class="hljs-params">(self, S: str)</span> -&gt; List[int]:</span>        mapping = &#123;&#125;        <span class="hljs-keyword">for</span> i,char <span class="hljs-keyword">in</span> enumerate(S):            mapping[char] = i        start, maxIndex = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        result = []        <span class="hljs-keyword">for</span> i,char <span class="hljs-keyword">in</span> enumerate(S):            maxIndex = max(maxIndex, mapping[char])            <span class="hljs-keyword">if</span> i == maxIndex:                result.append(maxIndex-start+<span class="hljs-number">1</span>)                start = maxIndex+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> result</code></pre></div><h1 id="方法二（区间合并转换）"><a href="#方法二（区间合并转换）" class="headerlink" title="方法二（区间合并转换）"></a>方法二（区间合并转换）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个问题的解题过程可以转化为求解区间合并的问题。</p><p>要求出字符出现的最远出现位置，可以把它看成这个字符出现区间的末端。而第一出现该字符的位置为头端。这样就构成了每个字符出现从开始到结束的区间范围，如下如所示：</p><img src="/2020/10/24/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/set.JPG" srcset="/img/loading.gif" alt="区间划分" style="zoom:87%;display: flex;margin: 0 auto;"><p>那么从这个图中就可以受到区间合并的启发，可以看到要使同一字母最多出现在一个片段中，那么只要确保最远出现的字符的位置就可以了。最远出现字符的位置可以对小于其出现位置的字符区间进行合并，从而是原字符串分为三个颜色的分断。从图中很容易看出。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span><span class="hljs-params">(self, S: str)</span> -&gt; List[int]:</span>        intervals=&#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(S)):            <span class="hljs-comment"># 如果第一次出现就加入区间[i,i]</span>            <span class="hljs-keyword">if</span> S[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> intervals:                intervals[S[i]]=[i,i]            <span class="hljs-comment"># 如果已经出现过，就更新区间终点</span>            <span class="hljs-keyword">else</span>:                intervals[S[i]][<span class="hljs-number">1</span>]=i        <span class="hljs-comment"># 把所有区间取出放入列表, 然后根据区间起点排序</span>        temp=list(intervals.values())        temp.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])        ans = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(temp)):            <span class="hljs-comment"># 不可能存在相等的情况，区间完全不相交，直接加上即可</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ans <span class="hljs-keyword">or</span> ans[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; temp[i][<span class="hljs-number">0</span>]:                ans.append(temp[i])            <span class="hljs-comment"># 在区间重叠的情况下，如果终点更大，则更新</span>            <span class="hljs-keyword">elif</span> temp[i][<span class="hljs-number">1</span>] &gt; ans[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]:                ans[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = temp[i][<span class="hljs-number">1</span>]        res=[x[<span class="hljs-number">1</span>]-x[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ans]                      <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <summary type="html">对字符串分割，如何确保同一字母最多出现在一个片段中？</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="中级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%BA%A7/"/>
    
    
    <category term="贪心" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>比较含退格的字符串</title>
    <link href="http://yoursite.com/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2020-10-19T15:15:04.000Z</published>
    <updated>2020-10-19T15:28:51.130Z</updated>
    
    <content type="html"><![CDATA[<style>    .css-13ynzks-InfoWrap {        width: 100%;        border: 1px solid rgba(var(--grey-3-rgb),1);        padding: 12px 20px 20px;    }    .css-1493omj-TestcaseDiv {        color: rgba(var(--grey-7-rgb),1);    }    .css-q5jqx5-DescSpan {        color: rgba(var(--grey-6-rgb),1);    }</style><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "ab#c", T = "ad#c"<strong>输出：</strong>true<strong>解释：</strong>S 和 T 都会变成 “ac”。</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "ab##", T = "c#d#"<strong>输出：</strong>true<strong>解释：</strong>S 和 T 都会变成 “”。</div></pre></div><p><strong>示例 3：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "a##c", T = "#a#c"<strong>输出：</strong>true<strong>解释：</strong>S 和 T 都会变成 “c”。</div></pre></div><p><strong>示例 4：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "a#c", T = "b"<strong>输出：</strong>false<strong>解释：</strong>S 会变成 “c”，但 T 仍然是 “b”。</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ol>    <li><code>1 &lt;= S.length &lt;= 200</code></li>    <li><code>1 &lt;= T.length &lt;= 200</code></li>    <li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>'#'</code>。</li></ol><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>    <li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="方法一：直接比较法"><a href="#方法一：直接比较法" class="headerlink" title="方法一：直接比较法"></a>方法一：直接比较法</h2><p>最简单的方法就是直接将两字符串中的<code>#</code>和其前一个字符去掉，比较剩余的字符是否相等。若相等则返回<code>true</code>。</p><p>我们如何在最好的时间内去掉<code>#</code>和其前一个字符呢？</p><p>在不考虑空间开销的情况下，我们可以考虑构造两个辅助栈来完成操作。如果遇到<code>#</code>，那么就取出栈顶的元素，这样也就模拟了删掉<code>#</code>前一个字符的效果。那么最后栈中剩余的元素就是去掉退格字符后的所有剩余字符。然后就可以将两个栈中的字符依次比较是否相同。这种方法的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        Stack&lt;Character&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        Stack&lt;Character&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;S.length(); i++)&#123;            <span class="hljs-keyword">if</span>(S.charAt(i)!=<span class="hljs-string">'#'</span>) stack1.add(S.charAt(i));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack1.isEmpty()) stack1.pop();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;T.length(); j++)&#123;            <span class="hljs-keyword">if</span>(T.charAt(j)!=<span class="hljs-string">'#'</span>) stack2.add(T.charAt(j));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack2.isEmpty()) stack2.pop();        &#125;        <span class="hljs-keyword">return</span> stack1.equals(stack2);    &#125;&#125;</code></pre></div><div class="css-13ynzks-InfoWrap ejyx8z41"><div><div class="css-1493omj-TestcaseDiv ejyx8z42"><strong>110 / 110</strong> 个通过测试用例</div><span class="css-q5jqx5-DescSpan ejyx8z43">状态：<i class="css-1qe57zj-Status ejyx8z44">通过</i></span></div><div><div><div class="css-1493omj-TestcaseDiv ejyx8z42">执行用时: <strong>3 ms</strong></div><div class="css-1493omj-TestcaseDiv ejyx8z42">内存消耗: <strong>36.3 MB</strong></div></div></div></div><p>由于额外创建了两个辅助栈，所以时间复杂度还是有一些偏高。我们再尝试做一些改进：</p><p><strong>那么本题，确实可以使用栈的思路，但是没有必要使用栈，因为最后比较的时候还要比较栈里的元素，有点麻烦</strong>。为了减轻开销，可以使用拼接字符串的方式将剩余的字符进行拼接，最后进行比较的是便是两个字符串。这样就会比比较两个集合的元素是否相同还要更快。</p><p>我们使用<code>Java</code>中的<code>StringBuffe</code>r类来实现字符串的拼接。如果没有遇到#字符，则将该字符拼接到<code>StringBuffer</code>的对象中，否则删除<code>StringBuffer</code>对象的最后一个字符。最后返回两者对象的字符串进行比较。代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        build(S).equals(build(T));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">build</span><span class="hljs-params">(String str)</span> </span>&#123;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (str.charAt(i) != <span class="hljs-string">'#'</span>)                sb.append(str.charAt(i));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span>)                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><div class="css-13ynzks-InfoWrap ejyx8z41"><div><div class="css-1493omj-TestcaseDiv ejyx8z42"><strong>110 / 110</strong> 个通过测试用例</div><span class="css-q5jqx5-DescSpan ejyx8z43">状态：<i class="css-1qe57zj-Status ejyx8z44">通过</i></span></div><div><div><div class="css-1493omj-TestcaseDiv ejyx8z42">执行用时: <strong>1 ms</strong></div><div class="css-1493omj-TestcaseDiv ejyx8z42">内存消耗: <strong>36.4 MB</strong></div></div></div></div><p>两次的结果进行对比可以看到，从时间复杂度上，改进之后的方法执行时间更短。但是两次方法的内存消耗没有什么大的变化。有没有一种方法，既可以保持这种优秀的执行时间还保证内存消耗的更少呢？下面就介绍这种双指针的方法来减少内存消耗。</p><h2 id="方法二：双指针法："><a href="#方法二：双指针法：" class="headerlink" title="方法二：双指针法："></a>方法二：双指针法：</h2><p>同时从后向前遍历<code>S</code>和T（<code>i</code>初始为<code>S</code>末尾，<code>j</code>初始为<code>T</code>末尾），记录<code>#</code>的数量，模拟消除的操作，如果<code>#</code>用完了，就开始比较<code>S[i]</code>和<code>S[j]</code>。</p><p>具体地，我们定义 <code>skip</code> 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><ul><li><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 <code>skip</code> 加 <code>1</code>；</p></li><li><p>若该字符为普通字符：</p><ul><li><p>若 <code>skip</code>为 <code>0</code>，则说明当前字符不需要删去；</p></li><li><p>若<code>skip</code>不为 <code>0</code>，则说明当前字符需要删去，我们让<code>skip</code> 减 <code>1</code>。</p></li></ul></li></ul><img src="/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/motion.gif" srcset="/img/loading.gif" alt="比较含退格的字符串" style="zoom:100%;display: flex;margin: 0 auto;"><p>如果<code>S[i]</code>和<code>S[j]</code>不相同返回<code>false</code>，如果有一个指针（<code>i</code>或者<code>j</code>）先走到的字符串头部位置，也返回<code>false</code>。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        <span class="hljs-keyword">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> i = S.length()-<span class="hljs-number">1</span>, j = T.length()-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(S.charAt(i) == <span class="hljs-string">'#'</span>) skipS++;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(skipS&gt;<span class="hljs-number">0</span>) skipS--;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;                i--;            &#125;            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(T.charAt(j) == <span class="hljs-string">'#'</span>) skipT++;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(skipT&gt;<span class="hljs-number">0</span>) skipT--;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;                j--;            &#125;            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(S.charAt(i)!=T.charAt(j)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            i--;j--;        &#125;        <span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span> &amp;&amp; j == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p><strong>复杂度分析</strong></p><p>时间复杂度：<em>O</em>(<em>N</em>+<em>M</em>)，其中 <em>N</em> 和 <em>M</em> 分别为字符串 <em>S</em> 和 <em>T</em> 的长度。我们需要遍历两字符串各一次。</p><p>空间复杂度：<em>O</em>(1)。对于每个字符串，我们只需要定义一个指针和一个计数器即可。</p><div class="css-13ynzks-InfoWrap ejyx8z41"><div><div class="css-1493omj-TestcaseDiv ejyx8z42"><strong>110 / 110</strong> 个通过测试用例</div><span class="css-q5jqx5-DescSpan ejyx8z43">状态：<i class="css-1qe57zj-Status ejyx8z44">通过</i></span></div><div><div><div class="css-1493omj-TestcaseDiv ejyx8z42">执行用时: <strong>0 ms</strong></div><div class="css-1493omj-TestcaseDiv ejyx8z42">内存消耗: <strong>36.4 MB</strong></div></div></div></div>]]></content>
    
    
    <summary type="html">如何判断动态删除字符的字符串是否相同？</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    
    <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>学会Python装饰器（简易版）</title>
    <link href="http://yoursite.com/2020/10/18/%E5%AD%A6%E4%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/"/>
    <id>http://yoursite.com/2020/10/18/%E5%AD%A6%E4%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/</id>
    <published>2020-10-18T02:13:02.000Z</published>
    <updated>2020-10-18T02:34:51.542Z</updated>
    
    <content type="html"><![CDATA[<h2 data-tool="mdnice编辑器" style="font-weight: bold;color: black;font-size: 22px;margin-top: 20px;margin-right: 10px;"><span style="font-size: 18px;color: rgb(34, 34, 34);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(248, 57, 41);">学会 Python 装饰器</span><br></h2><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰器，几乎各大Python框架中都能看到它的身影，足以表明它的价值！它有动态改变函数或类功能的魔力！</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">1 什么是装饰器</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">对于受到封装的原函数比如<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>来说，装饰器能够在<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>函数<span style="font-weight: 700;color: rgb(248, 57, 41);">执行前</span>或者<span style="font-weight: 700;color: rgb(248, 57, 41);">执行后</span>分别运行一些代码。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">2 装饰器的结构</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰器也是一个函数，它装饰原函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>或类<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">cls</code>后，再返回一个函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">g</code></p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰一个函数：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">decorator</span><span style="line-height: 26px;">(f)</span>:</span><br>&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;定义要返回的函数</span><br>&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'函数f执行前的动作'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'函数f执行后的动作'</span>)<br>&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰一个类：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">decorator</span><span style="line-height: 26px;">(cls)</span>:</span><br>&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;定义要返回的函数</span><br>&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'类cls执行前的动作'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'类cls执行后的动作'</span>)<br>&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用装饰器很简单，@+自定义装饰器 装饰要想装饰的函数。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">3 为什么要这样</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">要想理解装饰器为什么要有这种结构，要首先想明白装饰器的目标是什么。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">它的价值在于为原函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>增加一些行为，前提必须不能破坏函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>，所以肯定不能改变f的内部结构，所以只能在调用f前后定义一些行为。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">同时，装饰器函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">decorator</code>返回值又是什么？你可以思考下，返回一个函数是再好不过的了，它包装了原函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>.</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">4 装饰一个函数</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">printStar函数接收一个函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>，返回值也是一个函数，所以满足装饰器的结构要求，所以printStar是一个装饰器。</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">printStar</span><span style="line-height: 26px;">(f)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">printStar装饰器实现f函数执行前、后各打印20个*字符。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用printStar:</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'hello&nbsp;world'</span>)<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">调用：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;__name__&nbsp;==&nbsp;<span style="color: #98c379;line-height: 26px;">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">###&nbsp;改变函数功能</span><br>&nbsp;&nbsp;&nbsp;f()<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">打印结果：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;">********************<br>hello&nbsp;world<br>********************<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">可以很方便的装饰要想装饰的其他函数，如下：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'welcome&nbsp;to&nbsp;Python'</span>)<br></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">5 装饰一个类</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">除了可以装饰函数f外，还可以装饰类cls，两者原理都是一样的。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">下面给出一个装饰器实现单例模式的例子，所谓单例就是类只有唯一实例，不能有第二个。</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">singleton</span><span style="line-height: 26px;">(cls)</span>:</span><br>&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;{}<br><br>&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">get_instance</span><span style="line-height: 26px;">(*args,&nbsp;**kwargs)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;cls&nbsp;<span style="color: #c678dd;line-height: 26px;">not</span>&nbsp;<span style="color: #c678dd;line-height: 26px;">in</span>&nbsp;instance:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance[cls]&nbsp;=&nbsp;cls(*args,&nbsp;**kwargs)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;instance[cls]<br>&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;get_instance<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">定义字典<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">instance</code>，键值对分别为类和实例，这样确保只cls()一次。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用装饰器singleton修饰类：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@singleton</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">class</span>&nbsp;<span style="color: #e6c07b;line-height: 26px;">CorePoint</span>:</span><br>&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">pass</span><br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">测试：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;__name__&nbsp;==&nbsp;<span style="color: #98c379;line-height: 26px;">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">###&nbsp;改变类的功能</span><br>&nbsp;&nbsp;&nbsp;c1&nbsp;=&nbsp;CorePoint()<br>&nbsp;&nbsp;&nbsp;c2&nbsp;=&nbsp;CorePoint()<br>&nbsp;&nbsp;&nbsp;print(c1&nbsp;<span style="color: #c678dd;line-height: 26px;">is</span>&nbsp;c2)&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;True</span><br></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">6 装饰器层叠</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">上面原函数f不仅能被一个装饰器修饰，还能被n多个装饰器修饰。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">下面再定义一个装饰器printLine，被修饰函数执行前后打印20个 -</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">printLine</span><span style="line-height: 26px;">(f)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'-'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'-'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用上文定义好的<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">printStar</code>和<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">printLine</code>同时装饰函数f：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="color: #61aeee;line-height: 26px;">@printLine</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'hello&nbsp;world'</span>)<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">此时再调用函数f:</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;__name__&nbsp;==&nbsp;<span style="color: #98c379;line-height: 26px;">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">###&nbsp;改变函数功能</span><br>&nbsp;&nbsp;&nbsp;f()<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">打印结果：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;">********************<br>--------------------<br>hello&nbsp;world<br>--------------------<br>********************<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">f被装饰后，先打印*，再打印 -</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">层叠多一层，原函数f就变强大一层。使用装饰器，还能实现功能抽离，进一步实现松耦合。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">7 温馨提醒</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">打印原函数f的名字<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">__name__</code>，结果为<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code></p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;">In&nbsp;[<span style="color: #d19a66;line-height: 26px;">1</span>]:&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span>&nbsp;<br>&nbsp;&nbsp;&nbsp;...:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">pass</span>&nbsp;<br><br>In&nbsp;[<span style="color: #d19a66;line-height: 26px;">4</span>]:&nbsp;f.__name__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Out[<span style="color: #d19a66;line-height: 26px;">4</span>]:&nbsp;<span style="color: #98c379;line-height: 26px;">'f'</span><br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">但是，被装饰后函数名字f变为g，这不是我们希望的！</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">pass</span><br><br>f()<br>f.__name__&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;g</span><br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">Python提供的解决方案：使用functools模块中的<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">wraps</code>装饰器：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">from</span>&nbsp;functools&nbsp;<span style="color: #c678dd;line-height: 26px;">import</span>&nbsp;wraps<br><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">printStar</span><span style="line-height: 26px;">(f)</span>:</span><br><span style="color: #61aeee;line-height: 26px;">&nbsp;&nbsp;&nbsp;&nbsp;@wraps(f)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">此时再打印被装饰后f的名字，显示f，正常！</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">总结</span><span style="display: none;"></span></h3><ul class="list-paddingleft-2" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;width: 567.205px;font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;font-size: 16px;letter-spacing: 0.8px;text-align: left;white-space: normal;word-spacing: 0.8px;color: rgb(248, 57, 41);"><li><p>学会 Python 装饰器</p></li><ul class="list-paddingleft-2" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;width: 541.658px;list-style-type: square;"><li><p>1 什么是装饰器</p></li><li><p>2 装饰器的结构</p></li><li><p>3 为什么要这样</p></li><li><p>4 装饰一个函数</p></li><li><p>5 装饰一个类</p></li><li><p>6 装饰器层叠</p></li><li><p>7 温馨提醒</p></li><li><p>总结</p></li></ul></ul><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">以上就是装饰器的核心使用逻辑专题，希望能帮助到各位读者，若觉得有用，欢迎大家分享！</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">推荐各位读者关注另一个公众号《刷题日记》，不仅仅是刷题...</p><img src="/2020/10/18/%E5%AD%A6%E4%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/640.webp" srcset="/img/loading.gif" alt="刷题日记" style="zoom:80%;display: flex;margin: 0 auto;"><h3 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247497338&idx=1&sn=b6a2637de1a79930ed9dd76695819403&chksm=eb7fdbb1dc0852a789f9fb7327041198596c3d85d0f731f5ce6d1a8eb354d6b11b053cd42711&scene=21#wechat_redirect" target="_blank" rel="noopener">搞定三大神器之 Python 装饰器</a></p>]]></content>
    
    
    <summary type="html">装饰器，几乎各大Python框架中都能看到它的身影，足以表明它的价值！它有动态改变函数或类功能的魔力！</summary>
    
    
    
    <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    <category term="语法" scheme="http://yoursite.com/categories/Python/%E8%AF%AD%E6%B3%95/"/>
    
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>机器学习项目（二）：房价预测</title>
    <link href="http://yoursite.com/2020/10/18/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/"/>
    <id>http://yoursite.com/2020/10/18/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/</id>
    <published>2020-10-18T01:59:39.000Z</published>
    <updated>2020-10-18T02:08:21.901Z</updated>
    
    <content type="html"><![CDATA[<p>数据集的下载地址为：</p><p><a href="train.csv">train.csv</a></p><p><a href="test.csv">test.csv</a></p><h3 id="首先导入我们程序所需要的几个包："><a href="#首先导入我们程序所需要的几个包：" class="headerlink" title="首先导入我们程序所需要的几个包："></a>首先导入我们程序所需要的几个包：</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer</code></pre></div><h1 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h1><p>加载数据，输出训练集和测试集的形状。</p><div class="hljs"><pre><code class="hljs python">x = pd.read_csv(<span class="hljs-string">'./data/train.csv'</span>, index_col=<span class="hljs-string">'Id'</span>)x_test = pd.read_csv(<span class="hljs-string">'./data/test.csv'</span>, index_col=<span class="hljs-string">'Id'</span>)print(<span class="hljs-string">'Train data size:&#123;&#125;'</span>.format(x.shape))print(<span class="hljs-string">'Test data size:&#123;&#125;'</span>.format(x_test.shape))</code></pre></div><div class="hljs"><pre><code class="hljs python">Train data size:(<span class="hljs-number">1460</span>, <span class="hljs-number">80</span>)Test data size:(<span class="hljs-number">1459</span>, <span class="hljs-number">79</span>)</code></pre></div><p>去掉输出值为空的行（样本），然后将输出值赋值给y变量，在训练集中删除输出值，使训练集和测试集的特征数量相等。<br>然后将训练数据分为训练集和验证集，分别占比<code>80%</code>和<code>20%</code>。</p><div class="hljs"><pre><code class="hljs python">x.dropna(axis=<span class="hljs-number">0</span>, subset=[<span class="hljs-string">'SalePrice'</span>], inplace=<span class="hljs-literal">True</span>)y = x[<span class="hljs-string">'SalePrice'</span>]x.drop([<span class="hljs-string">'SalePrice'</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)x_train, x_val, y_train, y_val = train_test_split(x, y, train_size=<span class="hljs-number">0.8</span>, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">0</span>)print(<span class="hljs-string">'Train data size:&#123;&#125;'</span>.format(x_train.shape))print(<span class="hljs-string">'Test data size:&#123;&#125;'</span>.format(x_val.shape))</code></pre></div><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>统计包含空值的属性列</p><div class="hljs"><pre><code class="hljs python">miss_count = x_train.isnull().sum()cols_with_missing = list(miss_count[miss_count &gt; <span class="hljs-number">0</span>].index)print(<span class="hljs-string">'Numbers of missing values:&#123;&#125;'</span>.format(len(cols_with_missing)))print(<span class="hljs-string">'Missing features:'</span>, cols_with_missing)</code></pre></div><p>统计包含分类变量的属性列</p><div class="hljs"><pre><code class="hljs python">categorical_features = (x_train.dtypes == <span class="hljs-string">'object'</span>)categorical_features_list = list(categorical_features[categorical_features].index)print(<span class="hljs-string">'Numbers of categorical features:&#123;&#125;'</span>.format(len(categorical_features_list)))print(<span class="hljs-string">'Categorical features:'</span>, categorical_features_list)</code></pre></div><h2 id="在处理空值的方法中，主要有以下几种："><a href="#在处理空值的方法中，主要有以下几种：" class="headerlink" title="在处理空值的方法中，主要有以下几种："></a>在处理空值的方法中，主要有以下几种：</h2><h3 id="1-直接删掉空值属性；"><a href="#1-直接删掉空值属性；" class="headerlink" title="1.直接删掉空值属性；"></a>1.直接删掉空值属性；</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Fill in the line below: get names of columns with missing values</span>column_missing = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> x_train.columns <span class="hljs-keyword">if</span> x_train[col].isnull().any()] <span class="hljs-comment"># Your code here</span><span class="hljs-comment"># Fill in the lines below: drop columns in training and validation data</span>reduced_x_train = x_train.drop(column_missing, axis=<span class="hljs-number">1</span>)reduced_x_val = x_val.drop(column_missing, axis=<span class="hljs-number">1</span>)</code></pre></div><h3 id="2-特殊值填充属性中的空值，例如：中位数；"><a href="#2-特殊值填充属性中的空值，例如：中位数；" class="headerlink" title="2.特殊值填充属性中的空值，例如：中位数；"></a>2.特殊值填充属性中的空值，例如：中位数；</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Fill in the lines below: imputation</span>my_impute = SimpleImputer(strategy=<span class="hljs-string">'median'</span>) <span class="hljs-comment"># Your code here</span>imputed_X_train = pd.DataFrame(my_impute.fit_transform(x_train))imputed_X_valid = pd.DataFrame(my_impute.transform(x_val))<span class="hljs-comment"># Fill in the lines below: imputation removed column names; put them back</span>imputed_X_train.columns = x_train.columnsimputed_X_valid.columns = x_val.columns</code></pre></div><h3 id="3-改进版的特殊值填充，设置标志位"><a href="#3-改进版的特殊值填充，设置标志位" class="headerlink" title="3. 改进版的特殊值填充，设置标志位"></a>3. 改进版的特殊值填充，设置标志位</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Make copy to avoid changing original data (when imputing)</span>x_train_plus = x_train.copy()x_val_plus = x_val.copy()<span class="hljs-comment"># Make new columns indicating what will be imputed</span><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> cols_with_missing:    x_train_plus[col + <span class="hljs-string">'_was_missing'</span>] = x_train_plus[col].isnull()    x_val_plus[col + <span class="hljs-string">'_was_missing'</span>] = x_val_plus[col].isnull()<span class="hljs-comment"># Imputation</span>my_imputer = SimpleImputer()imputed_x_train_plus = pd.DataFrame(my_imputer.fit_transform(x_train_plus))imputed_x_val_plus = pd.DataFrame(my_imputer.transform(x_val_plus))<span class="hljs-comment"># Imputation removed column names; put them back</span>imputed_x_train_plus.columns = x_train_plus.columnsimputed_x_val_plus.columns = x_val_plus.columns</code></pre></div><h2 id="在处理分类变量的方法中，主要有以下几种："><a href="#在处理分类变量的方法中，主要有以下几种：" class="headerlink" title="在处理分类变量的方法中，主要有以下几种："></a>在处理分类变量的方法中，主要有以下几种：</h2><h3 id="1-直接删掉分类变量的属性；"><a href="#1-直接删掉分类变量的属性；" class="headerlink" title="1.直接删掉分类变量的属性；"></a>1.直接删掉分类变量的属性；</h3><div class="hljs"><pre><code class="hljs python">drop_X_train = X_train.select_dtypes(exclude=[<span class="hljs-string">'object'</span>])drop_X_valid = X_valid.select_dtypes(exclude=[<span class="hljs-string">'object'</span>])</code></pre></div><h3 id="2-使用Label-Encoding；"><a href="#2-使用Label-Encoding；" class="headerlink" title="2.使用Label Encoding；"></a>2.使用Label Encoding；</h3><p>在对特征进行编码时，要考虑训练集的分类变量范围是否和训练集的分类变量范围相同，不多不少。如果不相同的情况，则直接删除掉范围不同的属性。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># All categorical columns</span>object_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> x.columns <span class="hljs-keyword">if</span> x_test[col].dtype == <span class="hljs-string">"object"</span>]<span class="hljs-comment"># Columns that can be safely label encoded</span>good_label_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> object_cols <span class="hljs-keyword">if</span>                    set(x[col]) == set(x_test[col])]        <span class="hljs-comment"># Problematic columns that will be dropped from the dataset</span>bad_label_cols = list(set(object_cols)-set(good_label_cols))        print(<span class="hljs-string">'Categorical columns that will be label encoded:\n'</span>, good_label_cols)print(<span class="hljs-string">'\nCategorical columns that will be dropped from the dataset:\n'</span>, bad_label_cols)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder<span class="hljs-comment"># Drop categorical columns that will not be encoded</span>label_x_train = x_train.drop(bad_label_cols, axis=<span class="hljs-number">1</span>)label_x_val = x_val.drop(bad_label_cols, axis=<span class="hljs-number">1</span>)label_x_test = x_test.drop(bad_label_cols, axis=<span class="hljs-number">1</span>)print(label_x_train.shape)print(label_x_val.shape)print(label_x_test.shape)<span class="hljs-comment"># label_x_train = x_train.select_dtypes(include=['object'])</span><span class="hljs-comment"># label_x_val = x_val.select_dtypes(include=['object'])</span><span class="hljs-comment"># label_x_test = x_test.select_dtypes(include=['object'])</span><span class="hljs-comment"># Apply label encoder to each column with categorical data</span>label_encoder = LabelEncoder()<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> good_label_cols:    label_x_train[col] = label_encoder.fit_transform(x_train[col])    label_x_val[col] = label_encoder.transform(x_val[col])    label_x_test[col] = label_encoder.transform(x_test[col])</code></pre></div><h3 id="3-使用One-Hot-Encoding；"><a href="#3-使用One-Hot-Encoding；" class="headerlink" title="3.使用One-Hot Encoding；"></a>3.使用One-Hot Encoding；</h3><p>在使用<code>One-Hot</code>编码之前先查看每个属性的基数，我们只将基数小的属性进行<code>One-Hot</code>编码，基数较大的使用<code>Label Encoding</code>编码比较方便。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Get number of unique entries in each column with categorical data</span>object_nunique = list(map(<span class="hljs-keyword">lambda</span> col: label_x_train[col].nunique(), object_cols))d = dict(zip(object_cols, object_nunique))<span class="hljs-comment"># Print number of unique entries by column, in ascending order</span>sorted(d.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Columns that will be one-hot encoded</span>low_cardinality_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> object_cols <span class="hljs-keyword">if</span> x[col].nunique() &lt; <span class="hljs-number">10</span>]<span class="hljs-comment"># Columns that will be dropped from the dataset</span>high_cardinality_cols = list(set(object_cols)-set(low_cardinality_cols))print(<span class="hljs-string">'Categorical columns that will be one-hot encoded:'</span>, low_cardinality_cols)print(<span class="hljs-string">'\nCategorical columns that will be dropped from the dataset:'</span>, high_cardinality_cols)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<span class="hljs-comment"># Use as many lines of code as you need!</span>oh_encoder = OneHotEncoder(handle_unknown=<span class="hljs-string">'ignore'</span>, sparse=<span class="hljs-literal">False</span>)print(x[low_cardinality_cols].describe())print(x_test[low_cardinality_cols].describe())OH_col_train = pd.DataFrame(oh_encoder.fit_transform(x[low_cardinality_cols]))OH_col_valid = pd.DataFrame(oh_encoder.transform(x_test[low_cardinality_cols]))OH_col_train.index = x.indexOH_col_valid.index = x_test.indexnum_x_train = x.drop(low_cardinality_cols, axis=<span class="hljs-number">1</span>)num_x_valid = x_test.drop(low_cardinality_cols, axis=<span class="hljs-number">1</span>)num_x_train = num_x_train.drop(high_cardinality_cols, axis=<span class="hljs-number">1</span>)num_x_valid = num_x_valid.drop(high_cardinality_cols, axis=<span class="hljs-number">1</span>)OH_x_train = pd.concat([num_x_train, OH_col_train], axis=<span class="hljs-number">1</span>)OH_x_valid = pd.concat([num_x_valid, OH_col_valid], axis=<span class="hljs-number">1</span>)</code></pre></div><h1 id="管道搭建模型"><a href="#管道搭建模型" class="headerlink" title="管道搭建模型"></a>管道搭建模型</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># "Cardinality" means the number of unique values in a column</span><span class="hljs-comment"># Select categorical columns with relatively low cardinality (convenient but arbitrary)</span>categorical_cols = [cname <span class="hljs-keyword">for</span> cname <span class="hljs-keyword">in</span> X_train_full.columns <span class="hljs-keyword">if</span>                    X_train_full[cname].nunique() &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">and</span>                     X_train_full[cname].dtype == <span class="hljs-string">"object"</span>]<span class="hljs-comment"># Select numerical columns</span>numerical_cols = [cname <span class="hljs-keyword">for</span> cname <span class="hljs-keyword">in</span> X_train_full.columns <span class="hljs-keyword">if</span>                 X_train_full[cname].dtype <span class="hljs-keyword">in</span> [<span class="hljs-string">'int64'</span>, <span class="hljs-string">'float64'</span>]]<span class="hljs-comment"># Keep selected columns only</span>my_cols = categorical_cols + numerical_colsX_train = X_train_full[my_cols].copy()X_valid = X_valid_full[my_cols].copy()X_test = X_test_full[my_cols].copy()</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.compose <span class="hljs-keyword">import</span> ColumnTransformer<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline<span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<span class="hljs-comment"># Preprocessing for numerical data</span>numerical_transformer = SimpleImputer(strategy=<span class="hljs-string">'constant'</span>)<span class="hljs-comment"># Preprocessing for categorical data</span>categorical_transformer = Pipeline(steps=[    (<span class="hljs-string">'imputer'</span>, SimpleImputer(strategy=<span class="hljs-string">'most_frequent'</span>)),    (<span class="hljs-string">'onehot'</span>, OneHotEncoder(handle_unknown=<span class="hljs-string">'ignore'</span>))])<span class="hljs-comment"># Bundle preprocessing for numerical and categorical data</span>preprocessor = ColumnTransformer(    transformers=[        (<span class="hljs-string">'num'</span>, numerical_transformer, numerical_cols),        (<span class="hljs-string">'cat'</span>, categorical_transformer, categorical_cols)    ])</code></pre></div><h1 id="使用XGBoost训练"><a href="#使用XGBoost训练" class="headerlink" title="使用XGBoost训练"></a>使用XGBoost训练</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Define the model</span>my_model_2 = XGBRegressor(n_estimators=<span class="hljs-number">1000</span>, learning_rate=<span class="hljs-number">0.05</span>, n_jobs=<span class="hljs-number">4</span>)<span class="hljs-comment"># Fit the model</span>my_model_2.fit(X_train,                y_train,                early_stopping_rounds=<span class="hljs-number">5</span>,                eval_set=[(X_valid, y_valid)],               verbose=<span class="hljs-literal">False</span>) <span class="hljs-comment"># Your code here</span><span class="hljs-comment"># Get predictions</span>predictions_2 = my_model_2.predict(X_valid)<span class="hljs-comment"># Calculate MAE</span>mae_2 = mean_absolute_error(predictions_2, y_valid)<span class="hljs-comment"># print MAE</span>print(<span class="hljs-string">"Mean Absolute Error:"</span> , mae_2)</code></pre></div>]]></content>
    
    
    <summary type="html">如何使用机器学习模型从以往的历史数据中预测房价？</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
    <category term="scikit-learn" scheme="http://yoursite.com/tags/scikit-learn/"/>
    
  </entry>
  
  <entry>
    <title>机器学习项目（一）：泰坦尼克号的幸存者</title>
    <link href="http://yoursite.com/2020/10/17/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/"/>
    <id>http://yoursite.com/2020/10/17/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/</id>
    <published>2020-10-17T14:48:28.000Z</published>
    <updated>2020-10-18T02:02:02.183Z</updated>
    
    <content type="html"><![CDATA[<div style="color:white"></div><p style="text-indent: 2em;"></p><p class="note note-primary">    这里我们以泰坦尼克号幸存者数据集进行第一个机器学习项目</p><p>数据集的下载地址为：</p><p><a href="titanic_train.csv">titanic_train.csv</a></p><p>导包，导入数据集并分割数据集</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_splittitanic = pandas.read_csv(<span class="hljs-string">'./titanic_train.csv'</span>)</code></pre></div><p>输出输出的前几行，查看各列属性等</p><div class="hljs"><pre><code class="hljs python">titanic.head()</code></pre></div><img src="/2020/10/17/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/head.JPG" srcset="/img/loading.gif" alt="数据前5行" style="zoom:100%;display: flex;margin: 0 auto;"><br><br><p>下面简单介绍一下各列属性的含义，详细信息请见链接：<a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a></p><table><tbody><tr><th><b>Variable</b></th><th><b>Definition</b></th><th><b>Key</b></th></tr><tr><td>survival</td><td>Survival</td><td>0 = No, 1 = Yes</td></tr><tr><td>pclass</td><td>Ticket class</td><td>1 = 1st, 2 = 2nd, 3 = 3rd</td></tr><tr><td>sex</td><td>Sex</td><td></td></tr><tr><td>Age</td><td>Age in years</td><td></td></tr><tr><td>sibsp</td><td># of siblings / spouses aboard the Titanic</td><td></td></tr><tr><td>parch</td><td># of parents / children aboard the Titanic</td><td></td></tr><tr><td>ticket</td><td>Ticket number</td><td></td></tr><tr><td>fare</td><td>Passenger fare</td><td></td></tr><tr><td>cabin</td><td>Cabin number</td><td></td></tr><tr><td>embarked</td><td>Port of Embarkation</td><td>C = Cherbourg, Q = Queenstown, S = Southampton</td></tr></tbody></table><p>下一步分离数据特征和预测目标</p><div class="hljs"><pre><code class="hljs python">y = titanic[<span class="hljs-string">'Survived'</span>]x = titanic.drop([<span class="hljs-string">'Survived'</span>], axis=<span class="hljs-number">1</span>)print(x.shape)print(y.shape)</code></pre></div><div class="hljs"><pre><code class="hljs python">(<span class="hljs-number">891</span>, <span class="hljs-number">11</span>)(<span class="hljs-number">891</span>,)</code></pre></div><p>统计缺失数据，数据类型等情况。</p><div class="hljs"><pre><code class="hljs python">print(x.info())</code></pre></div><div class="hljs"><pre><code class="hljs python">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">pandas</span>.<span class="hljs-title">core</span>.<span class="hljs-title">frame</span>.<span class="hljs-title">DataFrame</span>'&gt;</span><span class="hljs-class"><span class="hljs-title">RangeIndex</span>:</span> <span class="hljs-number">891</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">890</span>Data columns (total <span class="hljs-number">11</span> columns): <span class="hljs-comment">#   Column       Non-Null Count  Dtype  </span>---  ------       --------------  -----   <span class="hljs-number">0</span>   PassengerId  <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">1</span>   Pclass       <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">2</span>   Name         <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">3</span>   Sex          <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">4</span>   Age          <span class="hljs-number">714</span> non-null    float64 <span class="hljs-number">5</span>   SibSp        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">6</span>   Parch        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">7</span>   Ticket       <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">8</span>   Fare         <span class="hljs-number">891</span> non-null    float64 <span class="hljs-number">9</span>   Cabin        <span class="hljs-number">204</span> non-null    object  <span class="hljs-number">10</span>  Embarked     <span class="hljs-number">889</span> non-null    object dtypes: float64(<span class="hljs-number">2</span>), int64(<span class="hljs-number">4</span>), object(<span class="hljs-number">5</span>)memory usage: <span class="hljs-number">76.7</span>+ KB<span class="hljs-literal">None</span></code></pre></div><p>从上面的输出信息可以看到：</p><ol><li>数据中一共有11个属性列，891个训练样本。</li><li>这些数据类型中有2个属性的数据类型为<code>float</code>，4个属性的数据类型为<code>int</code>，5个属性的数据类型为字符串类型，即为分类变量。</li><li>这些属性列中，<code>Age</code>属性，<code>Cabin</code>属性和<code>Embarked</code>属性列有空值，需要进一步处理。</li></ol><p>下面对空值进行处理，数据类型和文本类型的处理手段不同。<br><code>Age</code>属性使用已有的年龄属性的平均值进行填充。<br>字符串类型的空值统一标记为<code>Unknown</code>。</p><div class="hljs"><pre><code class="hljs python">x[<span class="hljs-string">'Age'</span>].fillna(x[<span class="hljs-string">'Age'</span>].mean(), inplace=<span class="hljs-literal">True</span>)x.fillna(<span class="hljs-string">'Unknown'</span>, inplace=<span class="hljs-literal">True</span>)print(x.info())</code></pre></div><div class="hljs"><pre><code class="hljs python">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">pandas</span>.<span class="hljs-title">core</span>.<span class="hljs-title">frame</span>.<span class="hljs-title">DataFrame</span>'&gt;</span><span class="hljs-class"><span class="hljs-title">RangeIndex</span>:</span> <span class="hljs-number">891</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">890</span>Data columns (total <span class="hljs-number">11</span> columns): <span class="hljs-comment">#   Column       Non-Null Count  Dtype  </span>---  ------       --------------  -----   <span class="hljs-number">0</span>   PassengerId  <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">1</span>   Pclass       <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">2</span>   Name         <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">3</span>   Sex          <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">4</span>   Age          <span class="hljs-number">891</span> non-null    float64 <span class="hljs-number">5</span>   SibSp        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">6</span>   Parch        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">7</span>   Ticket       <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">8</span>   Fare         <span class="hljs-number">891</span> non-null    float64 <span class="hljs-number">9</span>   Cabin        <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">10</span>  Embarked     <span class="hljs-number">891</span> non-null    object dtypes: float64(<span class="hljs-number">2</span>), int64(<span class="hljs-number">4</span>), object(<span class="hljs-number">5</span>)memory usage: <span class="hljs-number">76.7</span>+ KB<span class="hljs-literal">None</span></code></pre></div><p>可以看到数据被补全了，可以进行下一步操作。</p><p>下一步分割数据集，<code>25%</code>的数据用于测试集，<code>75%</code>的数据用于训练集。</p><div class="hljs"><pre><code class="hljs python">X_train, X_test, y_train, y_test = train_test_split(x, y, train_size=<span class="hljs-number">.75</span>, random_state=<span class="hljs-number">33</span>)</code></pre></div><p>下一步要处理的是分类变量，即建立分类变量的编码问题，这里选择使用<code>DictVectorizer</code>。</p><p><code>DictVectorizer</code>的处理对象是符号化(非数字化)的但是具有一定结构的特征数据，如字典等，将符号转成数字<code>0/1</code>表示。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_extraction <span class="hljs-keyword">import</span> DictVectorizervec = DictVectorizer()X_train = vec.fit_transform(X_train.to_dict(orient=<span class="hljs-string">'record'</span>))X_test = vec.transform(X_test.to_dict(orient=<span class="hljs-string">'record'</span>))print(len(vec.feature_names_))</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">1352</span></code></pre></div><p>输出建立分类变量的数据</p><div class="hljs"><pre><code class="hljs python">print(X_train.toarray()[:<span class="hljs-number">10</span>, :<span class="hljs-number">5</span>])</code></pre></div><div class="hljs"><pre><code class="hljs python">[[<span class="hljs-number">47.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">40.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">29.69911765</span>  <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">22.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">23.5</span>         <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">47.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">27.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">24.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">29.69911765</span>  <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">29.69911765</span>  <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ]]</code></pre></div><p>我们不难发现，<code>DictVectorizer</code>对非数字化的处理方式是，借助原特征的名称，组合成新的特征，并采用<code>0/1</code>的方式进行量化，而数值型的特征转化比较方便，一般情况维持原值即可。</p><p>对数据处理完毕后，开始对模型进行训练。这里我们使用随机森林模型对所有特征进行预测，并作性能评估。这里使用循环的方法找到最佳的参数<code>max_depth</code>。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifiermaxid, maxval = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">45</span>):    forest = RandomForestClassifier(max_depth=i, random_state=<span class="hljs-number">33</span>)    forest.fit(X_train, y_train)    score = forest.score(X_test, y_test)    <span class="hljs-keyword">if</span> maxval &lt; score:        maxval = score        maxid = iprint(maxid, maxval)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">28</span> <span class="hljs-number">0.874439461883408</span></code></pre></div><p>这里，我们选择<code>max_depth=10</code>为树的最大深度。开始训练模型：</p><div class="hljs"><pre><code class="hljs python">best_forest = RandomForestClassifier(max_depth=<span class="hljs-number">10</span>, random_state=<span class="hljs-number">33</span>)best_forest.fit(X_train, y_train)score = best_forest.score(X_test, y_test)print(score)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">0.8026905829596412</span></code></pre></div><p>总体来讲，良好的数据特征组合不需太多便可以使得模型的性能表现突出。比如，我们“良/恶性乳腺癌肿瘤预测”问题中，仅仅使用两个描述肿瘤形态的特征便可以取得很高的识别率。冗余的特征虽然不会影响到模型的性能，不过却使得CPU的计算做了无用功。比如，主成分分析主要用于去除多余的那些线性相关的特征组合，原因在于这些冗余的特征组合并不会对模型训练有更多贡献。而不良的特征自然会降低模型的精度。</p><p>特征筛选与<code>PCA</code>这类通过选择主成分对特征进行重建的方法略有区别:对于<code>PCA</code>而言，我们经常无法解释重建之后的特征；但是特征筛选不存在对特征值的修改，而更加侧重于寻找那些对模型的性能提升较大的少量特征。</p><p>这里我们在代码中继续沿用 Titanic据集，这次试图通过特征筛选来寻找最佳的特征组合，并且达到提高预测准确性的目标。</p><p>从<code>sklearn</code>中导入特征筛选器</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> feature_selectionfs = feature_selection.SelectPercentile(feature_selection.chi2, percentile=<span class="hljs-number">20</span>)</code></pre></div><div class="hljs"><pre><code class="hljs python">X_train_fs = fs.fit_transform(X_train, y_train)best_forest.fit(X_train_fs, y_train)fs_score = best_forest.score(fs.transform(X_test), y_test)print(fs_score)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">0.8295964125560538</span></code></pre></div><p>可以看到结果，在选择了前<code>20%</code>的属性进行模型的训练得到了一个比全属性进行训练更好的结果。准确率达到了<code>82.96%</code>。</p><p>这样，我们就完成了一个简单的模型，虽然没有对模型做过多的优化，后续的优化环节，在后续的博客中进行介绍。</p>]]></content>
    
    
    <summary type="html">Start here! Predict survival on the Titanic and get familiar with ML basics.</summary>
    
    
    
    <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="kaggle" scheme="http://yoursite.com/tags/kaggle/"/>
    
    <category term="scikit-learn" scheme="http://yoursite.com/tags/scikit-learn/"/>
    
  </entry>
  
  <entry>
    <title>更好，更快，更强壮的YOLOv2</title>
    <link href="http://yoursite.com/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/"/>
    <id>http://yoursite.com/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/</id>
    <published>2020-10-14T11:59:04.000Z</published>
    <updated>2020-10-19T15:13:35.226Z</updated>
    
    <content type="html"><![CDATA[<style>    .center{        width: auto;        display: table;        margin-left: auto;        margin-right: auto;    }    .mine{       text-indent: 2em;          margin: 10px 0px;    }    .markdown-body p > img, .markdown-body p > a > img {    box-shadow: none;}</style><p class="note note-warning">    YOLO9000(YOLO9000：Better, Faster, Stronger)是YOLO算法的改进版，YOLOv2相对v1版本，在继续保持处理速度的基础上，从预测更准确（Better），速度更快（Faster），识别对象更多（Stronger）这三个方面进行了改进。其中识别更多对象也就是扩展到能够检测9000种不同对象，所以称之为YOLO9000。</p><p>在保证目标召回率的同时，为了提高准确率和速度，<code>YOLOv2</code>并没有使用太深的网络这样也使得网络容易学习，主要做了以下几方面的改进：</p><ol><li><strong>Batch Normalization</strong>：在每个卷积层中加入批归一化，使<strong>mAP</strong>有了<code>2%</code>的提高。批归一化处理能够获得更好的收敛速度和收敛效果，减少过拟合的发生。</li><li><strong>High Resolution Classifier</strong>：采用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/224.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">图像进行分类模型预训练后，再采用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/448.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的高分辨率样本对分类模型进行<code>10</code>个<strong>epoch</strong>的微调，使网络特征逐渐适应<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/448.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的分辨率。然后再使用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/448.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的检测样本进行训练，缓解了分辨率突然切换造成的影响。</li><li><strong>Anchor Boxes</strong>：引入<strong>Anchor Boxes</strong>的思想后，使原来的每张图片预测<code>98</code>个<strong>Bounding-box</strong>增长到每张图片可以预测上千个<strong>Bounding-box</strong>。<strong>YOLOv2</strong>移除了全连接层、去掉了一个池化层，使网络卷积层输出具有更高的分辨率。同时减小输入图像的尺寸到<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/416.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">，这样在下采样因子为<code>32</code>的情况下，<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/13.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征图能正好有一个网格在正中心。相对<strong>YOLOv1</strong>的<code>81%</code>的召回率，<strong>YOLOv2</strong>的召回率大幅提升到<code>88%</code>。同时<strong>mAP</strong>有<code>0.2%</code>的轻微下降。</li><li><strong>Dimension Clusters</strong>：对训练集中标注的边框进行<code>k-means</code>聚类分析，设计出更符合样本中对象尺寸的先验框（Prior Boxes），这样就可以减少网络微调先验框到实际位置的难度。<strong>YOLOv2</strong>选择<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/k=5.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">作为边框数量与<code>IOU</code>的折中。如图1所示。</li></ol><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/iou.png" srcset="/img/loading.gif" alt="k-means聚类得到的IOU" style="zoom:50%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 1 k-means聚类得到的IOU</div><p>对比手工选择的<strong>Anchor Boxes</strong>，使用<code>5</code>个聚类得到的<strong>Prior Boxes</strong>即可达到<code>61.0</code>的<strong>Avg IOU</strong>，相当于<code>9</code>个手工设置的<strong>Anchor Boxes</strong> <code>60.9</code>的<strong>Avg IOU</strong>。如下图2所示：</p><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/avgiou.png" srcset="/img/loading.gif" alt="k取不同值时的Avg IOU" style="zoom:70%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 2 k取不同值时的Avg IOU</div><ol start="5"><li><p><strong>Direct Location Prediction</strong>：在使用<strong>Anchor Box</strong>时出现了预测边框的中心可能出现在任何位置的情况，导致训练早期阶段不容易稳定。因此<strong>YOLO</strong>调整了预测公式，将预测边框的中心约束在特定<code>gird</code>网格内。预测边框的蓝色中心点被约束在蓝色背景的网格内。如图3所示，约束边框位置使得模型更容易学习，且预测更为稳定。这种方式将<strong>mAP</strong>提高了<code>5%</code>。</p><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/priorbox.png" srcset="/img/loading.gif" alt="利用Prior Box对预测框定位" style="zoom:30%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图3 利用Prior Box对预测框定位</div></li><li><p><strong>Passthrough Layer</strong>： 输入<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/416.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">经过卷积网络下采样最后输出是<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/13.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">，较小的对象可能特征已经不明显甚至被忽略掉了。为了更好的检测出一些比较小的对象，<strong>YOLOv2</strong>引入一种称为<code>passthrough</code>层的方法在特征图中保留上一次池化之前的<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/26.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征。也就是说将<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/26512.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征图转化为<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/132048.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。然后直接传递到<code>pooling</code>后（并且又经过一组卷积）的特征图，两者叠加到一起作为输出<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/133072.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征图，使得<strong>MAP</strong>提高了<code>1%</code>。</p></li><li><p><strong>Multi-Scale Training</strong>：为了能使<strong>YOLOv2</strong>在不同尺寸的图片上鲁棒性更强，这里加入了多尺度的图像训练。因为去掉了全连接层，<strong>YOLOv2</strong>可以输入任何尺寸的图像。因为整个网络下采样倍数是<code>32</code>，作者采用了<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/seq.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">等<strong>10</strong>种输入图像的尺寸，这些尺寸的输入图像对应输出的特征图宽和高是<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/feaseq.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。训练时每<code>10</code>个<strong>batch</strong>就随机更换一种尺寸，使网络能够适应各种大小的对象检测。</p></li></ol><div class="mine">   YOLOv2提出了Darknet-19（有19个卷积层和5个池化层）网络结构。Darknet-19比VGG-16小一些，精度不弱于VGG-16。YOLOv2的训练主要包括三个阶段：</div><ul><li><p>第一阶段就是先预训练<strong>Darknet-19</strong>，模型输入为<code>224×224</code>，共训练<code>160</code>个<strong>epochs</strong>。</p></li><li><p>第二阶段将网络的输入调整为<code>448×448</code>，继续<strong>finetune</strong>分类模型。</p></li><li><p>第三个阶段就是修改<strong>Darknet-19</strong>分类模型为检测模型，移除最后一个卷积层、<strong><em>global avg pooling</em></strong>层以及<strong><em>softmax</em></strong>层，并且新增了三个<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/21024.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">卷积层，同时增加了一个<strong>passthrough</strong>层，最后使用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/1.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">卷积层输出预测结果，输出的<strong>channels</strong>数为：<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/channel.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。由于<strong>Anchors</strong>数为<code>5</code>，对于<strong>VOC</strong>数据集（20种分类对象）输出的<strong>channels</strong>数就是<code>125</code>，最终的输出的特征大小为:</p></li></ul><p>$$<br>(13, 13, 5,25)<br>$$</p><div class="mine">   YOLOv2和其他的算法在Pascal VOC 2007数据集上的比较结果如下表：</div><div class="center">    <table><thead><tr><th>Detection Frameworks</th><th>Train</th><th>mAP</th><th>FPS</th></tr></thead><tbody><tr><td>YOLO</td><td>2007+2012</td><td>63.4</td><td>45</td></tr><tr><td>Fast R-CNN</td><td>2007+2012</td><td>70.0</td><td>0.5</td></tr><tr><td>Faster R-CNN VGG-16</td><td>2007+2012</td><td>73.2</td><td>7</td></tr><tr><td>YOLOv2 288×288</td><td>2007+2012</td><td>69.0</td><td>91</td></tr><tr><td>YOLOv2 352×352</td><td>2007+2012</td><td>73.7</td><td>81</td></tr><tr><td>YOLOv2 416×416</td><td>2007+2012</td><td>76.8</td><td>67</td></tr><tr><td>YOLOv2 480×480</td><td>2007+2012</td><td>77.8</td><td>59</td></tr><tr><td>YOLOv2 544×544</td><td>2007+2012</td><td>78.6</td><td>40</td></tr></tbody></table></div><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    表1 YOLOv2与其他算法的性能比较</div><div class="mine">    为了能够使模型检测出更多的分类，作者又提出了一种对COCO数据集和ImageNet数据集上联合训练的方式可以检测出9000个类别的物体的YOLO9000，使得YOLOv2即使没有学过很多对象的检测样本，也能检测出这些对象。</div><div class="mine">    由于ImageNet的对象类别与COCO的对象类别不是互斥的。这样就不适合用单个softmax来做对象分类，而是要采用一种多标签分类模型。将ImageNet和COCO中的名词对象一起构建了一个WordTree，以physical object为根节点，各名词依据相互间的关系构建树枝、树叶，节点间的连接表达了对象概念之间的蕴含关系。</div><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/wordtree.png" srcset="/img/loading.gif" alt="利用Prior Box对预测框定位" style="zoom:50%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图4 WordTree名词关系树</div><p>对于单个节点，属于它的所有子节点之间是互斥关系，所以计算上可以进行<strong><em>softmax</em></strong>操作。实际中每个节点下的所有子节点都会进行<strong><em>softmax</em></strong>.</p><p>有标签的样本对应的<strong>WordTree</strong>中，该对象节点到根节点的所有节点概率都是<code>1</code>，其它节点概率是<code>0</code>。根据训练标签的设置，其实模型学习的是各节点的条件概率。</p><br><p>$$<br>Pr⁡(Norfolk terrier)=Pr⁡(Norfolk terrier│terrier)×Pr⁡(terrier│hunting dog)<br>$$</p><p>$$<br>×…×Pr⁡(mammal│animal)×Pr(animal|physical object)<br>$$<br>为了计算简便，从根节点开始向下遍历，对每一个节点，在它的所有子节点中，选择概率最大的那个，一直向下遍历直到某个节点的子节点概率低于设定的阈值，或达到叶子节点，那么该节点就是该<strong><em>WordTree</em></strong>对应的对象。</p><p><strong>YOLO9000</strong>依然采用<strong>YOLOv2</strong>的网络结构，使用<code>3</code>个先验框，现在<strong>YOLO9000</strong>的输出是<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/hahah.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。由于对象分类改成<strong>WordTree</strong>的形式，相应的误差计算也需要一些调整。对一个检测样本，其分类误差只包含该标签节点以及到根节点的所有节点的误差。对于分类样本，则只计算分类误差。<strong>YOLO9000</strong>总共输出<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/preboc.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">个预测框，计算它们对样本标签的预测概率，选择概率最大的那个框负责预测该样本的对象，即计算其<strong>WordTree</strong>的误差。</p><p>总的来说，<strong>YOLOv2</strong>通过一些改进明显提升了预测准确性，同时继续保持其运行速度快的优势。<strong>YOLO9000</strong>则开创性的提出联合使用分类样本和检测样本的训练方法，使对象检测能够扩展到缺乏检测样本的对象。</p>]]></content>
    
    
    <summary type="html">YOLOv2相对v1版本，在继续保持处理速度的基础上，从预测更准确，速度更快，识别对象更多这三个方面进行了改进。</summary>
    
    
    
    <category term="目标检测（Object Detection）" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88Object-Detection%EF%BC%89/"/>
    
    
    <category term="YOLO" scheme="http://yoursite.com/tags/YOLO/"/>
    
    <category term="One-Stage" scheme="http://yoursite.com/tags/One-Stage/"/>
    
  </entry>
  
  <entry>
    <title>开创性的YOLO</title>
    <link href="http://yoursite.com/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/"/>
    <id>http://yoursite.com/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/</id>
    <published>2020-10-10T10:10:48.000Z</published>
    <updated>2020-10-11T11:49:59.010Z</updated>
    
    <content type="html"><![CDATA[<style>    .center{        width: auto;        display: table;        margin-left: auto;        margin-right: auto;    }    .mine{       text-indent: 2em;          margin: 10px 0px;    }</style><p class="note note-primary">    Faster R-CNN系列等两阶段（Two-Stage）的目标检测算法有较好的检测效果和较高的检测精度，但从速度上来讲满足不了实时检测的要求。基于回归方法的深度学习目标检测就显得尤为重要了。使用回归的思想，输入的图片经过网络直接计算出物体的分类，位置信息以达到目标检测的目的。</p><p><strong>YOLO（You only look once：Unified ,Real-Time Object Detection）</strong>是基于回归的方法中最经典的算法之一。YOLO采用单个神经网络全图直接训练预测物品边界和类别概率，模型的最后直接输出Bounding-box 的坐标、 Bounding-box 中包含物体的置信度和物体的类别。从而实现真正意义上的端到端的物品检测。识别性能有了很大提升，在 Titan X 的 GPU 上能达到<strong>45 FPS</strong>，而在Fast YOLO(卷积层更少)中，可以达到155 FPS。<br>YOLO预测阶段的流程如下，流程图如图1所示：</p><img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/yolov1img2.png" srcset="/img/loading.gif" alt="YOLO网络结构" style="zoom:50%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 1 YOLO网络结构，整个网络由24个卷积层和2个全连接层。网络先在224×224尺寸的ImageNet数据集上进行预训练分类任务，之后将图像尺寸翻倍进行检测任务。</div><p>1)  将图像缩放到<code>448×448</code>尺寸作为卷积神经网络的输入，并对图像划分成<code>S×S</code>的网格。</p><p>2)  经过CNN后到达FC层，最后一层的FC输出<code>4096</code>个神经元 </p><p>3)  FC层的输出作为检测层（Detection层）的输入，在1）中将原图分为<code>7×7</code>的网格，对于每个网格，我们都预测<code>B</code>个Bounding-box，包括每个Bounding-box的<code>4</code>个位置信息，网格包含目标的置信度。另外每个网格还预测<code>C</code>个类别上的概率。最终得到<br>$$<br>S×S×(B×5+C)<br>$$<br>大小的特征图，输出的特征图结构如下。</p><img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/yolooutputt.png" srcset="/img/loading.gif" alt="YOLO网络结构" style="zoom:30%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 2 输出的特征向量</div><p>YOLO在PASCAL VOC数据集上进行评估，数据集中类别有<code>C=20</code>个。所以输出的特征向量大小为<br>$$<br>S×S×(B×5+C) = 7×7×(2×5+20)=(7,7,30)<br>$$</p><div class="mine">    最后根据阈值去除分类概率比较低的目标窗口，最后使用NMS算法去除冗余窗口，得到最后的目标窗口。</div><div class="mine">可以看到整个预测过程非常简单，不需要中间的**region proposal**找目标，直接回归便完成了位置和类别的判定。</div><p>YOLO网络模型的架构思想如图3所示，我们将初始大小为<code>448×448</code>大小的图像分为<code>7×7</code>的网格，每个网格的大小为<code>64×64</code>。如果一个物体的中心点落在这个网格内，那么这个网格负责预测这个物体。每个网格预测两个Bounding-box，每个Bounding-box对应预测除了四个位置参数外，还有一个参数叫<strong>置信度(confidence)</strong>的值，表达式为如下所示：<br>$$<br>confidence= P_r (Object)×IOU(truth|pred)<br>$$</p><div class="mine">其中，<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image002.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">表示这个网格是否包含目标物体，若包含目标物体则<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image003.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">，否则<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image004.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">。<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image005.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">表示ground truth和prediction的重叠率。还会预测出网格中存在目标物体的条件下属于那一类别物体的后验概率!<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image006.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">。</div><img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/yolov1img1.png" srcset="/img/loading.gif" alt="YOLO网络结构" style="zoom:40%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图3 将图像分为S×S的网格，每个网格预测两个边界框和对应网格的类别概率，最后回归得到物体的边界框和分类</div><div class="mine">    在预测分类时，每个Bounding-box的得分其实是confidence和后验概率的乘积。得分公式如下所示：</div><p>$$<br>Score=confidence×P_r (Class_i |Object)=P_r (Class_i )×IOU(truth|pred)<br>$$</p><div class="mine">    得到这个得分后再通过NMS算法过滤掉小于阈值的边界框，得到最终的边界框。    </div><div class="mine">    YOLO网络的卷积层采取的是类似GoogLeNet的结构，采用1×1大小的卷积核减少计算量。在ImageNet数据集上的预训练中，采用的是前20层的卷积层后加一个全连接层的结构。在预训练完分类任务后，将网络结构转化为检测网络，在20层卷积后又添加了4个卷积层和两个全连接层来执行检测任务。因为检测的过程中需要图像中更加细粒度的信息，所以将原图像尺寸增加到448×448进行检测任务。根据图片的宽高将Bounding-box的宽高归一化到[0,1]之间，中心点坐标设置为网格左上角顶点的偏移量，使用多任务的损失函数直接回归边界框，物体类别，置信度等信息。</div><div class="mine">    YOLO和其他的算法在Pascal VOC 2007数据集上的比较结果如下表：</div><div class="center">    <table><thead><tr><th>Real-Time Detectors</th><th>Train</th><th>mAP</th><th>FPS</th></tr></thead><tbody><tr><td>Fast YOLO</td><td>2007+2012</td><td>52.7</td><td>155</td></tr><tr><td>YOLO</td><td>2007+2012</td><td>63.4</td><td>45</td></tr></tbody></table></div><div class="center"><table><thead><tr><th>Less Than Real-Time</th><th>Train</th><th>mAP</th><th>FPS</th></tr></thead><tbody><tr><td>Fast R-CNN</td><td>2007+2012</td><td>70.0</td><td>0.5</td></tr><tr><td>Faster R-CNN VGG-16</td><td>2007+2012</td><td>73.2</td><td>7</td></tr></tbody></table></div><div class="mine">    可以看到回归方法的目标检测的FPS是很高的，但精度还有待提高。同时YOLO算法还存在几点不足：</div><ol><li>YOLO的每一个网格只预测两个边界框，一种类别。这导致模型对相邻目标预测准确率下降。因此，YOLO对集群的目标或小的目标识别准确率较低。</li><li>损失函数会同样的对待小边界框与大边界框的误差，导致了目标区域定位的误差偏大和召回率较低。</li></ol>]]></content>
    
    
    <summary type="html">YOLO算法是目标检测问题的回归思想的解决方案，是One-Stage算法的最具有代表性的一个。</summary>
    
    
    
    <category term="目标检测（Object Detection）" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88Object-Detection%EF%BC%89/"/>
    
    
    <category term="YOLO" scheme="http://yoursite.com/tags/YOLO/"/>
    
    <category term="One-Stage" scheme="http://yoursite.com/tags/One-Stage/"/>
    
  </entry>
  
  <entry>
    <title>MMDetection教程（二）训练数据集并分析</title>
    <link href="http://yoursite.com/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E5%88%86%E6%9E%90/</id>
    <published>2020-09-30T02:51:35.000Z</published>
    <updated>2020-10-10T11:20:40.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MMDetection（二）训练数据集并分析"><a href="#MMDetection（二）训练数据集并分析" class="headerlink" title="MMDetection（二）训练数据集并分析"></a>MMDetection（二）训练数据集并分析</h1><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="查找模型配置文件"><a href="#查找模型配置文件" class="headerlink" title="查找模型配置文件"></a>查找模型配置文件</h3><p>以<code>Faster RCNN</code>为例，讲解如何找到模型的配置文件和权重文件</p><ol><li><p>首先找到模型的配置文件<code>mmdetection/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</code>,这里以<code>ResNet50</code>作为backbone, 使用<code>FPN</code>为多层特征提取的网络配置文件.</p></li><li><p>打开配置文件得到以下信息:</p><div class="hljs"><pre><code class="hljs python">_base_ = [    <span class="hljs-string">'../_base_/models/faster_rcnn_r50_fpn.py'</span>,    <span class="hljs-string">'../_base_/datasets/coco_detection.py'</span>,    <span class="hljs-string">'../_base_/schedules/schedule_1x.py'</span>, <span class="hljs-string">'../_base_/default_runtime.py'</span>]</code></pre></div><p>这里可以看到四个文件:</p><ul><li><code>../_base_/models/faster_rcnn_r50_fpn.py</code>为模型的源码,配置文件.</li><li><code>../_base_/datasets/coco_detection.py</code>为训练模型使用的数据集的一些配置,比如数据集的预处理,缩放,数据集路径等信息.</li><li><code>../_base_/schedules/schedule_1x.py</code>为模型训练方式,其中包含优化器,学习率修改测率和训练的轮回数.</li><li><code>../_base_/default_runtime.py</code>为默认的训练运行时,其中包含保存断点权重的间隔数等.一般不需要修改.</li></ul></li><li><p>得到这些<code>configs</code>后,可以对这些文件进行修改了,也可以创建新的文件</p></li></ol><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ol><li><p>定义数据种类，需要修改的地方在<code>mmdetection/mmdet/datasets/coco.py</code>。把CLASSES的那个tuple改为自己数据集对应的种类tuple即可。例如：</p><div class="hljs"><pre><code class="hljs python">CLASSES = (<span class="hljs-string">'0B'</span>, <span class="hljs-string">'1B'</span>, <span class="hljs-string">'2B'</span>)</code></pre></div></li><li><p>接着在<code>mmdetection/mmdet/core/evaluation/class_names.py</code>修改coco_classes数据集类别，这个关系到后面test的时候结果图中显示的类别名称。例如：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coco_classes</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">'0B'</span>, <span class="hljs-string">'1B'</span>, <span class="hljs-string">'2B'</span>]</code></pre></div></li></ol><ol start="3"><li><p>修改<code>configs/_base_/datasets/coco_detection.py</code>中<code>train_pipeline</code>和<code>test_pipeline</code>中的<code>img_scale</code>:</p><div class="hljs"><pre><code class="hljs python">dataset_type = <span class="hljs-string">'CocoDataset'</span>data_root = <span class="hljs-string">'data/coco/'</span>img_norm_cfg = dict(    mean=[<span class="hljs-number">0.471</span>,<span class="hljs-number">0.448</span>,<span class="hljs-number">0.408</span>], std=[<span class="hljs-number">0.234</span>,<span class="hljs-number">0.239</span>,<span class="hljs-number">0.242</span>], to_rgb=<span class="hljs-literal">True</span>)train_pipeline = [    dict(type=<span class="hljs-string">'LoadImageFromFile'</span>),    dict(type=<span class="hljs-string">'LoadAnnotations'</span>, with_bbox=<span class="hljs-literal">True</span>),    dict(type=<span class="hljs-string">'Resize'</span>, img_scale=(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>), keep_ratio=<span class="hljs-literal">True</span>),    dict(type=<span class="hljs-string">'RandomFlip'</span>, flip_ratio=<span class="hljs-number">0.5</span>),    dict(type=<span class="hljs-string">'Normalize'</span>, **img_norm_cfg),    dict(type=<span class="hljs-string">'Pad'</span>, size_divisor=<span class="hljs-number">32</span>),    dict(type=<span class="hljs-string">'DefaultFormatBundle'</span>),    dict(type=<span class="hljs-string">'Collect'</span>, keys=[<span class="hljs-string">'img'</span>, <span class="hljs-string">'gt_bboxes'</span>, <span class="hljs-string">'gt_labels'</span>]),]test_pipeline = [    dict(type=<span class="hljs-string">'LoadImageFromFile'</span>),    dict(        type=<span class="hljs-string">'MultiScaleFlipAug'</span>,        <span class="hljs-comment"># 图像大小尺寸缩放</span>        img_scale=(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>),        flip=<span class="hljs-literal">False</span>,        transforms=[            dict(type=<span class="hljs-string">'Resize'</span>, keep_ratio=<span class="hljs-literal">True</span>),            dict(type=<span class="hljs-string">'RandomFlip'</span>),            dict(type=<span class="hljs-string">'Normalize'</span>, **img_norm_cfg),            dict(type=<span class="hljs-string">'Pad'</span>, size_divisor=<span class="hljs-number">32</span>),            dict(type=<span class="hljs-string">'ImageToTensor'</span>, keys=[<span class="hljs-string">'img'</span>]),            dict(type=<span class="hljs-string">'Collect'</span>, keys=[<span class="hljs-string">'img'</span>]),        ])]data = dict(    samples_per_gpu=<span class="hljs-number">2</span>,    workers_per_gpu=<span class="hljs-number">2</span>,    train=dict(        type=dataset_type,        <span class="hljs-comment"># 标记文件路径 和 数据集路径</span>        ann_file=data_root + <span class="hljs-string">'annotations/instances_train2017.json'</span>,        img_prefix=data_root + <span class="hljs-string">'train2017/'</span>,        pipeline=train_pipeline),    val=dict(        type=dataset_type,        ann_file=data_root + <span class="hljs-string">'annotations/instances_val2017.json'</span>,        img_prefix=data_root + <span class="hljs-string">'val2017/'</span>,        pipeline=test_pipeline),    test=dict(        type=dataset_type,        ann_file=data_root + <span class="hljs-string">'annotations/instances_test2017.json'</span>,        img_prefix=data_root + <span class="hljs-string">'test2017/'</span>,        pipeline=test_pipeline))evaluation = dict(interval=<span class="hljs-number">1</span>, metric=<span class="hljs-string">'bbox'</span>)</code></pre></div></li></ol><ol start="4"><li><p>修改<code>models/faster_rcnn_r50_fpn.py</code>中的<code>num_classes</code>:</p><div class="hljs"><pre><code class="hljs python">model = dict(    type=<span class="hljs-string">'FasterRCNN'</span>,    pretrained=<span class="hljs-string">'torchvision://resnet50'</span>,    backbone=dict(        type=<span class="hljs-string">'ResNet'</span>,        depth=<span class="hljs-number">50</span>,        num_stages=<span class="hljs-number">4</span>,        out_indices=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>),        frozen_stages=<span class="hljs-number">1</span>,        norm_cfg=dict(type=<span class="hljs-string">'BN'</span>, requires_grad=<span class="hljs-literal">True</span>),        norm_eval=<span class="hljs-literal">True</span>,        style=<span class="hljs-string">'pytorch'</span>),    neck=dict(        type=<span class="hljs-string">'FPN'</span>,        in_channels=[<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">2048</span>],        out_channels=<span class="hljs-number">256</span>,        num_outs=<span class="hljs-number">5</span>),    rpn_head=dict(        type=<span class="hljs-string">'RPNHead'</span>,        in_channels=<span class="hljs-number">256</span>,        feat_channels=<span class="hljs-number">256</span>,        anchor_generator=dict(            type=<span class="hljs-string">'AnchorGenerator'</span>,            scales=[<span class="hljs-number">8</span>],            ratios=[<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>],            strides=[<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>]),        bbox_coder=dict(            type=<span class="hljs-string">'DeltaXYWHBBoxCoder'</span>,            target_means=[<span class="hljs-number">.0</span>, <span class="hljs-number">.0</span>, <span class="hljs-number">.0</span>, <span class="hljs-number">.0</span>],            target_stds=[<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>]),        loss_cls=dict(            type=<span class="hljs-string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="hljs-literal">True</span>, loss_weight=<span class="hljs-number">1.0</span>),        loss_bbox=dict(type=<span class="hljs-string">'L1Loss'</span>, loss_weight=<span class="hljs-number">1.0</span>)),    roi_head=dict(        type=<span class="hljs-string">'StandardRoIHead'</span>,        bbox_roi_extractor=dict(            type=<span class="hljs-string">'SingleRoIExtractor'</span>,            roi_layer=dict(type=<span class="hljs-string">'RoIAlign'</span>, output_size=<span class="hljs-number">7</span>, sampling_ratio=<span class="hljs-number">0</span>),            out_channels=<span class="hljs-number">256</span>,            featmap_strides=[<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>]),        bbox_head=dict(            type=<span class="hljs-string">'Shared2FCBBoxHead'</span>,            in_channels=<span class="hljs-number">256</span>,            fc_out_channels=<span class="hljs-number">1024</span>,            roi_feat_size=<span class="hljs-number">7</span>,            <span class="hljs-comment">#类别数</span>            num_classes=<span class="hljs-number">3</span>,            bbox_coder=dict(                type=<span class="hljs-string">'DeltaXYWHBBoxCoder'</span>,                target_means=[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],                target_stds=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>]),            reg_class_agnostic=<span class="hljs-literal">False</span>,            loss_cls=dict(                type=<span class="hljs-string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="hljs-literal">False</span>, loss_weight=<span class="hljs-number">1.0</span>),            loss_bbox=dict(type=<span class="hljs-string">'L1Loss'</span>, loss_weight=<span class="hljs-number">1.0</span>))))<span class="hljs-comment"># model training and testing settings</span>.........</code></pre></div></li></ol><ol start="5"><li><p>修改<code>_base_/schedules/schedule_1x.py</code>中的配置:</p><div class="hljs"><pre><code class="hljs python">optimizer = dict(type=<span class="hljs-string">'SGD'</span>, lr=<span class="hljs-number">0.0025</span>, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">0.0001</span>) <span class="hljs-comment">#当gpu数量为8时,lr=0.02；当gpu数量为8时,lr=0.01；我只要一个gpu，所以设置lr=0.0025</span></code></pre></div><p>还可以修改训练的周期数.</p></li></ol><ol start="6"><li>在<code>mmdetection</code>的目录下新建<code>work_dirs</code>文件夹</li></ol><h3 id="使用单GPU训练"><a href="#使用单GPU训练" class="headerlink" title="使用单GPU训练"></a>使用单GPU训练</h3><div class="hljs"><pre><code class="hljs shell">python tools/train.py $&#123;CONFIG_FILE&#125; [optional arguments]</code></pre></div><p>如果您想在命令中指定工作目录（保存训练过程日志等信息）, 你可以添加参数 <code>--work-dir ${YOUR_WORK_DIR}</code>.</p><h3 id="使用多GPU训练"><a href="#使用多GPU训练" class="headerlink" title="使用多GPU训练"></a>使用多GPU训练</h3><div class="hljs"><pre><code class="hljs shell">./tools/dist_train.sh $&#123;CONFIG_FILE&#125; $&#123;GPU_NUM&#125; [optional arguments]</code></pre></div><p>可选参数:</p><ul><li><code>--work-dir ${WORK_DIR}</code>: 指定工作目录（保存训练过程日志等信息）</li><li><code>--resume-from ${CHECKPOINT_FILE}</code>: 从之前的断点文件中继续训练</li></ul><p>例如：</p><div class="hljs"><pre><code class="hljs shell">python tools/train.py configs/cascade_rcnn/cascade_rcnn_r101_fpn_20e_coco.py --work-dir cascade_rcnn</code></pre></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试数据集"><a href="#测试数据集" class="headerlink" title="测试数据集"></a>测试数据集</h3><p>可以使用单GPU和多GPU对测试数据进行测试，使用如下命令：</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 单GPU测试</span>python tools/test.py $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--out $&#123;RESULT_FILE&#125;] [--eval $&#123;EVAL_METRICS&#125;] [--show] [--cfg-options]<span class="hljs-meta">#</span><span class="bash"> 多GPU测试</span>./tools/dist_test.sh $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; $&#123;GPU_NUM&#125; [--out $&#123;RESULT_FILE&#125;] [--eval $&#123;EVAL_METRICS&#125;] [--cfg-options]</code></pre></div><p>可选参数:</p><ul><li><p><code>RESULT_FILE</code>: 输出结果保存为pickle格式在指定目录下，如果不指定该参数，输出结果不保存。</p></li><li><p><code>EVAL_METRICS</code>: 评价结果的标准。根据数据集可选择的评价标准有： <code>proposal_fast</code>, <code>proposal</code>, <code>bbox</code>, <code>segm</code> 可用在COCO数据集上； <code>mAP</code>, <code>recall</code> 可用在PASCAL VOC数据集上。</p></li><li><p><code>--show</code>: 如果指定，检测结果将绘制在图像上并显示在一个新窗口中。仅适用于单GPU测试，用于调试和可视化。请确保GUI在你的环境中可用，否则您可能会遇到类似“无法连接到X服务器”的错误。</p></li><li><p><code>--show-dir</code>: 如果指定，检测结果将绘制在图像上并保存到指定的目录中。仅适用于单GPU测试，用于调试和可视化。使用此选项时，环境中可以不需要可用的GUI。</p></li><li><p><code>--show-score-thr</code>: 如果指定，则将删除分数低于此阈值的检测。</p></li></ul><p>测试Faster R-CNN模型，并将结果可视化展示在窗口中，按任意键切换下一张图片：</p><div class="hljs"><pre><code class="hljs shell">python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py save/epoch_9.pth --show detection_results --eval bbox</code></pre></div><p>测试Faster R-CNN模型，不将结果可视化展示在窗口中，保存在文件中，为方便后续的可视化：</p><div class="hljs"><pre><code class="hljs shell">python tools/test.py configs/grid_rcnn/grid_rcnn_x101_64x4d_fpn_gn-head_2x_coco.py grid_rcnn/epoch_25.pth --show-dir detection_results --eval bbox</code></pre></div><h3 id="测试单张图片"><a href="#测试单张图片" class="headerlink" title="测试单张图片"></a>测试单张图片</h3><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py $&#123;IMAGE_FILE&#125; $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--device $&#123;GPU_ID&#125;] [--score-thr $&#123;SCORE_THR&#125;]</code></pre></div><p>例如使用Faster R-CNN模型测试<code>demo.jpg</code>图片，输入如下命令：</p><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py demo/demo.jpg configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \    checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth --device cpu</code></pre></div><h2 id="分析训练日志"><a href="#分析训练日志" class="headerlink" title="分析训练日志"></a>分析训练日志</h2><p>通过训练生成的log文件可以画出loss/mAP曲线。首先需要安装<code>pip install seaborn</code>依赖。</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py plot_curve [--keys $&#123;KEYS&#125;] [--title $&#123;TITLE&#125;] [--legend $&#123;LEGEND&#125;] [--backend $&#123;BACKEND&#125;] [--style $&#123;STYLE&#125;] [--out $&#123;OUT_FILE&#125;]</code></pre></div><p>绘制分类损失：</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py plot_curve faster_rcnn_1x_res50/20200928_120614.log.json --keys loss_cls loss_bbox --legend loss_cls loss_bbox</code></pre></div><p>绘制分类损失和边界框损失：</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py plot_curve log.json --keys loss_cls loss_bbox</code></pre></div><p>计算平均训练时间：</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py cal_train_time log.json</code></pre></div><p>输出的格式如下：</p><div class="hljs"><pre><code class="hljs python">-----Analyze train time of save/<span class="hljs-number">20200927</span>_095440.log.json-----slowest epoch <span class="hljs-number">6</span>, average time <span class="hljs-keyword">is</span> <span class="hljs-number">0.1322</span>fastest epoch <span class="hljs-number">7</span>, average time <span class="hljs-keyword">is</span> <span class="hljs-number">0.1202</span>time std over epochs <span class="hljs-keyword">is</span> <span class="hljs-number">0.0033</span>average iter time: <span class="hljs-number">0.1271</span> s/iter</code></pre></div>]]></content>
    
    
    <summary type="html">MMDetection is an open source object detection toolbox based on PyTorch. It is a part of the OpenMMLab project developed by Multimedia Laboratory, CUHK.</summary>
    
    
    
    <category term="目标检测（Object Detection）" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88Object-Detection%EF%BC%89/"/>
    
    
    <category term="PyTorch" scheme="http://yoursite.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>MMDetection教程（一）数据测试</title>
    <link href="http://yoursite.com/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95/"/>
    <id>http://yoursite.com/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95/</id>
    <published>2020-09-30T02:50:54.000Z</published>
    <updated>2020-10-10T11:20:49.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MMDetection教程（一）数据测试"><a href="#MMDetection教程（一）数据测试" class="headerlink" title="MMDetection教程（一）数据测试"></a>MMDetection教程（一）数据测试</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试单张图片"><a href="#测试单张图片" class="headerlink" title="测试单张图片"></a>测试单张图片</h3><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py $&#123;IMAGE_FILE&#125; $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--device $&#123;GPU_ID&#125;] [--score-thr $&#123;SCORE_THR&#125;]</code></pre></div><p>例如使用Faster R-CNN模型测试<code>demo.jpg</code>图片，输入如下命令：</p><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py demo/demo.jpg configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \    checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth --device cpu</code></pre></div><h3 id="高阶API整合"><a href="#高阶API整合" class="headerlink" title="高阶API整合"></a>高阶API整合</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmdet.apis <span class="hljs-keyword">import</span> inference_detector, init_detector<span class="hljs-comment"># 训练配置文件</span>config = <span class="hljs-string">'configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py'</span><span class="hljs-comment"># 网络权重路径</span>checkpoint = <span class="hljs-string">'checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'</span><span class="hljs-comment"># 创建模型</span>model = init_detector(config, checkpoint, device=<span class="hljs-string">'cuda:0'</span>)<span class="hljs-comment"># 示例图片</span>img = <span class="hljs-string">'demo/demo.jpg'</span><span class="hljs-comment"># inference</span>result = inference_detector(model, img)<span class="hljs-comment"># 在新窗口中展示检测结果</span>model.show_result(img, result)<span class="hljs-comment"># 将检测结果保存在文件中</span>model.show_result(img, result, out_file=<span class="hljs-string">'result.jpg'</span>)</code></pre></div>]]></content>
    
    
    <summary type="html">MMDetection is an open source object detection toolbox based on PyTorch. It is a part of the OpenMMLab project developed by Multimedia Laboratory, CUHK.</summary>
    
    
    
    <category term="目标检测（Object Detection）" scheme="http://yoursite.com/categories/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88Object-Detection%EF%BC%89/"/>
    
    
    <category term="PyTorch" scheme="http://yoursite.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>一文学会回溯算法解题技巧</title>
    <link href="http://yoursite.com/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</id>
    <published>2020-09-20T07:25:29.000Z</published>
    <updated>2020-09-20T07:49:52.743Z</updated>
    
    <content type="html"><![CDATA[<p>以下文章来源于码海 ，作者码海</p><blockquote><p>来源：码海</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650565386&idx=1&sn=e49c4418d462f742d3063de76959be85&chksm=f1fedd89c689549f1ef6b430132573546b80e3d278bc6c4cd1524ea51db2b5d564b8373e69e7&scene=21#wechat_redirect" target="_blank" rel="noopener">上文</a>我们学习了深度优先搜索和广度优先搜索，相信大家对这两者的算法有了比较清楚的认识，值得一提的，深度优先算法用到了回溯的算法思想，这个算法虽然相对比较简单，但很重要，在生产上广泛用在正则表达式，编译原理的语法分析等地方，很多经典的面试题也可以用回溯算法来解决，如八皇后问题，排列组合问题，0-1背包问题，数独问题等，也是一种非常重要的算法。</p><p>本文将会从以下几个方面来讲述回溯算法，相信大家看了肯定有收获！</p><ol><li>什么是回溯算法</li><li>回溯算法解题通用套路</li><li>经典习题讲解</li></ol><h2 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a><strong>什么是回溯算法</strong></h2><p>回溯算法本质其实就是枚举，在给定的枚举集合中，不断从其中尝试搜索找到问题的解，如果在搜索过程中发现不满足求解条件 ，则「回溯」返回，尝试其它路径继续搜索解决，这种走不通就回退再尝试其它路径的方法就是回溯法，许多复杂的，规模较大的问题都可以使用回溯法，所以回溯法有「通用解题方法」的美称。</p><h2 id="回溯算法解题通用套路"><a href="#回溯算法解题通用套路" class="headerlink" title="回溯算法解题通用套路"></a><strong>回溯算法解题通用套路</strong></h2><p>为了有规律地求解问题，我们把问题分成多个阶段，每个阶段都有多个解，随机选择一个解，进入下一个阶段，下一个阶段也随机选择一个解，再进入下一个阶段…</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/0.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>每个阶段选中的解都放入一个 「已选解集合」 中，并且要判断 「已选解集合」是否满足问题的条件（base case）,有两种情况</p><ol><li>如果「已选解集合」满足问题的条件，则将 「已选解集合」放入「结果集」中，并且「回溯」换个解再遍历。</li><li>如果不满足，则「回溯」换个解再遍历</li></ol><p>根据以上描述不难得出回溯算法的通用解决套路伪代码如下:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">backtrace</span><span class="hljs-params">(已选解集合,每个阶段可选解)</span> </span>&#123;    <span class="hljs-keyword">if</span> (已选解集合满足条件) &#123;        结果集.add(已选解集合);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 遍历每个阶段的可选解集合</span>    <span class="hljs-keyword">for</span> (可选解 in 每个阶段的可选解) &#123;        <span class="hljs-comment">// 选择此阶段其中一个解,将其加入到已选解集合中</span>        已选解集合.add(可选解)        <span class="hljs-comment">// 进入下一个阶段</span>        backtrace(已选解集合,下个阶段可选的空间解)        <span class="hljs-comment">// 「回溯」换个解再遍历</span>        已选解集合.remove(可选解)    &#125;&#125;</code></pre></div><p>通过以上分析我们不难发现回溯算法本质上就是深度优先遍历，它一般解决的是树形问题（问题分解成多个阶段，每个阶段有多个解，这样就构成了一颗树），所以判断问题是否可以用回溯算法的关键在于它是否可以转成一个树形问题。</p><p>另外我们也发现如果能缩小每个阶段的可选解，就能让问题的搜索规模都缩小，这种就叫「剪枝」，通过剪枝能有效地降低整个问题的搜索复杂度！之前我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650564819&idx=1&sn=d9bb77b1f6da35198cea065eec697143&chksm=f1fede50c6895746de12e536961e49ec8bdd294254b7a1459296c66bf254be6d32fb7ee6a218&scene=21#wechat_redirect" target="_blank" rel="noopener">一文学会递归解题</a>中求解斐波那契问题时就用到了减枝的技巧，使问题的空间大大减少（如下图示）</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/1.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>综上，我们可以得出回溯算法的基本套路如下：</p><ol><li>将问题分成多个阶段，每个阶段都有多个不同的解，这样就将问题转化成了树形问题，这一步是问题的关键！如果能将问题转成树形问题，其实就成功了一半，需要注意的是树形问题要明确终止条件，这样可以在 DFS 的过程中及时终止遍历，达到剪枝的效果</li><li>套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解。</li></ol><p>只要两个步骤，是不是很简单！接下来我们套用以上的解题模板来看看怎么使用以上回溯算法解题套路来解几道经典的问题。</p><h2 id="经典习题讲解"><a href="#经典习题讲解" class="headerlink" title="经典习题讲解"></a><strong>经典习题讲解</strong></h2><p><strong>一、全排列</strong></p><blockquote><p>给定数字 1，2，3，求出 3 位不重复数字的全排列</p></blockquote><p><strong>1、将问题转为树形结构</strong></p><p>由于求的是 3 位数的全排列，所以问题分解为 3 个阶段，第一个阶段可以选 1，2，3 三个解，如果第一阶段选完数字后，第二个阶段可以选另外 2 个解，同理第三个阶段也可以选择剩下一个解。树形结构如下：</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/2.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>2、套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解</p><p>代码如下:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结果集</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; RESULT = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">10</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 参与全排列的数字</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; NUMS = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 遍历当前阶段的解</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedNums   已选解集合</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectableNums 可选的解集合</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">permutation</span><span class="hljs-params">(List&lt;Integer&gt; selectedNums, List&lt;Integer&gt; selectableNums &#123;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">        // 满足条件，加入结果集</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">if</span> (selectedNums.size()</span> </span>== NUMS.size()) &#123;            RESULT.add(Arrays.toString(selectedNums.toArray()));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历每个阶段的可选解集合</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectableNums.size(); i++) &#123;            Integer num = selectableNums.get(i);            <span class="hljs-comment">// 去除不符合条件的解，减枝</span>            <span class="hljs-keyword">if</span> (selectedNums.contains(num)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 选择当前阶段其中一个解</span>            selectedNums.add(num);            <span class="hljs-comment">// 选完之后再进入下个阶段遍历</span>            permutation(selectedNums, selectableNums);            <span class="hljs-comment">// 回溯,换一个解继续遍历</span>            selectedNums.remove(num);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; selectedNums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        permutation(selectedNums, NUMS);        System.out.println(Arrays.toString(RESULT.toArray()));    &#125;&#125;</code></pre></div><p>为了让大家更好地理解上述代码，我一步步地画出了每个阶段的解题图解，对照着以上代码看相信大家应该能看明白</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/3.JPG" srcset="/img/loading.gif" style="zoom:100%;display: flex;margin: 0 auto;"><p><strong>二、0-1背包问题</strong></p><p>这里介绍一下一种比较简单的背包问题：</p><blockquote><p>有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？假设这 n 个物品的质量分别  3kg, 4kg, 6kg, 8kg，背包总的承载重量是 10kg。</p></blockquote><p>套用回溯算法解题思路</p><p><strong>1、将问题转为树形结构</strong></p><p>由于有 n 个物品，所以问题可以分解成 n 个阶段，第一个阶段可以有 n 个物品可选，第二个阶段有 n-1 个物品可选,,,,,,最后一个阶段有 1 个物品可选，不难画出以下递归树</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/4.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>既然能转成树形结构，那我们进入步骤 2</p><p><strong>2、套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解</strong></p><p>需要注意的，进行 DFS 的终止条件是什么呢，显然是所选物品质量（遍历的节点）和大于等于背包质量，稍加变形不难得出以下代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结果集</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer RESULT = <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 背包最大承载质量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer KNAPSACK_MAX_WEIGHT = <span class="hljs-number">10</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 现有背包</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; WEIGHTS = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 遍历当前阶段的解</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedWeights  已选解集合</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectableWeight 可选的解集合</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(List&lt;Integer&gt; selectedWeights, List&lt;Integer&gt; selectableWeight)</span> </span>&#123;        &#123;            <span class="hljs-comment">// 求已选物品的总重量</span>            <span class="hljs-keyword">int</span> sumOfWeights = selectedWeights.stream().mapToInt(Integer::intValue).sum();            <span class="hljs-keyword">if</span> (sumOfWeights == KNAPSACK_MAX_WEIGHT) &#123;                RESULT = Math.max(RESULT, sumOfWeights);                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sumOfWeights &gt; KNAPSACK_MAX_WEIGHT) &#123;                <span class="hljs-comment">// 如果已选物品的总重量超过背包最大承受质量，则要把最后一个选择的物品移除，再求质量和</span>                selectedWeights.remove(selectedWeights.size() - <span class="hljs-number">1</span>);                sumOfWeights = selectedWeights.stream().mapToInt(Integer::intValue).sum();                RESULT = Math.max(RESULT, sumOfWeights);                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                RESULT = Math.max(RESULT, sumOfWeights);            &#125;        &#125;        <span class="hljs-comment">// 遍历每个阶段的可选解集合</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectableWeight.size(); i++) &#123;            Integer num = selectableWeight.get(i);            <span class="hljs-comment">// 去除不符合条件的解，减枝</span>            <span class="hljs-keyword">if</span> (selectedWeights.contains(num)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 选择子节点的其中一个解</span>            selectedWeights.add(num);            <span class="hljs-comment">// 选完之后再进行 dfs</span>            knapsack(selectedWeights, selectableWeight);            <span class="hljs-comment">// 「回溯」换个解再遍历</span>            selectedWeights.remove(num);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; selectedNums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        knapsack(selectedNums, WEIGHTS);        System.out.println(<span class="hljs-string">"result = "</span> + RESULT);    &#125;&#125;</code></pre></div><p>可以看到套用模板我们又轻松解决了0-1背包问题，可能有人会说以上问题比较简单，接下来我们来看看如何用上模板来解八皇后问题。</p><p><strong>3、八皇后</strong></p><p>老读者对八皇后问题应该并不陌生，之前我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650565284&idx=1&sn=33f7d3dc982b2b550f30a24479a9fe4f&chksm=f1fedc27c689553167f471b3b4d080bcb13bf60825d73262f55f2bbe2639835ff71ab4b78f33&scene=21#wechat_redirect" target="_blank" rel="noopener">位运算</a>的文章中详细地讲解了如何用位运算来求解八皇后问题，当时也说了，用位运算来求解，是效率最高的，其实八皇后问题也可以用我们的回溯算法来求解，只不过不是那么高效而已，不过可读性更好。</p><p>来简单回顾上什么是八皇后问题。</p><blockquote><p>八皇后问题：8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子</p></blockquote><p>如下所示是 8 皇后问题的一种放法。</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/5.JPG" srcset="/img/loading.gif" style="zoom:100%;display: flex;margin: 0 auto;"><p><strong>1、将问题转为树形结构</strong></p><p>对于 N 皇后问题，问题可以分解为 N 个阶段， 第一个阶段即第一行有 N 个解（N 列中的做生意一个解）， 第二阶段（第二行）由于受第一行限制（皇后所在列，斜线不能放），解肯定是少于 N 个解，它的解视第一行所放皇后位置而定,… ，第 N 个阶段的解受前面 N-1 个阶段解的影响。N 皇后树形结构如下</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/6.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p><strong>2、套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解</strong></p><p>套用以上模板时，注意终止条件与每个阶段（每一行）所选解是否合法（剪枝）即可。注意看下 queenSettle 的方法，这是套用我们的回溯算法解题模板所得出来的，其他方法都是在此模板上进行添砖加瓦而已。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer N = <span class="hljs-number">8</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedColumns 已选解集合,下标表示行,值表示queen存储在哪一列</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row             可选的空间解,第 n 行可选</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queenSettle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] selectedColumns, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (row &gt; N - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 说明前 N 行都已经都选完皇后了，</span>            printQueens(selectedColumns);            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++) &#123;            <span class="hljs-comment">// 剔除不合法的格子</span>            <span class="hljs-keyword">if</span> (!isValid(row, i, selectedColumns)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 选择子节点（当前行）其中一个解</span>            selectedColumns[row] = i;            <span class="hljs-comment">// 选完之后再进入下个阶段的（下一行）遍历</span>            queenSettle(selectedColumns, row + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 回溯,换一个解继续 dfs，回溯时要把回溯节点的解移除</span>            selectedColumns[row] = -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断相应的格子放置皇后是否OK</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> column</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedColumns</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span>[] selectedColumns)</span> </span>&#123;        <span class="hljs-comment">//判断row行column列放置是否合适</span>        <span class="hljs-keyword">int</span> leftup = column - <span class="hljs-number">1</span>, rightup = column + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 逐行往上考察每一行</span>            <span class="hljs-keyword">if</span> (selectedColumns[i] == column) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 第i行的column列有棋子吗？</span>            <span class="hljs-keyword">if</span> (leftup &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 考察左上对角线：第i行leftup列有棋子吗？</span>                <span class="hljs-keyword">if</span> (selectedColumns[i] == leftup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">if</span> (rightup &lt; <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 考察右上对角线：第i行rightup列有棋子吗？</span>                <span class="hljs-keyword">if</span> (selectedColumns[i] == rightup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            --leftup; ++rightup;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] selectedColumn = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];        <span class="hljs-comment">// 从第 0 行开始 DFS</span>        queenSettle(selectedColumn, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] result)</span> </span>&#123; <span class="hljs-comment">// 打印出一个二维矩阵</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">8</span>; ++row) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123;                <span class="hljs-keyword">if</span> (result[row] == column) System.out.print(<span class="hljs-string">"Q "</span>);                <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">"* "</span>);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;&#125;</code></pre></div><p>可以看到八皇后这么复杂的问题套用以上的解题模板也被我们轻松解决了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>使用回溯算法解题的关键是把问题分成多阶段，每个阶段都有相应的解，于是就把问题转成了树形问题，转成树形问题后，剩下的只需要套用上文总结的解题模板即可，尤其需要注意的是，当遍历当前阶段解的时候，可以根据之前阶段的解作「剪枝」操作，这样使问题的搜索规模变小，有效降低了问题的复杂度。</p><p><strong>巨人的肩膀</strong></p><ul><li><a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ</a> 回溯算法详解</li><li><a href="https://time.geekbang.org/column/article/74287" target="_blank" rel="noopener">https://time.geekbang.org/column/article/74287</a> 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</li></ul>]]></content>
    
    
    <summary type="html">什么是回溯算法，怎么去解决这样的问题？</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="中级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%BA%A7/"/>
    
    
    <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="http://yoursite.com/2020/09/20/%E5%AD%90%E9%9B%86/"/>
    <id>http://yoursite.com/2020/09/20/%E5%AD%90%E9%9B%86/</id>
    <published>2020-09-20T05:32:30.000Z</published>
    <updated>2020-10-27T09:19:24.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定一组<strong>不含重复元素</strong>的整数数组&nbsp;<em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> nums = [1,2,3]<strong>输出:</strong>[  [3],&nbsp; [1],&nbsp; [2],&nbsp; [1,2,3],&nbsp; [1,3],&nbsp; [2,3],&nbsp; [1,2],&nbsp; []]</div></pre></div><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们可以使用经典的回溯法解题模板，来求解这个问题：</p><p>相关代码如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>        result = []        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursive</span><span class="hljs-params">(select, allnums)</span>:</span>            <span class="hljs-keyword">if</span> select <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> result:                result.append(select.copy())            <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> enumerate(allnums):                select.append(num)                recursive(select, allnums[i + <span class="hljs-number">1</span>:])                select.remove(num)        recursive([], nums)        <span class="hljs-keyword">return</span> result</code></pre></div><p style="text-indent: 2em;">    这种经典的回溯解法当然是万能的，但是时间复杂度稍微有点高。我们在这里来介绍一种新的方法。</p><p class="note note-primary">迭代法实现子集枚举</p><p>记原序列中元素的总数为 <code>n</code>。原序列中的每个数字 <code>a_i</code>的状态可能有两种，即「在子集中」和「不在子集中」。我们用 <code>1</code> 表示「在子集中」，<code>0</code> 表示不在子集中，那么每一个子集可以对应一个长度为 <code>n</code> 的 0/1序列，第 <code>i</code> 位表示 <code>a_i</code>是否在子集中。例如，<code>n = 3 ，a = { 5, 2, 9 }</code> 时：</p><table><thead><tr><th>0/1 <strong>序列</strong></th><th><strong>子集</strong></th><th>0/10/1 序列对应的二进制数</th></tr></thead><tbody><tr><td>000</td><td>{ }</td><td>0</td></tr><tr><td>001</td><td>{ 9 }</td><td>1</td></tr><tr><td>010</td><td>{ 2 }</td><td>2</td></tr><tr><td>011</td><td>{ 2, 9 }</td><td>3</td></tr><tr><td>100</td><td>{ 5 }</td><td>4</td></tr><tr><td>101</td><td>{ 5, 9 }</td><td>5</td></tr><tr><td>110</td><td>{ 5, 2 }</td><td>6</td></tr><tr><td>111</td><td>{ 5, 2, 9 }</td><td>7</td></tr></tbody></table><p>可以发现 0/1序列对应的二进制数正好从 0 到 2^n - 1。我们可以枚举 mask∈[0,2^n−1]，mask 的二进制表示是一个 0/1序列，我们可以按照这个 0/1序列在原集合当中取数。当我们枚举完所有 2^n个 mask，我们也就能构造出所有的子集。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>        result = []        n = len(nums)        <span class="hljs-keyword">for</span> mask <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>&lt;&lt;n):            select = []            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):                <span class="hljs-keyword">if</span> mask &amp; <span class="hljs-number">1</span>&lt;&lt;i != <span class="hljs-number">0</span>:                    select.append(nums[i])            result.append(select)        <span class="hljs-keyword">return</span> result</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++mask) &#123;            t.clear();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;                <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;                    t.add(nums[i]);                &#125;            &#125;            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(t));        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/</a></p></div>]]></content>
    
    
    <summary type="html">如何求解数学集合问题中的子集呢?</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="中级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%BA%A7/"/>
    
    
    <category term="回溯" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>1+2+3+....+n=???</title>
    <link href="http://yoursite.com/2020/09/20/1-2-3-n/"/>
    <id>http://yoursite.com/2020/09/20/1-2-3-n/</id>
    <published>2020-09-20T05:31:49.000Z</published>
    <updated>2020-09-20T07:24:23.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> n = 3<strong>输出:&nbsp;</strong>6</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> n = 9<strong>输出:&nbsp;</strong>45</div></pre></div><p><strong>限制：</strong></p><ul>    <li><code>1 &lt;= n&nbsp;&lt;= 10000</code></li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p style="text-indent: 2em;">    首先我们梳理一下，这题要求我们不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句，因此我们手里能用的工具很少，列举出来发现只有加减法，赋值，位运算符以及逻辑运算符。</p><p style="text-indent: 2em;">    试想一下如果不加限制地使用递归的方法来实现这道题，相信大家都能很容易地给出下面的实现（以 C++ 为例）：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : n + sumNums(n - <span class="hljs-number">1</span>);    &#125;&#125;;</code></pre></div><p style="text-indent: 2em;">    通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。</p><p style="text-indent: 2em;">    以逻辑运算符 && 为例，对于 A && B 这个表达式，如果 A 表达式返回False，那么 A && B 已经确定为False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回True ，那么 A || B 已经确定为True ，此时不会去执行表达式 B。</p><p style="text-indent: 2em;">    利用这一特性，我们可以将判断是否为递归的出口看作 A && B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回 True，并继续执行表达式 B 的部分，否则递归结束。当然，你也可以用逻辑运算符 || 给出类似的实现，这里我们只提供结合逻辑运算符 && 的递归实现。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        <span class="hljs-keyword">return</span> n <span class="hljs-keyword">and</span> (n + self.sumNums(n<span class="hljs-number">-1</span>))</code></pre></div></div>]]></content>
    
    
    <summary type="html">连加谁不会？</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    
    <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2的幂？3的幂？4的幂？</title>
    <link href="http://yoursite.com/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/</id>
    <published>2020-09-01T09:05:30.000Z</published>
    <updated>2020-09-02T03:56:26.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定一个整数，写一个函数来判断它是否是 3&nbsp;的幂次方。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 27<strong>输出:</strong> true</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 0<strong>输出:</strong> false</div></pre></div><p><strong>示例 3:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 9<strong>输出:</strong> true</div></pre></div><p><strong>示例 4:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 45<strong>输出:</strong> false</div></pre></div><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p><p class="note note-primary">2和4的幂次问题同理</p><p>​         对于求解幂次的问题，我们第一反应会是想到系统提供的库函数<br>$$<br>n = pow(x, y) \ 9 = pow(3, 2) \ 即3^2=9<br>$$<br>，那么最笨的方法就是使用这个库函数，设置一个计数变量i，表示幂次，然后依次计算pow，直到等于n为止。这种方法是时间复杂度最高的，也是计算量最大的方法，俗称‘笨’方法。我将在接下里的方法中介绍一种通用的求解幂问题的通用，较为快捷的方法，和针对一些特殊情况的小技巧方法。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="方法一：循环迭代"><a href="#方法一：循环迭代" class="headerlink" title="方法一：循环迭代"></a>方法一：循环迭代</h2><p>找出数字 <code>n</code> 是否是数字 <code>b</code> 的幂的一个简单方法是，<code>n%3</code>  只要余数为 0，就一直将 <code>n</code> 除以 <code>b</code>。</p><p>$$<br>n=b^x<br>$$</p><p>因此，应该可以将 <code>n</code> 除以 <code>b</code>  x 次，每次都有 0 的余数，最终结果是 1。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">while</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>: n //= <span class="hljs-number">3</span>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span></code></pre></div><p>注意我们需要一个警卫来检查那个 <code>n！=0</code>，否则 while 循环将永远不会结束。对于负数，该算法没有意义，因此我们也将包括该保护。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O<em>(log*b</em>(<em>n</em>))，在我们的例子中是 O(\log n)*。除数是用对数表示的。</li></ul><ul><li>空间复杂度：O(1)，没有使用额外的空间。</li></ul><p>这种做法同样适用2和4的幂次。</p><h2 id="方法二：log运算法"><a href="#方法二：log运算法" class="headerlink" title="方法二：log运算法"></a>方法二：log运算法</h2><p>我们可以用下面的数学公式，也就是高中所学的换底公式：<br>$$<br>n=3^i<br>$$</p><p>$$<br>i=log_3(n)={log_b(n)\over log_b(3)}<br>$$</p><p>若 <code>n</code> 是 3 的幂则 <code>i</code> 是整数。在 Java 中，我们通过取小数部分（利用 <code>% 1</code>）来检查数字是否是整数，并检查它是否是 0。</p><p>我们取<code>b=10</code>，进行换底计算，代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> (Math.log10(n) / Math.log10(<span class="hljs-number">3</span>)) % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><p>其他编程语言的实现要看对应的API。</p><p><strong>常见的陷阱 :</strong><br>这个解决方案是有问题的，因为我们开始使用 <code>double s</code>，这意味着我们会遇到精度错误。说明在比较双精度数时不应使用 ==。这是因为 <code>Math.log10(n)/Math.log10(3)</code> 的结果可能是 <code>5.0000001</code> 或 <code>4.9999999</code>。使用 <code>Math.log()</code> 函数而不是<code>Math.log10()</code> 可以观察到这种效果。</p><p>为了解决这个问题，我们需要将结果与 <code>epsilon</code> 进行比较。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">return</span> (Math.log(n) / Math.log(<span class="hljs-number">3</span>) + epsilon) % <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> * epsilon;</code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：Unknown。这里主要消耗时间的运算是 <code>Math.log</code>，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器 。</p></li><li><p>空间复杂度： <code>O(1)</code>，我们没有使用任何额外的内存。<code>epsilon</code> 变量可以是内联的。</p></li></ul><p>这种做法也同样适用2和4的幂次。</p><h2 id="方法三：整数限制"><a href="#方法三：整数限制" class="headerlink" title="方法三：整数限制"></a>方法三：整数限制</h2><p>这种解法的精髓就在于求出在编程语言中能够表示的最大的幂次结果，然后模上这个数<code>n</code>，如果结果为<code>0</code>，那么这个<code>n</code>就是幂次结果。</p><p>举例，比如在python中，整数所能表示的最大数是30。当然这只是个假设，为了方便理解！！！，那么在30之内最大的3的幂次就是27了。因为<code>3*3*3=27</code>，所以我直接用这个最大的27模上<code>n</code>，比如<code>n=9</code>。显然，若要使模后的结果为<code>0</code>，那么n必须也得是3的倍数，<code>n=3, n=9</code>。所以，直接用最大的能表示的幂次数直接模<code>n</code>，看看结果是否为<code>0</code>，就可以判断了。</p><p>那么问题是怎么找到这个在整数表示内的最大幂次数呢？<br>$$<br>MaxInt = \frac{ 2^{32} }{2} - 1<br>$$<br> 因为我们使用 32 位来表示数字，所以范围的一半用于负数，0 是正数的一部分。</p><p>知道了 <code>n</code> 的限制，我们现在可以推断出 <code>n</code> 的最大值，也就是 3 的幂，是 <strong>1162261467</strong>。我们计算如下：<br>$$<br>3 ^{⌊log 3​     MaxInt⌋} =3^{⌊19.56⌋} =3^{19} =1162261467<br>$$</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        maxInt = <span class="hljs-number">2147483647</span> <span class="hljs-comment">#python所能表达的最大正整数</span>        max_exp = pow(<span class="hljs-number">3</span>, math.floor(math.log(maxInt, <span class="hljs-number">3</span>)))        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> max_exp % n == <span class="hljs-number">0</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。我们只做了一次操作。</p></li><li><p>空间复杂度： <code>O(1)</code>，没有使用额外空间。</p></li></ul><p class="note note-danger">这种方法只适用于底数为质数的数字，如3，5。</p><h2 id="方法四：位运算（2为底）"><a href="#方法四：位运算（2为底）" class="headerlink" title="方法四：位运算（2为底）"></a>方法四：位运算（2为底）</h2><p>该方法将通过位运算在 <code>O(1)</code> 的时间复杂度解决，通过使用如下的按位技巧：</p><ul><li><p>如何获取二进制中最右边的 <code>1</code>：<code>x &amp; (-x)</code>。</p></li><li><p>如何将二进制中最右边的 <code>1</code> 设置为 <code>0</code>：<code>x &amp; (x - 1)</code>。</p></li></ul><p>以下的两种解决方案背后的思想都是一样的：2 的幂在二进制中是有一个 <code>1</code> 后跟一些 <code>0</code>：<br>$$<br>1=(00000001) _2<br>$$</p><p>$$<br>2 = (0000 0010)_2<br>$$</p><p>$$<br>4 = (0000 0100)_2<br>$$</p><p>$$<br>8 = (0000 1000)_2<br>$$</p><p>不是 2 的幂的二进制中有一个以上的 <code>1</code>。<br>$$<br>3 = (00000011) _2<br>$$</p><p>$$<br>5 = (0000 0101)_2<br>$$</p><p>$$<br>6 = (0000 0110)_2<br>$$</p><p>$$<br>7 = (0000 0111)_2<br>$$</p><p>除了 <code>0</code>，我们应该单独处理。</p><h3 id="获取最右边的-1"><a href="#获取最右边的-1" class="headerlink" title="获取最右边的 1"></a><strong>获取最右边的 1</strong></h3><p>首先讨论为什么 <code>x &amp; (-x)</code> 可以获取到二进制中最右边的 1，且其它位设置为 0。如下图所示：</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m1.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p>因此，<em>x</em> 和 −<em>x</em> 只有一个共同点：最右边的 1。这说明 <code>x &amp; (-x)</code> 将保留最右边的 1。并将其他的位设置为 0。</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m2.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p><strong>检测是否为 2 的幂：</strong></p><p>我们通过 <code>x &amp; (-x)</code> 保留了最右边的 1，并将其他位设置为 0 若 <code>x</code> 为 2 的幂，则它的二进制表示中只包含一个 1，则有 <code>x &amp; (-x) = x</code>。</p><p>若 <code>x</code> 不是 2 的幂，则在二进制表示中存在其他 1，因此 <code>x &amp; (-x) != x</code>。</p><p>因此判断是否为 2 的幂的关键是：判断 <code>x &amp; (-x) == x</code>。</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m3.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> n &amp; (-n) == n</code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><h3 id="去除二进制中最右边的-1"><a href="#去除二进制中最右边的-1" class="headerlink" title="去除二进制中最右边的 1"></a>去除二进制中最右边的 1</h3><p>首先讨论为什么 <code>x &amp; (x - 1)</code> 可以将最右边的 1 设置为 0。</p><p><code>(x - 1)</code> 代表了将 <code>x</code> 最右边的 1 设置为 0，并且将较低位设置为 1。</p><p>再使用与运算：则 <code>x</code> 最右边的 1 和就会被设置为 0，因为 <code>1 &amp; 0 = 0</code>。</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m4.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p><strong>检测是否为 2 的幂：</strong></p><ul><li><p>2 的幂二进制表示只含有一个 1。</p></li><li><p><code>x &amp; (x - 1)</code> 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 <code>x &amp; (x - 1) == 0</code>。</p></li></ul><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m5.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> n &amp; (n - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><p class="note note-danger">这种方法只适用于底数为2或者4的数字</p><h2 id="方法五：暴力破解法"><a href="#方法五：暴力破解法" class="headerlink" title="方法五：暴力破解法"></a>方法五：暴力破解法</h2><p>我们提前计算所有可能答案。</p><p>我们知道输入的整数是 32 位整数<br>$$<br>x \le 2^{31} - 1<br>$$<br>因此我们最大 3的幂次为<br>$$<br>[\log_3\left(2^{31} - 1\right)] = 19<br>$$<br>那么我们总共有 20 种可能：<br>$$<br>3^0 , 3^1 , 3^2 , …, 3^{19}<br>$$<br>我们预计算全部可能，然后运行时检查输入数字是否在预计算列表中。</p><p>预计算：</p><div class="hljs"><pre><code class="hljs python">result = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):    result.append(pow(<span class="hljs-number">3</span>, i))</code></pre></div><p>得到这样的一个列表：</p><div class="hljs"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">27</span>, <span class="hljs-number">81</span>, <span class="hljs-number">243</span>, <span class="hljs-number">729</span>, <span class="hljs-number">2187</span>, <span class="hljs-number">6561</span>, <span class="hljs-number">19683</span>, <span class="hljs-number">59049</span>, <span class="hljs-number">177147</span>, <span class="hljs-number">531441</span>, <span class="hljs-number">1594323</span>, <span class="hljs-number">4782969</span>, <span class="hljs-number">14348907</span>, <span class="hljs-number">43046721</span>, <span class="hljs-number">129140163</span>, <span class="hljs-number">387420489</span>, <span class="hljs-number">1162261467</span>]</code></pre></div><p>然后判断n是否在列表中：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        result = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">27</span>, <span class="hljs-number">81</span>, <span class="hljs-number">243</span>, <span class="hljs-number">729</span>, <span class="hljs-number">2187</span>, <span class="hljs-number">6561</span>, <span class="hljs-number">19683</span>, <span class="hljs-number">59049</span>, <span class="hljs-number">177147</span>, <span class="hljs-number">531441</span>, <span class="hljs-number">1594323</span>, <span class="hljs-number">4782969</span>, <span class="hljs-number">14348907</span>, <span class="hljs-number">43046721</span>, <span class="hljs-number">129140163</span>, <span class="hljs-number">387420489</span>, <span class="hljs-number">1162261467</span>]        <span class="hljs-keyword">return</span> n <span class="hljs-keyword">in</span> result</code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><p class="note note-danger">这种方法适用于所有情况</p><h2 id="方法六：位运算（4为底）"><a href="#方法六：位运算（4为底）" class="headerlink" title="方法六：位运算（4为底）"></a>方法六：位运算（4为底）</h2><ul><li><p>我们首先检查 <code>num</code> 是否为 <code>2</code> 的幂：<code>x &gt; 0 and x &amp; (x - 1) == 0</code>。</p></li><li><p>现在的问题是区分 <code>2</code> 的偶数幂（当 <em>x</em> 是 <code>4</code> 的幂时）和 <code>2</code> 的奇数幂（当 <em>x</em> 不是 <code>4</code> 的幂时）。在二进制表示中，这两种情况都只有一位为 <code>1</code>，其余为 <code>0</code>。</p></li><li><p>有什么区别？在第一种情况下（<code>4</code> 的幂），<code>1</code> 处于偶数位置：第 <code>0</code> 位、第 <code>2</code> 位、第 <code>4</code> 位等；在第二种情况下，<code>1</code> 处于奇数位置。</p></li></ul><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/4mi.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p>因此 <code>4</code> 的幂与数字<br>$$<br>(101010…10)_2<br>$$<br> 相与会得到 <code>0</code>。即<br>$$<br>4^a \land (101010…10)_2 == 0<br>$$<br>(101010…10)2 用十六进制表示为 ：</p><p>$$<br>(aaaaaaaa)_{16}<br>$$</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &amp; (-n) == n <span class="hljs-keyword">and</span> n &amp; <span class="hljs-number">0xaaaaaaaa</span> == <span class="hljs-number">0</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(1)</code>。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://leetcode-cn.com/problems/power-of-four/solution/4de-mi-by-leetcode/" target="_blank" rel="noopener">4的幂</a></p><p><a href="https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/" target="_blank" rel="noopener">3的幂</a></p><p><a href="https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode/" target="_blank" rel="noopener">2的幂</a></p></div>]]></content>
    
    
    <summary type="html">如何判断一个数n是否是2的多少次幂呢？</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    
    <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="位运算" scheme="http://yoursite.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>二叉树层序遍历的思考</title>
    <link href="http://yoursite.com/2020/08/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2020/08/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2020-08-26T07:15:15.000Z</published>
    <updated>2020-08-26T08:08:58.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><div class="notranslate"><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><div class="hljs"><pre><div style="color:white">    3   / \  9  20    /  \   15   7</div></pre></div><p>返回其层次遍历结果：</p><div class="hljs"><pre><div style="color:white">[  [3],  [9,20],  [15,7]]</div></pre></div><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p style="text-indent: 2em;">    二叉树的层序遍历比较基础，想法很简单，就是用一个queue就可以实现，一次把弹出节点的左右子节点放入queue中，然后读出就行。</p><p style="text-indent: 2em;">    然而这个题，要求同一层结点数据放在一个[]中，这个地方就是我们要思考的地方！</p><p style="text-indent: 2em;">    在队列中添加子节点的同时，要把同一层的结点放在一起操作，这里就需要获得这一层结点的数量，然后在这个数量中再循环看看是否还有子节点，然后继续放入队列中。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span>        results = [] <span class="hljs-comment">#放最终结果</span>        que = Queue() <span class="hljs-comment">#暂存队列</span>        <span class="hljs-keyword">if</span> root:            results.append([root.val])            que.put(root)        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            quelength = que.qsize() <span class="hljs-comment">#获取同层结点的数量，因为同层的结点同时在队列里</span>            cell = [] <span class="hljs-comment">#存放每层的结点val</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(quelength):                node = que.get()                <span class="hljs-keyword">if</span> node.left:                    cell.append(node.left.val)                    que.put(node.left)                <span class="hljs-keyword">if</span> node.right:                    cell.append(node.right.val)                    que.put(node.right)                quelength -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> cell :                results.append(cell)        <span class="hljs-keyword">return</span> results</code></pre></div><h1 id="问题变种"><a href="#问题变种" class="headerlink" title="问题变种"></a>问题变种</h1><p class="note note-success">如何求每层的平均值？</p><div class="notranslate"><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>    3   / \  9  20    /  \   15   7<strong>输出：</strong>[3, 14.5, 11]<strong>解释：</strong>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</div></pre></div><p><strong>提示：</strong></p><ul>    <li>节点值的范围在32位有符号整数范围内。</li></ul>代码实现：<div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[float]:</span>        results = []        que = Queue()        <span class="hljs-keyword">if</span> root:            results.append(root.val)            que.put(root)        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            quelength = que.qsize()            sum = <span class="hljs-number">0</span>            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(quelength):                node = que.get()                <span class="hljs-keyword">if</span> node.left:                    sum += node.left.val                    que.put(node.left)                    count += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> node.right:                    sum += node.right.val                    que.put(node.right)                    count += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> count!=<span class="hljs-number">0</span>:                avg = sum / count                results.append(avg)        <span class="hljs-keyword">return</span> results</code></pre></div></div></div>]]></content>
    
    
    <summary type="html">二叉树遍历的问题分析</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="中级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%BA%A7/"/>
    
    
    <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>模拟求和问题</title>
    <link href="http://yoursite.com/2020/08/26/%E6%A8%A1%E6%8B%9F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/08/26/%E6%A8%A1%E6%8B%9F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2020-08-26T07:14:37.000Z</published>
    <updated>2020-08-26T09:06:08.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-二进制的加法"><a href="#一-二进制的加法" class="headerlink" title="一. 二进制的加法"></a>一. 二进制的加法</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><div class="notranslate"><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空 </strong>字符串且只包含数字&nbsp;<code>1</code>&nbsp;和&nbsp;<code>0</code>。</p><p><strong>示例&nbsp;1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> a = "11", b = "1"<strong>输出:</strong> "100"</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> a = "1010", b = "1011"<strong>输出:</strong> "10101"</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>每个字符串仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成。</li>    <li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>    <li>字符串如果不是 <code>"0"</code> ，就都不含前导零。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p class="note note-primary">方法一： 转十进制相加</p><p>考虑一个最朴素的方法：先将<code>a</code>和<code>b</code>转化成十进制数，求和后再转化为二进制数。利用 Python 和 Java 自带的高精度运算，我们可以很简单地写出这个程序：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(self, a, b)</span> -&gt; str:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'&#123;0:b&#125;'</span>.format(int(a, <span class="hljs-number">2</span>) + int(b, <span class="hljs-number">2</span>))</code></pre></div><p>如果 <code>a</code> 的位数是 <code>n</code>，<code>b</code> 的位数为 <code>m</code>，这个算法的渐进时间复杂度为 <code>O(n+m)</code>。但是这里非常简单的实现基于 Python 和 Java 本身的高精度功能，在其他的语言中可能并不适用，并且在 Java 中：</p><ul><li>如果字符串超过 3333 位，不能转化为 <code>Integer</code></li><li>如果字符串超过 6565 位，不能转化为 <code>Long</code></li><li>如果字符串超过 500000001500000001 位，不能转化为 <code>BigInteger</code></li></ul><p>因此，为了适用于长度较大的字符串计算，我们应该使用更加健壮的算法。</p><p class="note note-primary">方法二： 竖式模拟相加</p><p>我们可以借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p><p>具体的，我们可以取<br>$$<br>n = max{ |a|, |b| }<br>$$<br>，循环 <code>n</code> 次，从最低位开始遍历。我们使用一个变量 <code>carry</code> 表示上一个位置的进位，初始值为 <code>0</code>。记当前位置对其的两个位为<br>$$<br>a^i,b^i<br>$$<br>，则每一位的答案为<br>$$<br>(carry + a^i+b^i)mod2<br>$$<br>，下一位的进位为<br>$$<br>⌊(carry + a^i+b^i)/2⌋<br>$$<br>。重复上述步骤，直到数字 <code>a</code> 和 <code>b</code> 的每一位计算完毕。最后如果 <code>carry</code> 的最高位不为 <code>0</code>，则将最高位添加到计算结果的末尾。</p><p>注意，为了让各个位置对齐，你也可以直接把 <code>a</code> 和 <code>b</code> 中短的那一个补 <code>0</code> 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转.</p><img src="/2020/08/26/%E6%A8%A1%E6%8B%9F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/IMG_3114.jpg" srcset="/img/loading.gif" alt="IMG_3114.jpg" style="zoom:25%;display: flex;margin: 0 auto;"><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(self, a: str, b: str)</span> -&gt; str:</span>        results = []        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(max(len(a), len(b))):            carry += int(a[len(a) - i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &lt; len(a) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            carry += int(b[len(b) - i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &lt; len(b) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            results.append(str(carry % <span class="hljs-number">2</span>))            carry //= <span class="hljs-number">2</span>            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> carry &gt; <span class="hljs-number">0</span> :            results.append(<span class="hljs-string">'1'</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(results[::<span class="hljs-number">-1</span>])</code></pre></div><p>复杂度分析</p><p>假设 <code>n=max{∣a∣,∣b∣}</code>。</p><ul><li>时间复杂度：<code>O(n)</code>，这里的时间复杂度来源于顺序遍历 <code>a</code> 和 <code>b</code>。</li><li>空间复杂度：<code>O(1)</code>，除去答案所占用的空间，这里使用了常数个临时变量。</li></ul><h1 id="二-链表求和"><a href="#二-链表求和" class="headerlink" title="二. 链表求和"></a>二. 链表求和</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><div class="notranslate"><p>给定两个用链表表示的整数，每个节点包含一个数位。</p><p>这些数位是反向存放的，也就是个位排在链表首部。</p><p>编写函数对这两个整数求和，并用链表形式返回结果。</p><p><strong>示例：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<strong>输出：</strong>2 -&gt; 1 -&gt; 9，即912</div></pre></div><p><strong>进阶：</strong>假设这些数位是正向存放的，请再做一遍。</p><p><strong>示例：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295<strong>输出：</strong>9 -&gt; 1 -&gt; 2，即912</div></pre></div><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>解题思路和上一题样，只不过这里增加了尾插法插入链表的操作。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>        end = results = ListNode(<span class="hljs-number">-1</span>)        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:            carry += l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            carry += l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            end.next = ListNode(carry % <span class="hljs-number">10</span>)            end = end.next            carry //= <span class="hljs-number">10</span>            l1 = l1.next <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>            l2 = l2.next <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> carry &gt;= <span class="hljs-number">1</span>:            end.next = ListNode(<span class="hljs-number">1</span>)            end = end.next        <span class="hljs-keyword">return</span> results.next</code></pre></div></div></div>]]></content>
    
    
    <summary type="html">怎样以手工竖式的方式实现两数字的加法？</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    
    <category term="数学" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>回文串的那些事儿（一）</title>
    <link href="http://yoursite.com/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-08-04T07:24:35.000Z</published>
    <updated>2020-08-04T08:55:45.429Z</updated>
    
    <content type="html"><![CDATA[<p class="note note-success">回顾经典回文串链问题</p><h1 id="一-回文数"><a href="#一-回文数" class="headerlink" title="一.  回文数"></a>一.  回文数</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 121<strong>输出:</strong> true</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> -121<strong>输出:</strong> false<strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</div></pre></div><p><strong>示例 3:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 10<strong>输出:</strong> false<strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</div></pre></div><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">    在这道题中，我们可以借助列表的反转方法来判断数字是否是一个回文数字。首先，由于回文串的对称性，负数一定不是回文数，那么我们只需对正数进行字符串转换。之后将字符串放到list中，使用reverse方法来判断反转之后的list和原list是否相同。若相同表示是回文数字，否则不是回文数字。</p><p style="text-indent: 2em;">    这种方法的一个缺点就是另外开辟了新的数组空间，空间复杂度偏高。</p><p style="text-indent: 2em;">    另外一种做法就是通过取整和取余操作获取整数中对应的数字进行比较。举个例子：1221 这个数字。通过计算 1221 / 1000， 得首位1；通过计算 1221 % 10， 可得末位 1；进行比较；再将 22 取出来继续比较</p><img src="/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/p1.gif" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:50%;display: flex;margin: 0 auto;"><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, x: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">else</span>:            num_list = list(str(x))            reverse = <span class="hljs-string">''</span>.join(num_list[::<span class="hljs-number">-1</span>])            <span class="hljs-keyword">if</span> str(x) == reverse:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">//边界判断</span>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> div = <span class="hljs-number">1</span>;        <span class="hljs-comment">//</span>        <span class="hljs-keyword">while</span> (x / div &gt;= <span class="hljs-number">10</span>) div *= <span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> left = x / div;            <span class="hljs-keyword">int</span> right = x % <span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span> (left != right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            x = (x % div) / <span class="hljs-number">10</span>;            div /= <span class="hljs-number">100</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h1 id="二-验证回文串"><a href="#二-验证回文串" class="headerlink" title="二. 验证回文串"></a>二. 验证回文串</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "A man, a plan, a canal: Panama"<strong>输出:</strong> true</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "race a car"<strong>输出:</strong> false</div></pre></div><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">    在这道题中，我们的限定条件是只考虑字符串其中的字母和数字部分，并且字母大小写可忽略。我们可以使用双指针的方法，一个只指向开头字符，一个指向末尾字符，两指针所指字符分别比较。如果当前指针所指字符不是字母或数字，那么就越过这一字符，指向下一个字符，直到是字母或数字为止。这种双指针的方法，只需遍历一遍字符串即可判断。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        i, j = <span class="hljs-number">0</span>, len(s)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> i &lt; j :            <span class="hljs-keyword">while</span> i&lt;j <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[i].isalnum():                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> i&lt;j <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[j].isalnum():                j -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i &lt; j :                <span class="hljs-keyword">if</span> s[i].lower() != s[j].lower():                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(|s|)</code>，其中<code>∣s∣</code> 是字符串s 的长度。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h1 id="三-验证回文字符串Ⅱ"><a href="#三-验证回文字符串Ⅱ" class="headerlink" title="三. 验证回文字符串Ⅱ"></a>三. 验证回文字符串Ⅱ</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>给定一个非空字符串&nbsp;<code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "aba"<strong>输出:</strong> True</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "abca"<strong>输出:</strong> True<strong>解释:</strong> 你可以删除c字符。</div></pre></div><p><strong>注意:</strong></p><ol>    <li>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</li></ol><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">    考虑最朴素的方法：首先判断原串是否是回文串，如果是，就返回 true；如果不是，则枚举每一个位置作为被删除的位置，再判断剩下的字符串是否是回文串。这种做法的渐进时间复杂度是 O(n^2)的，会超出时间限制。</p><p style="text-indent: 2em;">我们换一种想法。首先考虑如果不允许删除字符，如何判断一个字符串是否是回文串。常见的做法是使用双指针。定义左右指针，初始时分别指向字符串的第一个字符和最后一个字符，每次判断左右指针指向的字符是否相同，如果不相同，则不是回文串；如果相同，则将左右指针都往中间移动一位，直到左右指针相遇，则字符串是回文串。</p><p style="text-indent: 2em;">    在允许最多删除一个字符的情况下，同样可以使用双指针，通过贪心算法实现。初始化两个指针 low 和 high 分别指向字符串的第一个字符和最后一个字符。每次判断两个指针指向的字符是否相同，如果相同，则更新指针，令 low = low + 1 和 high = high - 1，然后判断更新后的指针范围内的子串是否是回文字符串。如果两个指针指向的字符不同，则两个字符中必须有一个被删除，此时我们就分成两种情况：即删除左指针对应的字符，留下子串s[low + 1], ..., s[high]，或者删除右指针对应的字符，留下子串 s[low], s[low + 1], ..., s[high - 1]。当这两个子串中至少有一个是回文串时，就说明原始字符串删除一个字符之后就以成为回文串。</p><img src="/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/680_fig1.png" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:50%;display: flex;margin: 0 auto;"><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletePalindrome</span><span class="hljs-params">(low, high)</span>:</span>            <span class="hljs-keyword">while</span> low &lt; high:                <span class="hljs-keyword">if</span> s[low] == s[high]:                    low += <span class="hljs-number">1</span>                    high -= <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        low, high = <span class="hljs-number">0</span>, len(s)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> low&lt;high:            <span class="hljs-keyword">if</span> s[low] == s[high]:                low += <span class="hljs-number">1</span>                high -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> deletePalindrome(low+<span class="hljs-number">1</span>, high) <span class="hljs-keyword">or</span> deletePalindrome(low, high<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="四-回文链表"><a href="#四-回文链表" class="headerlink" title="四. 回文链表"></a>四. 回文链表</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 1-&gt;2<strong>输出:</strong> false</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<strong>输出:</strong> true</div></pre></div><p><strong>进阶：</strong><br>你能否用&nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。</p><p style="text-indent: 2em;">执行第二部的最佳方法取决于你使用的变成语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。</p><p style="text-indent: 2em;">在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val==node_2.val。而 node_1==node_2 是错误的。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, head: ListNode)</span> -&gt; bool:</span>        listt = []        <span class="hljs-keyword">while</span> head:            listt.append(head.val)            head = head.next        <span class="hljs-keyword">return</span> listt == listt[::<span class="hljs-number">-1</span>]</code></pre></div><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p style="text-indent: 2em;">避免使用 O(n) 额外空间的方法就是改变输入。</p><p style="text-indent: 2em;">我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。</p><p><strong>算法：</strong></p><p>我们可以分为以下几个步骤：</p><ol><li><p>找到前半部分链表的尾节点。</p></li><li><p>反转后半部分链表。</p></li><li><p>判断是否为回文。</p></li><li><p>恢复链表。</p></li><li><p>返回结果。</p><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p></li></ol><p style="text-indent: 2em;">或者可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。</p><p style="text-indent: 2em;">若链表有奇数个节点，则中间的节点应该看作是前半部分。</p><p style="text-indent: 2em;">步骤二可以使用在反向链表问题中找到解决方法来反转链表的后半部分。</p><p style="text-indent: 2em;">步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p><p style="text-indent: 2em;">步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, head: ListNode)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-comment"># Find the end of first half and reverse second half.</span>        first_half_end = self.end_of_first_half(head)        second_half_start = self.reverse_list(first_half_end.next)        <span class="hljs-comment"># Check whether or not there's a palindrome.</span>        result = <span class="hljs-literal">True</span>        first_position = head        second_position = second_half_start        <span class="hljs-keyword">while</span> result <span class="hljs-keyword">and</span> second_position <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">if</span> first_position.val != second_position.val:                result = <span class="hljs-literal">False</span>            first_position = first_position.next            second_position = second_position.next        <span class="hljs-comment"># Restore the list and return the result.</span>        first_half_end.next = self.reverse_list(second_half_start)        <span class="hljs-keyword">return</span> result        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">end_of_first_half</span><span class="hljs-params">(self, head)</span>:</span>        fast = head        slow = head        <span class="hljs-keyword">while</span> fast.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> fast.next.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            fast = fast.next.next            slow = slow.next        <span class="hljs-keyword">return</span> slow    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_list</span><span class="hljs-params">(self, head)</span>:</span>        previous = <span class="hljs-literal">None</span>        current = head        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            next_node = current.next            current.next = previous            previous = current            current = next_node        <span class="hljs-keyword">return</span> previous</code></pre></div><p>反转链表使用的是头插法。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 指的是链表的大小。</li><li>空间复杂度：<code>O(1)</code>，我们是一个接着一个的改变指针，我们在堆栈上的堆栈帧不超过 <code>O(1)</code>。<br>该方法的缺点是，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执执行过程中链表暂时断开。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p style="text-indent: 2em;">回文串问题是经典的初级算法，回顾这一文章，不难发现解决回文的问题追根溯源可以归结以下几种方法：</p><ul><li>借助list反转实现判断</li><li>借助双指针，前后分别进行判断</li><li>链表借助list空间</li><li>求出回文的中间节点，将后一半的回文反转后，与前一半回文依次进行比较</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/" target="_blank" rel="noopener">回文数</a></p><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/" target="_blank" rel="noopener">验证回文字符串 Ⅱ</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode/" target="_blank" rel="noopener">回文链表</a></p></div></div></div></div>]]></content>
    
    
    <summary type="html">从最简单的判断回文串开始，逐步介绍回文串问题的变种。</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="初级" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/%E5%88%9D%E7%BA%A7/"/>
    
    
    <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="回文串" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    
  </entry>
  
</feed>
