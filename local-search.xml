<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>秒杀经典TopK问题</title>
    <link href="/2020/11/09/%E7%A7%92%E6%9D%80%E7%BB%8F%E5%85%B8TopK%E9%97%AE%E9%A2%98/"/>
    <url>/2020/11/09/%E7%A7%92%E6%9D%80%E7%BB%8F%E5%85%B8TopK%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">Top K问题是解决如何在数组中或者数据中获得前K个最大或者最小的元素，是面试时的高频问点。</p><p>问题的具体化形式包括但不限于以下几个：</p><ul><li><h4 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h4></li><li><h4 id="973-最接近原点的-K-个点"><a href="#973-最接近原点的-K-个点" class="headerlink" title="973. 最接近原点的 K 个点"></a><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></h4></li><li><h4 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></h4></li></ul><p>解决这一类问题，我们通常有如下几种解题方法：</p><ul><li><p>排序法</p></li><li><p>堆</p></li><li><p>快速查找法</p></li></ul><p>下面对于每种方法给出解题思路，对于这一类问题可以直接套用。</p><h1 id="一-排序法"><a href="#一-排序法" class="headerlink" title="一. 排序法"></a>一. 排序法</h1><p>排序法是最简单的也是最容易想到的方法。这种方法可以依赖编程语言的API排序函数进行排序，然后选择对应元素即可。</p><p>解题的模板如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; int:</span>        <span class="hljs-comment"># 对集合进行排序</span>        nums.sort()        <span class="hljs-comment"># 返回符合要求的元素</span>        <span class="hljs-keyword">return</span> nums[k]</code></pre></div><p>对于<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a>，这里可以使用此方法直接返回排序后的第K个索引的元素，即是算法的结果。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; int:</span>        nums.sort(reverse=<span class="hljs-literal">True</span>)        <span class="hljs-keyword">return</span> nums[k<span class="hljs-number">-1</span>]</code></pre></div><p>对于<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a>，这里返回的不是一个数字，而是返回一个列表，其中包含最小的K个数字。也可以使用这个模板进行作答。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span>        arr.sort()        <span class="hljs-keyword">return</span> arr[:k]</code></pre></div><p>对于<a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a>，别管是求什么距离最近，脱去外衣还是求最小的K个数字，和上一题不同的是，这里的排序条件要改变一下，自定义个求距离的函数。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kClosest</span><span class="hljs-params">(self, points: List[List[int]], K: int)</span> -&gt; List[List[int]]:</span>        points.sort(key=<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>))        <span class="hljs-keyword">return</span> points[:K]</code></pre></div><p>通过上述三个体可以看出 ，这种方法最简单也是最直接的，运行效果也不错。</p><h1 id="二-堆"><a href="#二-堆" class="headerlink" title="二. 堆"></a>二. 堆</h1><p>要获得前K个元素，而且是最大或者最小。我们第一反应可以想到堆排序。我们用一个大根堆实时维护数组的前 <code>k</code>小值。首先将前 <code>k</code> 个数插入大根堆中，随后从第 <code>k+1</code> 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。而 Python 语言中的对为小根堆，因此我们要对数组中所有的数取其相反数，才能使用小根堆维护前 <code>k</code> 小值。</p><p>对于<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; int:</span>        heap = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums[:k]]        heapq.heapify(heap)        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(k, len(nums)):            <span class="hljs-keyword">if</span> heap[<span class="hljs-number">0</span>] &lt; nums[num]:                heapq.heappushpop(heap, nums[num])        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>]</code></pre></div><p>对于<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> []        heap = [-num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr[:k]]        heapq.heapify(heap)        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(k, len(arr)):            <span class="hljs-keyword">if</span> -heap[<span class="hljs-number">0</span>] &gt; arr[num]:                heapq.heappushpop(heap, -arr[num])        res = [-num <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> heap]        <span class="hljs-keyword">return</span> res</code></pre></div><p>对于<a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kClosest</span><span class="hljs-params">(self, points: List[List[int]], K: int)</span> -&gt; List[List[int]]:</span>        res = []        q = [(x[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + x[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>, i) <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(points)]        heapq.heapify(q)        <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> range(K):            res.append(points[heapq.heappop(q)[<span class="hljs-number">1</span>]])        <span class="hljs-keyword">return</span> res</code></pre></div><p class="note note-primary">总结一点：求最大要用小根堆，求最小要用大根堆</p><p>为什么呢？请独立思考！</p><p class="note note-danger">对于海量数据，我们不需要一次性将全部数据取出来，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(nlogk)</code>，其中 <code>n</code> 是数组 <code>arr</code> 的长度。由于大根堆实时维护前 <code>k</code> 小值，所以插入删除都是 <code>O(logk)</code> 的时间复杂度，最坏情况下数组里 <code>n</code> 个数都会插入，所以一共需要 <code>O(nlogk)</code> 的时间复杂度。</li></ul><ul><li>空间复杂度：<code>O(k)</code>，因为大根堆里最多 <code>k</code> 个数。</li></ul><h1 id="三-快速查找法"><a href="#三-快速查找法" class="headerlink" title="三. 快速查找法"></a>三. 快速查找法</h1><p>我们可以借鉴快速排序的思想。我们知道快排的划分函数每次执行完后都能将数组分成两个部分，小于等于分界值 <code>pivot</code> 的元素的都会被放到数组的左边，大于的都会被放到数组的右边，然后返回分界值的下标。与快速排序不同的是，快速排序会根据分界值的下标递归处理划分的两侧，而这里我们只处理划分的一边。</p><p>Top K 问题的这个解法就比较难想到，需要在平时有算法的积累。找第 k 大的数，或者找前 k 大的数，有一个经典的 quick select（快速选择）算法。这个名字和 quick sort（快速排序）看起来很像，算法的思想也和快速排序类似，都是分治法的思想。</p><p><code>partition</code> 操作是原地进行的，需要 <code>O(n)</code> 的时间，接下来，快速排序会递归地排序左右两侧的数组。而快速选择（quick select）算法的不同之处在于，接下来只需要递归地选择一侧的数组。快速选择算法想当于一个“不完全”的快速排序，因为我们只需要知道最小的 <code>k</code> 个数是哪些，并不需要知道它们的顺序。</p><p>这种方法需要多加领会思想，如果你对快速排序掌握得很好，那么稍加推导应该不难掌握 quick select 的要领。</p><p>对于<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span><span class="hljs-params">(self, nums, low, high)</span>:</span>        pivot = nums[high]        i = low - <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(low, high):            <span class="hljs-keyword">if</span> nums[j] &lt; pivot:                i += <span class="hljs-number">1</span>                nums[i], nums[j] = nums[j], nums[i]        nums[high], nums[i+<span class="hljs-number">1</span>] = nums[i+<span class="hljs-number">1</span>], nums[high]        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickSelection</span><span class="hljs-params">(self, nums, left, right, k)</span>:</span>        pivot = self.partition(nums, left, right)        <span class="hljs-keyword">if</span> pivot == k:            <span class="hljs-keyword">return</span> nums[pivot]        <span class="hljs-keyword">elif</span> pivot &lt; k:            <span class="hljs-keyword">return</span> self.quickSelection(nums, pivot+<span class="hljs-number">1</span>, right, k)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> self.quickSelection(nums, left, pivot<span class="hljs-number">-1</span>, k)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(self, nums, k)</span>:</span>        <span class="hljs-keyword">return</span> self.quickSelection(nums, <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span>, len(nums) - k)</code></pre></div><p>对于<a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 40. 最小的k个数</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span><span class="hljs-params">(self, nums, l, r)</span>:</span>        pivot = nums[r]        i = l - <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(l, r):            <span class="hljs-keyword">if</span> nums[j] &lt;= pivot:                i += <span class="hljs-number">1</span>                nums[i], nums[j] = nums[j], nums[i]        nums[i + <span class="hljs-number">1</span>], nums[r] = nums[r], nums[i + <span class="hljs-number">1</span>]        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomized_partition</span><span class="hljs-params">(self, nums, l, r)</span>:</span>        i = random.randint(l, r)        nums[r], nums[i] = nums[i], nums[r]        <span class="hljs-keyword">return</span> self.partition(nums, l, r)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomized_selected</span><span class="hljs-params">(self, arr, l, r, k)</span>:</span>        pos = self.randomized_partition(arr, l, r)        num = pos - l + <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> k &lt; num:            self.randomized_selected(arr, l, pos - <span class="hljs-number">1</span>, k)        <span class="hljs-keyword">elif</span> k &gt; num:            self.randomized_selected(arr, pos + <span class="hljs-number">1</span>, r, k - num)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getLeastNumbers</span><span class="hljs-params">(self, arr: List[int], k: int)</span> -&gt; List[int]:</span>        <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> list()        self.randomized_selected(arr, <span class="hljs-number">0</span>, len(arr) - <span class="hljs-number">1</span>, k)        <span class="hljs-keyword">return</span> arr[:k]</code></pre></div><p>我们的目的是寻找最小的 <code>k</code>个数。假设经过一次 <code>partition</code> 操作，枢纽元素位于下标 <code>m</code>，也就是说，左侧的数组有 <code>m</code> 个元素，是原数组中最小的 <code>m</code> 个数。那么：</p><ul><li>若 <code>k = m</code>，我们就找到了最小的 <code>k</code> 个数，就是左侧的数组；</li><li>若 <code>k&lt;m</code> ，则最小的 <code>k</code> 个数一定都在左侧数组中，我们只需要对左侧数组递归地 <code>partition</code>即可；</li><li>若 <code>k&gt;m</code>，则左侧数组中的 <code>m</code> 个数都属于最小的 <code>k</code> 个数，我们还需要在右侧数组中寻找最小的 <code>k-m</code> 个数，对右侧数组递归地 <code>partition</code> 即可。</li></ul><p>对于<a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. 最接近原点的 K 个点</a></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kClosest</span><span class="hljs-params">(self, points: List[List[int]], K: int)</span> -&gt; List[List[int]]:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_select</span><span class="hljs-params">(left: int, right: int, K: int)</span>:</span>            pivot_id = random.randint(left, right)            pivot = points[pivot_id][<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + points[pivot_id][<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span>            points[right], points[pivot_id] = points[pivot_id], points[right]            i = left - <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(left, right):                <span class="hljs-keyword">if</span> points[j][<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + points[j][<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span> &lt;= pivot:                    i += <span class="hljs-number">1</span>                    points[i], points[j] = points[j], points[i]            i += <span class="hljs-number">1</span>            points[i], points[right] = points[right], points[i]            <span class="hljs-comment"># [left, i-1] 都小于等于 pivot, [i+1, right] 都大于 pivot</span>            <span class="hljs-keyword">if</span> K &lt; i - left + <span class="hljs-number">1</span>:                random_select(left, i - <span class="hljs-number">1</span>, K)            <span class="hljs-keyword">elif</span> K &gt; i - left + <span class="hljs-number">1</span>:                random_select(i + <span class="hljs-number">1</span>, right, K - (i - left + <span class="hljs-number">1</span>))        n = len(points)        random_select(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, K)        <span class="hljs-keyword">return</span> points[:K]</code></pre></div><p>我们定义函数 <code>random_select(left, right, K)</code> 表示划分数组 <code>points</code> 的 <code>[left,right]</code> 区间，并且需要找到其中第 <code>K</code> 个距离最小的点。在一次划分操作完成后，设 <code>pivot</code> 的下标为 <code>i</code>，即区间 <code>[left,i−1]</code> 中的点的距离都小于等于<code>pivot</code>，而区间 <code>[i+1,right]</code> 的点的距离都大于<code>pivot</code>。此时会有三种情况：</p><ul><li>如果 <code>K=i−left+1</code>，那么说明 <code>pivot</code> 就是第 <code>K</code> 个距离最小的点，我们可以结束整个过程；</li><li>如果<code>K&lt;i−left+1</code>，那么说明第 <code>K</code> 个距离最小的点在 <code>pivot</code> 左侧，因此递归调用 <code>random_select(left, i - 1, K)；</code></li><li>如果 <code>K&gt;i−left+1</code>，那么说明第 <code>K</code> 个距离最小的点在 <code>pivot</code> 右侧，因此递归调用 <code>random_select(i + 1, right, K - (i - left + 1))</code>。</li></ul><p>在整个过程结束之后，第 <code>K</code> 个距离最小的点恰好就在数组 <code>points</code> 中的第 <code>K</code> 个位置，并且其左侧的所有点的距离都小于它。此时，我们就找到了前 <code>K</code> 个距离最小的点。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：期望为 <code>O(n)</code> </li></ul><ul><li>空间复杂度：期望为 <code>O(logn)</code></li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247488820&idx=1&sn=e6a58b67b0050ae8144bb8ea579cf0d0&chksm=9bd7eb3caca0622a20b407f83decfa56e969002cd4e041b859d4feba1522940a5f7b78849060&xtrack=1&scene=90&subscene=93&sessionid=1605399773&clicktime=1605400161&enterid=1605400161&ascene=56&devicetype=android-25&version=2700143d&nettype=WIFI&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=Awz5DvW825fil6M%2BLvwEqX8%3D&pass_ticket=V6kjxFCodaO6ulJz62AztX5BFdRpGKyzRJ1q2QphALjI6kNqxfieBqEobGrs5JHG&wx_header=1" target="_blank" rel="noopener">快排亲兄弟：快速选择算法详解</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入区间</title>
    <link href="/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/"/>
    <url>/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">区间类问题有很多种：区间合并， 区间交集， 区间插入等等。 区间类问题只要的重难点就是找好区间直接重叠或不相交的条件。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给出一个<em>无重叠的 ，</em>按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p>&nbsp;</p><p><strong>示例&nbsp;1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>intervals = [[1,3],[6,9]], newInterval = [2,5]<strong>输出：</strong>[[1,5],[6,9]]</div></pre></div><p><strong>示例&nbsp;2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]<strong>输出：</strong>[[1,2],[3,10],[12,16]]<strong>解释：</strong>这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10]&nbsp;重叠。</div></pre></div><p>&nbsp;</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>刚刚拿到这一题目，我的第一反应是想用之前解决区间问题的思路来解决这一问题。在这一题中，我们要新增一个区间，那么就会有两者插入情况：</p><ol><li>新插入的区间与原数组中的任何一个区间都不重叠，那么这个时候就要找出需要插入的位置；</li><li>薪插入的区间与原数组中的某些区间有重叠，那么这个时候就要考虑区间合并的问题。</li></ol><p>那么，这道题就好解了！设置好遍历区间和新增区间的三种位置关系，然后依次判断是否相交，然后按照区间合并的思路去做。</p><p>但是，当我真正用这种方法来套用这一题时，发现这么做的代码非常冗余，判断条件很多，稍不注意就会有遗漏的地方。归结到问题的本质还是要找出新区间与原区间的关系，确定好这个关系，问题就好解决了。</p><p><strong>下面来介绍一种新的方法。</strong></p><p><em>方法来源：</em></p><p class="note note-primary">    作者：LeetCode-Solution<br>    链接：<a href="https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-interval/solution/cha-ru-qu-jian-by-leetcode-solution/</a><br>    来源：力扣（LeetCode）<br></p><p>由于题目中的区间列表已经是按照区间起始排好序的，所以每一个区间的起始都大于前一个期间的起始。那么如果新加入的区间起始大于当前区间的结束，那么说明当前区间与新区间没有交集。那么可以遍历下一个区间了。</p><p>如果新加入的区间起始小于当前区间的结束，那么说明这两个区间是有交集的了，如下图所示：</p><img src="/2020/11/04/%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/merge.png" srcset="/img/loading.gif" alt="区间插入过程描述" style="zoom:40%;display: flex;margin: 0 auto;"><p><strong>那么我们就要修改新插入区间的区间范围！！！</strong></p><p>怎样修改？它们的交集即为：<br>$$<br>[min(l1, l2), min(r1, r2)]<br>$$<br>它们的并集为：<br>$$<br>[min(l1, l2), max(r1, r2)]<br>$$<br>那么直接就修改新插入的区间范围。</p><p>什么时候将新区间插入到区间列表中呢？当然是第一个满足新插入区间的结尾小于当前区间的起始的时候，说明它们两个无交集。这个时候就可以将新区间插入到列表中了！</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span>        res = []        remove = <span class="hljs-literal">False</span>        left, right = newInterval        <span class="hljs-keyword">for</span> li, ri <span class="hljs-keyword">in</span> intervals:            <span class="hljs-comment"># 新区间和当前区间无交集，直接将当前区间加到结果中</span>            <span class="hljs-keyword">if</span> left &gt; ri:                res.append([li, ri])            <span class="hljs-comment"># 判断新区间是否要插入到列表中的条件</span>            <span class="hljs-keyword">elif</span> li &gt; right:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> remove:                    res.append([left, right])                    remove = <span class="hljs-literal">True</span>                res.append([li, ri])            <span class="hljs-comment"># 新区间和当前区间有交集，进行新区间范围合并</span>            <span class="hljs-keyword">else</span>:                left = min(li, left)                right = max(ri, right)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> remove:            res.append([left, right])        <span class="hljs-keyword">return</span> res</code></pre></div><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组 <code>intervals</code> 的长度，即给定的区间个数。</li><li>空间复杂度：<code>O(n)</code>，除了存储返回答案的空间以外，我们只需要额外的常数空间即可。</li></ul><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><p>还可以不另外创造新的存储空间，直接对原列表进行原地修改。</p><p>从头到尾找到重叠的区间，记录重叠区间的索引，方便后续的切片替换。当区间不重叠的时候就可以直接替换掉重复的区间段了。</p><p>代码实现如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span><span class="hljs-params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span>        <span class="hljs-comment"># 初始状况判断</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> newInterval:            <span class="hljs-keyword">return</span> intervals        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> intervals:            <span class="hljs-keyword">return</span> [newInterval]        <span class="hljs-comment"># 已经是起点有序的了</span>        i = <span class="hljs-number">0</span>        intervalsLen = len(intervals)        <span class="hljs-keyword">while</span> i &lt; intervalsLen <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">1</span>] &lt; newInterval[<span class="hljs-number">0</span>]:            i += <span class="hljs-number">1</span>        <span class="hljs-comment"># 保存删除之前的位置，最后在这个位置上插入</span>        tempI = i        <span class="hljs-keyword">while</span> i &lt; intervalsLen <span class="hljs-keyword">and</span> intervals[i][<span class="hljs-number">0</span>] &lt;= newInterval[<span class="hljs-number">1</span>]:            newInterval[<span class="hljs-number">0</span>] = min(newInterval[<span class="hljs-number">0</span>], intervals[i][<span class="hljs-number">0</span>])            newInterval[<span class="hljs-number">1</span>] = max(newInterval[<span class="hljs-number">1</span>], intervals[i][<span class="hljs-number">1</span>])            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">del</span> intervals[tempI:i]        intervals.insert(tempI, newInterval)        <span class="hljs-keyword">return</span> intervals</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>困难</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>区间</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集</title>
    <link href="/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
    <url>/2020/11/02/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">求解两个数组的交集问题有很多种写法，这里主要介绍两种方法。还有其他的编程语言特色的求解方法。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>nums1 = [1,2,2,1], nums2 = [2,2]<strong>输出：</strong>[2]</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>nums1 = [4,9,5], nums2 = [9,4,9,8,4]<strong>输出：</strong>[9,4]</div></pre></div><p>&nbsp;</p><p><strong>说明：</strong></p><ul>    <li>输出结果中的每个元素一定是唯一的。</li>    <li>我们可以不考虑输出结果的顺序。</li></ul><h1 id="方法一（借助哈希）"><a href="#方法一（借助哈希）" class="headerlink" title="方法一（借助哈希）"></a>方法一（借助哈希）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>要求解两个数组中的交集，首先我们可以去除掉各自列表中的重复元素。去除重复元素这一过程，可以使用<code>set()</code>集合的性质（不能存储重复元素）进行操作。</p><p>得到精简后的数组后，就可以进行元素级别的比较了。遍历长度较小的数组，然后在另一个数组中查找是否存在其中。这种方法有点还是可以有提升的地方。我们可以将查找的时间复杂度降低。即使用Hash来查找。所以在上一步的操作中，可以使用<code>Java</code>的<code>HashSet()</code>去重的同时，来减少查找的时间复杂度。</p><p>最后一步，定义一个结果变量，如果较短数组中的元素在另外一个数组中，则可以直接将元素添加到结果变量中，直到遍历完整个较短数组。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        nums1 = set(nums1)        nums2 = set(nums2)        <span class="hljs-keyword">if</span> len(nums1) &lt; len(nums2):            <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums1 <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> nums2]        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> nums2 <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> nums1]</code></pre></div><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：<code>O(m+n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 <code>O(m+n)</code> 的时间，遍历较小的集合并判断元素是否在另一个集合中需要 <code>O(min(m,n))</code> 的时间，因此总时间复杂度是 <code>O(m+n)</code>。</p></li><li><p>空间复杂度：<code>O(m+n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。空间复杂度主要取决于两个集合。</p></li></ul><h1 id="方法二（排序-双指针）"><a href="#方法二（排序-双指针）" class="headerlink" title="方法二（排序+双指针）"></a>方法二（排序+双指针）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种方法的解题思路就比较直接了。借助合并两个有序链表的思想，设置两个指针<code>i</code>和<code>j</code>分别指向两个数组<code>nums1</code>和<code>nums2</code>，如果<code>nums1[i] == nums2[j]</code>那么就是两个列表的交集元素。将元素放到无重复元素的<code>set()</code>中。两个元素不相等的情况下，元素小的那个指针往前移一位，直到两个指针越界。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        nums1.sort()        nums2.sort()        res = set()        i, j = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> i&lt;len(nums1) <span class="hljs-keyword">and</span> j&lt;len(nums2):            <span class="hljs-keyword">if</span> nums1[i] &lt; nums2[j]:                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums1[i] &gt; nums2[j]:                j += <span class="hljs-number">1</span>            <span class="hljs-keyword">elif</span> nums1[i] == nums2[j]:                res.add(nums1[i])                i += <span class="hljs-number">1</span>                j += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre></div><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度：<code>O(nlogn)</code>，其中 <code>m</code> 和 <code>n</code> 分别是两个数组的长度。排序的时间复杂度级别是 <code>O(nlogn)</code>，双指针寻找交集元素的时间复杂度级别是 <code>O(n)</code>，因此总时间复杂度是 <code>O(nlogn)</code>。</p></li><li><p>空间复杂度：<code>O(n)</code>，其中 <code>n</code> 是数组的长度。在最坏的情况下，两数组的元素都一样。</p></li></ul><h1 id="其他代码示例"><a href="#其他代码示例" class="headerlink" title="其他代码示例"></a>其他代码示例</h1><h2 id="Python-amp-运算符"><a href="#Python-amp-运算符" class="headerlink" title="Python &amp; 运算符"></a>Python &amp; 运算符</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        <span class="hljs-keyword">return</span> list(set(nums1) &amp; set(nums2))</code></pre></div><p>Python语言中的&amp;运算符可以直接求出两列表的交集</p><h2 id="Java-retainAll-方法"><a href="#Java-retainAll-方法" class="headerlink" title="Java retainAll()方法"></a>Java retainAll()方法</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] intersection(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;    HashSet&lt;Integer&gt; set1 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    HashSet&lt;Integer&gt; set2 = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:nums1)&#123;        list.add(i);    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:nums2)&#123;        set2.add(i);    &#125;    list.retainAll(set2);    set1.addAll(list);    <span class="hljs-keyword">return</span> set1.stream().mapToInt(i-&gt;i).toArray();&#125;</code></pre></div><p><code>A.retainAll(B)</code>方法的含义：移除<code>A</code>中，不包含在<code>B</code>中的元素。</p></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中的最长山脉</title>
    <link href="/2020/10/27/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/"/>
    <url>/2020/10/27/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “<em>山脉”</em>：</p><ul>    <li><code>B.length &gt;= 3</code></li>    <li>存在 <code>0 &lt; i&nbsp;&lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li></ul><p>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）</p><p>给出一个整数数组 <code>A</code>，返回最长 <em>“山脉”</em>&nbsp;的长度。</p><p>如果不含有 “<em>山脉”&nbsp;</em>则返回 <code>0</code>。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>[2,1,4,7,3,2,5]<strong>输出：</strong>5<strong>解释：</strong>最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>[2,2,2]<strong>输出：</strong>0<strong>解释：</strong>不含 “山脉”。</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ol>    <li><code>0 &lt;= A.length &lt;= 10000</code></li>    <li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol><h1 id="方法一（动态规划）"><a href="#方法一（动态规划）" class="headerlink" title="方法一（动态规划）"></a>方法一（动态规划）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题的做法可以想到 <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank">674.最长连续递增序列</a><br></p><p><code>dp1</code>: 从左到右记录以这个数为结尾的最长连续递增序列长度</p><p><code>dp2</code>: 从右到左记录以这个数为结尾的最长连续递增序列长度</p><p>最后遍历一遍统计 <code>dp1[i] + dp2[i] - 1</code>为以这个数为山脉最高点的最长长度</p><p><code>nums = [2,1,4,7,3,2,5]</code></p><p><code>dp1 = [1,1,2,3,1,1,2]</code></p><p><code>dp2 = [2,1,1,3,2,1,1]</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestMountain</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        方法一：使用动态规划的思想解决问题</span><span class="hljs-string">        """</span>        la = [<span class="hljs-number">0</span>]*len(A)        lb = [<span class="hljs-number">0</span>]*len(A)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(A)):            <span class="hljs-keyword">if</span> A[i] &gt; A[i<span class="hljs-number">-1</span>]:                la[i] = la[i<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>         <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(A)<span class="hljs-number">-1</span>)[::<span class="hljs-number">-1</span>]:            <span class="hljs-keyword">if</span> A[j] &gt;A[j+<span class="hljs-number">1</span>]:                lb[j] = lb[j+<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(A)):            <span class="hljs-keyword">if</span> la[i]&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> lb[i]&gt;<span class="hljs-number">0</span>:                res = max(res, la[i]+lb[i]+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> res</code></pre></div><h1 id="方法二（标记法）"><a href="#方法二（标记法）" class="headerlink" title="方法二（标记法）"></a>方法二（标记法）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个变量 <code>increasing</code> 和 <code>decreasing</code>，分别记录每个山脉上升区间的长度以及下降区间的长度。通过遍历，寻找最长的山脉。</p><p>遍历一遍数组，如果遇到连续递增的情况，那么 <code>increasing</code>就加一；如果遇到连续递减的情况，那么 <code>decreasing</code>就减一。</p><p>如果数组中只有一个<em>山</em>的话，那么遍历完一遍之后， <code>increasing</code> 和 <code>decreasing</code>的和加一就是最后的结果。</p><p>为了防止一个数组中出现很多个<em>山</em>的情况，我们在每次的外循环使 <code>increasing</code> 和 <code>decreasing</code>的值清零。</p><p>如果遇到相邻两元素值相同的情况，我们直接跳过即可。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestMountain</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        方法二：使用两个变量increasing和decreasing，分别记录每个山脉上升区间的长度以及下降区间的长度。通过遍历，寻找最长的山脉。</span><span class="hljs-string">        """</span>        maxLength = <span class="hljs-number">0</span>        j = <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> j &lt; len(A):            increasing, decreasing = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> j &lt; len(A) <span class="hljs-keyword">and</span> A[j<span class="hljs-number">-1</span>] &lt; A[j]:                j += <span class="hljs-number">1</span>                increasing += <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> j &lt; len(A) <span class="hljs-keyword">and</span> A[j<span class="hljs-number">-1</span>] &gt; A[j]:                j += <span class="hljs-number">1</span>                decreasing += <span class="hljs-number">1</span>                        <span class="hljs-keyword">if</span> increasing &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> decreasing &gt; <span class="hljs-number">0</span>:                maxLength = max(maxLength, increasing + decreasing + <span class="hljs-number">1</span>)            <span class="hljs-keyword">while</span> j &lt; len(A) <span class="hljs-keyword">and</span> A[j<span class="hljs-number">-1</span>] == A[j]:                j += <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> maxLength</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>划分字母区间问题</title>
    <link href="/2020/10/24/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <url>/2020/10/24/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p>&nbsp;</p><p><strong>示例：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "ababcbacadefegdehijhklij"<strong>输出：</strong>[9,7,8]<strong>解释：</strong>划分结果为 "ababcbaca", "defegde", "hijhklij"。每个字母最多出现在一个片段中。像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>    <li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li></ul><h1 id="方法一（贪心-双指针）"><a href="#方法一（贪心-双指针）" class="headerlink" title="方法一（贪心+双指针）"></a>方法一（贪心+双指针）</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。因此需要遍历字符串，得到每个字母最后一次出现的下标位置。</p><p>想切割，要有首尾两个指针，确定了结尾指针，就能确定下一个切割的开始指针。<br>遍历字符串，如果已扫描部分的所有字符，都只出现在已扫描的范围内，即可做切割。<br></p><p>我们假设变量<code>start</code>和<code>maxIndex</code>为开始和结束的两个标记指针。由于上一步已经得到了每个字符出现的最后索引。所以变遍历每个字母的同时，边求得出现索引最远的字母。这样，就可以确保之前所有的字符的出现位置都小于索引出现最远的字母了。</p><p>如果当前位置<code>i</code>已经等于最远出现的字符索引，那么在这里就可以直接切割，使用<code>maxIndex-start+1</code>来求得每段分割的最长数量，从而达到最多的分割数。</p><p>上述做法使用贪心的思想寻找每个片段可能的最小结束下标，因此可以保证每个片段的长度一定是符合要求的最短长度，如果取更短的片段，则一定会出现同一个字母出现在多个片段中的情况。由于每次取的片段都是符合要求的最短的片段，因此得到的片段数也是最多的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span><span class="hljs-params">(self, S: str)</span> -&gt; List[int]:</span>        mapping = &#123;&#125;        <span class="hljs-keyword">for</span> i,char <span class="hljs-keyword">in</span> enumerate(S):            mapping[char] = i        start, maxIndex = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        result = []        <span class="hljs-keyword">for</span> i,char <span class="hljs-keyword">in</span> enumerate(S):            maxIndex = max(maxIndex, mapping[char])            <span class="hljs-keyword">if</span> i == maxIndex:                result.append(maxIndex-start+<span class="hljs-number">1</span>)                start = maxIndex+<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> result</code></pre></div><h1 id="方法二（区间合并转换）"><a href="#方法二（区间合并转换）" class="headerlink" title="方法二（区间合并转换）"></a>方法二（区间合并转换）</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个问题的解题过程可以转化为求解区间合并的问题。</p><p>要求出字符出现的最远出现位置，可以把它看成这个字符出现区间的末端。而第一出现该字符的位置为头端。这样就构成了每个字符出现从开始到结束的区间范围，如下如所示：</p><img src="/2020/10/24/%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/set.JPG" srcset="/img/loading.gif" alt="区间划分" style="zoom:87%;display: flex;margin: 0 auto;"><p>那么从这个图中就可以受到区间合并的启发，可以看到要使同一字母最多出现在一个片段中，那么只要确保最远出现的字符的位置就可以了。最远出现字符的位置可以对小于其出现位置的字符区间进行合并，从而是原字符串分为三个颜色的分断。从图中很容易看出。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partitionLabels</span><span class="hljs-params">(self, S: str)</span> -&gt; List[int]:</span>        intervals=&#123;&#125;        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(S)):            <span class="hljs-comment"># 如果第一次出现就加入区间[i,i]</span>            <span class="hljs-keyword">if</span> S[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> intervals:                intervals[S[i]]=[i,i]            <span class="hljs-comment"># 如果已经出现过，就更新区间终点</span>            <span class="hljs-keyword">else</span>:                intervals[S[i]][<span class="hljs-number">1</span>]=i        <span class="hljs-comment"># 把所有区间取出放入列表, 然后根据区间起点排序</span>        temp=list(intervals.values())        temp.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>])        ans = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(temp)):            <span class="hljs-comment"># 不可能存在相等的情况，区间完全不相交，直接加上即可</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> ans <span class="hljs-keyword">or</span> ans[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] &lt; temp[i][<span class="hljs-number">0</span>]:                ans.append(temp[i])            <span class="hljs-comment"># 在区间重叠的情况下，如果终点更大，则更新</span>            <span class="hljs-keyword">elif</span> temp[i][<span class="hljs-number">1</span>] &gt; ans[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]:                ans[<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>] = temp[i][<span class="hljs-number">1</span>]        res=[x[<span class="hljs-number">1</span>]-x[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> ans]                      <span class="hljs-keyword">return</span> res</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>比较含退格的字符串</title>
    <link href="/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<style>    .css-13ynzks-InfoWrap {        width: 100%;        border: 1px solid rgba(var(--grey-3-rgb),1);        padding: 12px 20px 20px;    }    .css-1493omj-TestcaseDiv {        color: rgba(var(--grey-7-rgb),1);    }    .css-q5jqx5-DescSpan {        color: rgba(var(--grey-6-rgb),1);    }</style><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "ab#c", T = "ad#c"<strong>输出：</strong>true<strong>解释：</strong>S 和 T 都会变成 “ac”。</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "ab##", T = "c#d#"<strong>输出：</strong>true<strong>解释：</strong>S 和 T 都会变成 “”。</div></pre></div><p><strong>示例 3：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "a##c", T = "#a#c"<strong>输出：</strong>true<strong>解释：</strong>S 和 T 都会变成 “c”。</div></pre></div><p><strong>示例 4：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>S = "a#c", T = "b"<strong>输出：</strong>false<strong>解释：</strong>S 会变成 “c”，但 T 仍然是 “b”。</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ol>    <li><code>1 &lt;= S.length &lt;= 200</code></li>    <li><code>1 &lt;= T.length &lt;= 200</code></li>    <li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>'#'</code>。</li></ol><p>&nbsp;</p><p><strong>进阶：</strong></p><ul>    <li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="方法一：直接比较法"><a href="#方法一：直接比较法" class="headerlink" title="方法一：直接比较法"></a>方法一：直接比较法</h2><p>最简单的方法就是直接将两字符串中的<code>#</code>和其前一个字符去掉，比较剩余的字符是否相等。若相等则返回<code>true</code>。</p><p>我们如何在最好的时间内去掉<code>#</code>和其前一个字符呢？</p><p>在不考虑空间开销的情况下，我们可以考虑构造两个辅助栈来完成操作。如果遇到<code>#</code>，那么就取出栈顶的元素，这样也就模拟了删掉<code>#</code>前一个字符的效果。那么最后栈中剩余的元素就是去掉退格字符后的所有剩余字符。然后就可以将两个栈中的字符依次比较是否相同。这种方法的代码如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        Stack&lt;Character&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        Stack&lt;Character&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;S.length(); i++)&#123;            <span class="hljs-keyword">if</span>(S.charAt(i)!=<span class="hljs-string">'#'</span>) stack1.add(S.charAt(i));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack1.isEmpty()) stack1.pop();        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;T.length(); j++)&#123;            <span class="hljs-keyword">if</span>(T.charAt(j)!=<span class="hljs-string">'#'</span>) stack2.add(T.charAt(j));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!stack2.isEmpty()) stack2.pop();        &#125;        <span class="hljs-keyword">return</span> stack1.equals(stack2);    &#125;&#125;</code></pre></div><div class="css-13ynzks-InfoWrap ejyx8z41"><div><div class="css-1493omj-TestcaseDiv ejyx8z42"><strong>110 / 110</strong> 个通过测试用例</div><span class="css-q5jqx5-DescSpan ejyx8z43">状态：<i class="css-1qe57zj-Status ejyx8z44">通过</i></span></div><div><div><div class="css-1493omj-TestcaseDiv ejyx8z42">执行用时: <strong>3 ms</strong></div><div class="css-1493omj-TestcaseDiv ejyx8z42">内存消耗: <strong>36.3 MB</strong></div></div></div></div><p>由于额外创建了两个辅助栈，所以时间复杂度还是有一些偏高。我们再尝试做一些改进：</p><p><strong>那么本题，确实可以使用栈的思路，但是没有必要使用栈，因为最后比较的时候还要比较栈里的元素，有点麻烦</strong>。为了减轻开销，可以使用拼接字符串的方式将剩余的字符进行拼接，最后进行比较的是便是两个字符串。这样就会比比较两个集合的元素是否相同还要更快。</p><p>我们使用<code>Java</code>中的<code>StringBuffe</code>r类来实现字符串的拼接。如果没有遇到#字符，则将该字符拼接到<code>StringBuffer</code>的对象中，否则删除<code>StringBuffer</code>对象的最后一个字符。最后返回两者对象的字符串进行比较。代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        build(S).equals(build(T));    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">build</span><span class="hljs-params">(String str)</span> </span>&#123;        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        <span class="hljs-keyword">int</span> len = str.length();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (str.charAt(i) != <span class="hljs-string">'#'</span>)                sb.append(str.charAt(i));            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sb.length() &gt; <span class="hljs-number">0</span>)                sb.deleteCharAt(sb.length() - <span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> sb.toString();    &#125;&#125;</code></pre></div><div class="css-13ynzks-InfoWrap ejyx8z41"><div><div class="css-1493omj-TestcaseDiv ejyx8z42"><strong>110 / 110</strong> 个通过测试用例</div><span class="css-q5jqx5-DescSpan ejyx8z43">状态：<i class="css-1qe57zj-Status ejyx8z44">通过</i></span></div><div><div><div class="css-1493omj-TestcaseDiv ejyx8z42">执行用时: <strong>1 ms</strong></div><div class="css-1493omj-TestcaseDiv ejyx8z42">内存消耗: <strong>36.4 MB</strong></div></div></div></div><p>两次的结果进行对比可以看到，从时间复杂度上，改进之后的方法执行时间更短。但是两次方法的内存消耗没有什么大的变化。有没有一种方法，既可以保持这种优秀的执行时间还保证内存消耗的更少呢？下面就介绍这种双指针的方法来减少内存消耗。</p><h2 id="方法二：双指针法："><a href="#方法二：双指针法：" class="headerlink" title="方法二：双指针法："></a>方法二：双指针法：</h2><p>同时从后向前遍历<code>S</code>和T（<code>i</code>初始为<code>S</code>末尾，<code>j</code>初始为<code>T</code>末尾），记录<code>#</code>的数量，模拟消除的操作，如果<code>#</code>用完了，就开始比较<code>S[i]</code>和<code>S[j]</code>。</p><p>具体地，我们定义 <code>skip</code> 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p><ul><li><p>若该字符为退格符，则我们需要多删除一个普通字符，我们让 <code>skip</code> 加 <code>1</code>；</p></li><li><p>若该字符为普通字符：</p><ul><li><p>若 <code>skip</code>为 <code>0</code>，则说明当前字符不需要删去；</p></li><li><p>若<code>skip</code>不为 <code>0</code>，则说明当前字符需要删去，我们让<code>skip</code> 减 <code>1</code>。</p></li></ul></li></ul><img src="/2020/10/19/%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/motion.gif" srcset="/img/loading.gif" alt="比较含退格的字符串" style="zoom:100%;display: flex;margin: 0 auto;"><p>如果<code>S[i]</code>和<code>S[j]</code>不相同返回<code>false</code>，如果有一个指针（<code>i</code>或者<code>j</code>）先走到的字符串头部位置，也返回<code>false</code>。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(String S, String T)</span> </span>&#123;        <span class="hljs-keyword">int</span> skipS = <span class="hljs-number">0</span>, skipT = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> i = S.length()-<span class="hljs-number">1</span>, j = T.length()-<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;            <span class="hljs-keyword">while</span>(i&gt;=<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(S.charAt(i) == <span class="hljs-string">'#'</span>) skipS++;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(skipS&gt;<span class="hljs-number">0</span>) skipS--;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;                i--;            &#125;            <span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">if</span>(T.charAt(j) == <span class="hljs-string">'#'</span>) skipT++;                <span class="hljs-keyword">else</span>&#123;                    <span class="hljs-keyword">if</span>(skipT&gt;<span class="hljs-number">0</span>) skipT--;                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;                &#125;                j--;            &#125;            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span> || j&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">if</span>(S.charAt(i)!=T.charAt(j)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            i--;j--;        &#125;        <span class="hljs-keyword">if</span>(i == -<span class="hljs-number">1</span> &amp;&amp; j == -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;&#125;</code></pre></div><p><strong>复杂度分析</strong></p><p>时间复杂度：<em>O</em>(<em>N</em>+<em>M</em>)，其中 <em>N</em> 和 <em>M</em> 分别为字符串 <em>S</em> 和 <em>T</em> 的长度。我们需要遍历两字符串各一次。</p><p>空间复杂度：<em>O</em>(1)。对于每个字符串，我们只需要定义一个指针和一个计数器即可。</p><div class="css-13ynzks-InfoWrap ejyx8z41"><div><div class="css-1493omj-TestcaseDiv ejyx8z42"><strong>110 / 110</strong> 个通过测试用例</div><span class="css-q5jqx5-DescSpan ejyx8z43">状态：<i class="css-1qe57zj-Status ejyx8z44">通过</i></span></div><div><div><div class="css-1493omj-TestcaseDiv ejyx8z42">执行用时: <strong>0 ms</strong></div><div class="css-1493omj-TestcaseDiv ejyx8z42">内存消耗: <strong>36.4 MB</strong></div></div></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学会Python装饰器（简易版）</title>
    <link href="/2020/10/18/%E5%AD%A6%E4%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/"/>
    <url>/2020/10/18/%E5%AD%A6%E4%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 data-tool="mdnice编辑器" style="font-weight: bold;color: black;font-size: 22px;margin-top: 20px;margin-right: 10px;"><span style="font-size: 18px;color: rgb(34, 34, 34);display: inline-block;padding-left: 10px;border-left: 5px solid rgb(248, 57, 41);">学会 Python 装饰器</span><br></h2><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰器，几乎各大Python框架中都能看到它的身影，足以表明它的价值！它有动态改变函数或类功能的魔力！</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">1 什么是装饰器</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">对于受到封装的原函数比如<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>来说，装饰器能够在<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>函数<span style="font-weight: 700;color: rgb(248, 57, 41);">执行前</span>或者<span style="font-weight: 700;color: rgb(248, 57, 41);">执行后</span>分别运行一些代码。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">2 装饰器的结构</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰器也是一个函数，它装饰原函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>或类<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">cls</code>后，再返回一个函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">g</code></p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰一个函数：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">decorator</span><span style="line-height: 26px;">(f)</span>:</span><br>&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;定义要返回的函数</span><br>&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'函数f执行前的动作'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'函数f执行后的动作'</span>)<br>&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">装饰一个类：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">decorator</span><span style="line-height: 26px;">(cls)</span>:</span><br>&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;定义要返回的函数</span><br>&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'类cls执行前的动作'</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'类cls执行后的动作'</span>)<br>&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用装饰器很简单，@+自定义装饰器 装饰要想装饰的函数。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">3 为什么要这样</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">要想理解装饰器为什么要有这种结构，要首先想明白装饰器的目标是什么。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">它的价值在于为原函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>增加一些行为，前提必须不能破坏函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>，所以肯定不能改变f的内部结构，所以只能在调用f前后定义一些行为。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">同时，装饰器函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">decorator</code>返回值又是什么？你可以思考下，返回一个函数是再好不过的了，它包装了原函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>.</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">4 装饰一个函数</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">printStar函数接收一个函数<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code>，返回值也是一个函数，所以满足装饰器的结构要求，所以printStar是一个装饰器。</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">printStar</span><span style="line-height: 26px;">(f)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">printStar装饰器实现f函数执行前、后各打印20个*字符。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用printStar:</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'hello&nbsp;world'</span>)<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">调用：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;__name__&nbsp;==&nbsp;<span style="color: #98c379;line-height: 26px;">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">###&nbsp;改变函数功能</span><br>&nbsp;&nbsp;&nbsp;f()<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">打印结果：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;">********************<br>hello&nbsp;world<br>********************<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">可以很方便的装饰要想装饰的其他函数，如下：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'welcome&nbsp;to&nbsp;Python'</span>)<br></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">5 装饰一个类</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">除了可以装饰函数f外，还可以装饰类cls，两者原理都是一样的。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">下面给出一个装饰器实现单例模式的例子，所谓单例就是类只有唯一实例，不能有第二个。</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">singleton</span><span style="line-height: 26px;">(cls)</span>:</span><br>&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;{}<br><br>&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">get_instance</span><span style="line-height: 26px;">(*args,&nbsp;**kwargs)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;cls&nbsp;<span style="color: #c678dd;line-height: 26px;">not</span>&nbsp;<span style="color: #c678dd;line-height: 26px;">in</span>&nbsp;instance:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance[cls]&nbsp;=&nbsp;cls(*args,&nbsp;**kwargs)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;instance[cls]<br>&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;get_instance<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">定义字典<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">instance</code>，键值对分别为类和实例，这样确保只cls()一次。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用装饰器singleton修饰类：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@singleton</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">class</span>&nbsp;<span style="color: #e6c07b;line-height: 26px;">CorePoint</span>:</span><br>&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">pass</span><br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">测试：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;__name__&nbsp;==&nbsp;<span style="color: #98c379;line-height: 26px;">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">###&nbsp;改变类的功能</span><br>&nbsp;&nbsp;&nbsp;c1&nbsp;=&nbsp;CorePoint()<br>&nbsp;&nbsp;&nbsp;c2&nbsp;=&nbsp;CorePoint()<br>&nbsp;&nbsp;&nbsp;print(c1&nbsp;<span style="color: #c678dd;line-height: 26px;">is</span>&nbsp;c2)&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;True</span><br></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">6 装饰器层叠</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">上面原函数f不仅能被一个装饰器修饰，还能被n多个装饰器修饰。</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">下面再定义一个装饰器printLine，被修饰函数执行前后打印20个 -</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">printLine</span><span style="line-height: 26px;">(f)</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'-'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'-'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">使用上文定义好的<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">printStar</code>和<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">printLine</code>同时装饰函数f：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="color: #61aeee;line-height: 26px;">@printLine</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'hello&nbsp;world'</span>)<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">此时再调用函数f:</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">if</span>&nbsp;__name__&nbsp;==&nbsp;<span style="color: #98c379;line-height: 26px;">'__main__'</span>:<br>&nbsp;&nbsp;&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">###&nbsp;改变函数功能</span><br>&nbsp;&nbsp;&nbsp;f()<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">打印结果：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;">********************<br>--------------------<br>hello&nbsp;world<br>--------------------<br>********************<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">f被装饰后，先打印*，再打印 -</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">层叠多一层，原函数f就变强大一层。使用装饰器，还能实现功能抽离，进一步实现松耦合。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">7 温馨提醒</span><span style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">打印原函数f的名字<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">__name__</code>，结果为<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">f</code></p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;">In&nbsp;[<span style="color: #d19a66;line-height: 26px;">1</span>]:&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span>&nbsp;<br>&nbsp;&nbsp;&nbsp;...:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">pass</span>&nbsp;<br><br>In&nbsp;[<span style="color: #d19a66;line-height: 26px;">4</span>]:&nbsp;f.__name__&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>Out[<span style="color: #d19a66;line-height: 26px;">4</span>]:&nbsp;<span style="color: #98c379;line-height: 26px;">'f'</span><br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">但是，被装饰后函数名字f变为g，这不是我们希望的！</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #61aeee;line-height: 26px;">@printStar</span><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">f</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">pass</span><br><br>f()<br>f.__name__&nbsp;<span style="color: #5c6370;font-style: italic;line-height: 26px;">#&nbsp;g</span><br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">Python提供的解决方案：使用functools模块中的<code style="font-size: 14px;overflow-wrap: break-word;padding: 2px 4px;border-radius: 4px;margin-right: 2px;margin-left: 2px;background-color: rgba(27, 31, 35, 0.05);font-family: &quot;Operator Mono&quot;, Consolas, Monaco, Menlo, monospace;word-break: break-all;color: rgb(255, 93, 108);">wraps</code>装饰器：</p><div class="hljs"><pre><code style="overflow-x: auto;padding: 16px;color: #abb2bf;background: #282c34;display: -webkit-box;font-family: Operator Mono, Consolas, Monaco, Menlo, monospace;border-radius: 0px;font-size: 12px;-webkit-overflow-scrolling: touch;"><span style="color: #c678dd;line-height: 26px;">from</span>&nbsp;functools&nbsp;<span style="color: #c678dd;line-height: 26px;">import</span>&nbsp;wraps<br><br><span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">printStar</span><span style="line-height: 26px;">(f)</span>:</span><br><span style="color: #61aeee;line-height: 26px;">&nbsp;&nbsp;&nbsp;&nbsp;@wraps(f)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="line-height: 26px;"><span style="color: #c678dd;line-height: 26px;">def</span>&nbsp;<span style="color: #61aeee;line-height: 26px;">g</span><span style="line-height: 26px;">()</span>:</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span style="color: #98c379;line-height: 26px;">'*'</span>*<span style="color: #d19a66;line-height: 26px;">20</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span style="color: #c678dd;line-height: 26px;">return</span>&nbsp;g<br></code></pre></div><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">此时再打印被装饰后f的名字，显示f，正常！</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px;margin-bottom: 15px;font-weight: bold;color: black;font-size: 20px;"><span style="display: none;"></span><span style="font-size: 16px;color: #222;">总结</span><span style="display: none;"></span></h3><ul class="list-paddingleft-2" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;width: 567.205px;font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &quot;PingFang SC&quot;, Cambria, Cochin, Georgia, Times, &quot;Times New Roman&quot;, serif;font-size: 16px;letter-spacing: 0.8px;text-align: left;white-space: normal;word-spacing: 0.8px;color: rgb(248, 57, 41);"><li><p>学会 Python 装饰器</p></li><ul class="list-paddingleft-2" style="margin-top: 8px;margin-bottom: 8px;padding-left: 25px;width: 541.658px;list-style-type: square;"><li><p>1 什么是装饰器</p></li><li><p>2 装饰器的结构</p></li><li><p>3 为什么要这样</p></li><li><p>4 装饰一个函数</p></li><li><p>5 装饰一个类</p></li><li><p>6 装饰器层叠</p></li><li><p>7 温馨提醒</p></li><li><p>总结</p></li></ul></ul><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">以上就是装饰器的核心使用逻辑专题，希望能帮助到各位读者，若觉得有用，欢迎大家分享！</p><p data-tool="mdnice编辑器" style="padding-top: 8px;padding-bottom: 8px;line-height: 1.75;margin-top: 0.8em;margin-bottom: 0.8em;">推荐各位读者关注另一个公众号《刷题日记》，不仅仅是刷题...</p><img src="/2020/10/18/%E5%AD%A6%E4%BC%9APython%E8%A3%85%E9%A5%B0%E5%99%A8%EF%BC%88%E7%AE%80%E6%98%93%E7%89%88%EF%BC%89/640.webp" srcset="/img/loading.gif" alt="刷题日记" style="zoom:80%;display: flex;margin: 0 auto;"><h3 id="文章来源"><a href="#文章来源" class="headerlink" title="文章来源"></a>文章来源</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NTkyMjA4NA==&mid=2247497338&idx=1&sn=b6a2637de1a79930ed9dd76695819403&chksm=eb7fdbb1dc0852a789f9fb7327041198596c3d85d0f731f5ce6d1a8eb354d6b11b053cd42711&scene=21#wechat_redirect" target="_blank" rel="noopener">搞定三大神器之 Python 装饰器</a></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习项目（二）：房价预测</title>
    <link href="/2020/10/18/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/"/>
    <url>/2020/10/18/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>数据集的下载地址为：</p><p><a href="train.csv">train.csv</a></p><p><a href="test.csv">test.csv</a></p><h3 id="首先导入我们程序所需要的几个包："><a href="#首先导入我们程序所需要的几个包：" class="headerlink" title="首先导入我们程序所需要的几个包："></a>首先导入我们程序所需要的几个包：</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer</code></pre></div><h1 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h1><p>加载数据，输出训练集和测试集的形状。</p><div class="hljs"><pre><code class="hljs python">x = pd.read_csv(<span class="hljs-string">'./data/train.csv'</span>, index_col=<span class="hljs-string">'Id'</span>)x_test = pd.read_csv(<span class="hljs-string">'./data/test.csv'</span>, index_col=<span class="hljs-string">'Id'</span>)print(<span class="hljs-string">'Train data size:&#123;&#125;'</span>.format(x.shape))print(<span class="hljs-string">'Test data size:&#123;&#125;'</span>.format(x_test.shape))</code></pre></div><div class="hljs"><pre><code class="hljs python">Train data size:(<span class="hljs-number">1460</span>, <span class="hljs-number">80</span>)Test data size:(<span class="hljs-number">1459</span>, <span class="hljs-number">79</span>)</code></pre></div><p>去掉输出值为空的行（样本），然后将输出值赋值给y变量，在训练集中删除输出值，使训练集和测试集的特征数量相等。<br>然后将训练数据分为训练集和验证集，分别占比<code>80%</code>和<code>20%</code>。</p><div class="hljs"><pre><code class="hljs python">x.dropna(axis=<span class="hljs-number">0</span>, subset=[<span class="hljs-string">'SalePrice'</span>], inplace=<span class="hljs-literal">True</span>)y = x[<span class="hljs-string">'SalePrice'</span>]x.drop([<span class="hljs-string">'SalePrice'</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)x_train, x_val, y_train, y_val = train_test_split(x, y, train_size=<span class="hljs-number">0.8</span>, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">0</span>)print(<span class="hljs-string">'Train data size:&#123;&#125;'</span>.format(x_train.shape))print(<span class="hljs-string">'Test data size:&#123;&#125;'</span>.format(x_val.shape))</code></pre></div><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>统计包含空值的属性列</p><div class="hljs"><pre><code class="hljs python">miss_count = x_train.isnull().sum()cols_with_missing = list(miss_count[miss_count &gt; <span class="hljs-number">0</span>].index)print(<span class="hljs-string">'Numbers of missing values:&#123;&#125;'</span>.format(len(cols_with_missing)))print(<span class="hljs-string">'Missing features:'</span>, cols_with_missing)</code></pre></div><p>统计包含分类变量的属性列</p><div class="hljs"><pre><code class="hljs python">categorical_features = (x_train.dtypes == <span class="hljs-string">'object'</span>)categorical_features_list = list(categorical_features[categorical_features].index)print(<span class="hljs-string">'Numbers of categorical features:&#123;&#125;'</span>.format(len(categorical_features_list)))print(<span class="hljs-string">'Categorical features:'</span>, categorical_features_list)</code></pre></div><h2 id="在处理空值的方法中，主要有以下几种："><a href="#在处理空值的方法中，主要有以下几种：" class="headerlink" title="在处理空值的方法中，主要有以下几种："></a>在处理空值的方法中，主要有以下几种：</h2><h3 id="1-直接删掉空值属性；"><a href="#1-直接删掉空值属性；" class="headerlink" title="1.直接删掉空值属性；"></a>1.直接删掉空值属性；</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Fill in the line below: get names of columns with missing values</span>column_missing = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> x_train.columns <span class="hljs-keyword">if</span> x_train[col].isnull().any()] <span class="hljs-comment"># Your code here</span><span class="hljs-comment"># Fill in the lines below: drop columns in training and validation data</span>reduced_x_train = x_train.drop(column_missing, axis=<span class="hljs-number">1</span>)reduced_x_val = x_val.drop(column_missing, axis=<span class="hljs-number">1</span>)</code></pre></div><h3 id="2-特殊值填充属性中的空值，例如：中位数；"><a href="#2-特殊值填充属性中的空值，例如：中位数；" class="headerlink" title="2.特殊值填充属性中的空值，例如：中位数；"></a>2.特殊值填充属性中的空值，例如：中位数；</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Fill in the lines below: imputation</span>my_impute = SimpleImputer(strategy=<span class="hljs-string">'median'</span>) <span class="hljs-comment"># Your code here</span>imputed_X_train = pd.DataFrame(my_impute.fit_transform(x_train))imputed_X_valid = pd.DataFrame(my_impute.transform(x_val))<span class="hljs-comment"># Fill in the lines below: imputation removed column names; put them back</span>imputed_X_train.columns = x_train.columnsimputed_X_valid.columns = x_val.columns</code></pre></div><h3 id="3-改进版的特殊值填充，设置标志位"><a href="#3-改进版的特殊值填充，设置标志位" class="headerlink" title="3. 改进版的特殊值填充，设置标志位"></a>3. 改进版的特殊值填充，设置标志位</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Make copy to avoid changing original data (when imputing)</span>x_train_plus = x_train.copy()x_val_plus = x_val.copy()<span class="hljs-comment"># Make new columns indicating what will be imputed</span><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> cols_with_missing:    x_train_plus[col + <span class="hljs-string">'_was_missing'</span>] = x_train_plus[col].isnull()    x_val_plus[col + <span class="hljs-string">'_was_missing'</span>] = x_val_plus[col].isnull()<span class="hljs-comment"># Imputation</span>my_imputer = SimpleImputer()imputed_x_train_plus = pd.DataFrame(my_imputer.fit_transform(x_train_plus))imputed_x_val_plus = pd.DataFrame(my_imputer.transform(x_val_plus))<span class="hljs-comment"># Imputation removed column names; put them back</span>imputed_x_train_plus.columns = x_train_plus.columnsimputed_x_val_plus.columns = x_val_plus.columns</code></pre></div><h2 id="在处理分类变量的方法中，主要有以下几种："><a href="#在处理分类变量的方法中，主要有以下几种：" class="headerlink" title="在处理分类变量的方法中，主要有以下几种："></a>在处理分类变量的方法中，主要有以下几种：</h2><h3 id="1-直接删掉分类变量的属性；"><a href="#1-直接删掉分类变量的属性；" class="headerlink" title="1.直接删掉分类变量的属性；"></a>1.直接删掉分类变量的属性；</h3><div class="hljs"><pre><code class="hljs python">drop_X_train = X_train.select_dtypes(exclude=[<span class="hljs-string">'object'</span>])drop_X_valid = X_valid.select_dtypes(exclude=[<span class="hljs-string">'object'</span>])</code></pre></div><h3 id="2-使用Label-Encoding；"><a href="#2-使用Label-Encoding；" class="headerlink" title="2.使用Label Encoding；"></a>2.使用Label Encoding；</h3><p>在对特征进行编码时，要考虑训练集的分类变量范围是否和训练集的分类变量范围相同，不多不少。如果不相同的情况，则直接删除掉范围不同的属性。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># All categorical columns</span>object_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> x.columns <span class="hljs-keyword">if</span> x_test[col].dtype == <span class="hljs-string">"object"</span>]<span class="hljs-comment"># Columns that can be safely label encoded</span>good_label_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> object_cols <span class="hljs-keyword">if</span>                    set(x[col]) == set(x_test[col])]        <span class="hljs-comment"># Problematic columns that will be dropped from the dataset</span>bad_label_cols = list(set(object_cols)-set(good_label_cols))        print(<span class="hljs-string">'Categorical columns that will be label encoded:\n'</span>, good_label_cols)print(<span class="hljs-string">'\nCategorical columns that will be dropped from the dataset:\n'</span>, bad_label_cols)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> LabelEncoder<span class="hljs-comment"># Drop categorical columns that will not be encoded</span>label_x_train = x_train.drop(bad_label_cols, axis=<span class="hljs-number">1</span>)label_x_val = x_val.drop(bad_label_cols, axis=<span class="hljs-number">1</span>)label_x_test = x_test.drop(bad_label_cols, axis=<span class="hljs-number">1</span>)print(label_x_train.shape)print(label_x_val.shape)print(label_x_test.shape)<span class="hljs-comment"># label_x_train = x_train.select_dtypes(include=['object'])</span><span class="hljs-comment"># label_x_val = x_val.select_dtypes(include=['object'])</span><span class="hljs-comment"># label_x_test = x_test.select_dtypes(include=['object'])</span><span class="hljs-comment"># Apply label encoder to each column with categorical data</span>label_encoder = LabelEncoder()<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> good_label_cols:    label_x_train[col] = label_encoder.fit_transform(x_train[col])    label_x_val[col] = label_encoder.transform(x_val[col])    label_x_test[col] = label_encoder.transform(x_test[col])</code></pre></div><h3 id="3-使用One-Hot-Encoding；"><a href="#3-使用One-Hot-Encoding；" class="headerlink" title="3.使用One-Hot Encoding；"></a>3.使用One-Hot Encoding；</h3><p>在使用<code>One-Hot</code>编码之前先查看每个属性的基数，我们只将基数小的属性进行<code>One-Hot</code>编码，基数较大的使用<code>Label Encoding</code>编码比较方便。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Get number of unique entries in each column with categorical data</span>object_nunique = list(map(<span class="hljs-keyword">lambda</span> col: label_x_train[col].nunique(), object_cols))d = dict(zip(object_cols, object_nunique))<span class="hljs-comment"># Print number of unique entries by column, in ascending order</span>sorted(d.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Columns that will be one-hot encoded</span>low_cardinality_cols = [col <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> object_cols <span class="hljs-keyword">if</span> x[col].nunique() &lt; <span class="hljs-number">10</span>]<span class="hljs-comment"># Columns that will be dropped from the dataset</span>high_cardinality_cols = list(set(object_cols)-set(low_cardinality_cols))print(<span class="hljs-string">'Categorical columns that will be one-hot encoded:'</span>, low_cardinality_cols)print(<span class="hljs-string">'\nCategorical columns that will be dropped from the dataset:'</span>, high_cardinality_cols)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<span class="hljs-comment"># Use as many lines of code as you need!</span>oh_encoder = OneHotEncoder(handle_unknown=<span class="hljs-string">'ignore'</span>, sparse=<span class="hljs-literal">False</span>)print(x[low_cardinality_cols].describe())print(x_test[low_cardinality_cols].describe())OH_col_train = pd.DataFrame(oh_encoder.fit_transform(x[low_cardinality_cols]))OH_col_valid = pd.DataFrame(oh_encoder.transform(x_test[low_cardinality_cols]))OH_col_train.index = x.indexOH_col_valid.index = x_test.indexnum_x_train = x.drop(low_cardinality_cols, axis=<span class="hljs-number">1</span>)num_x_valid = x_test.drop(low_cardinality_cols, axis=<span class="hljs-number">1</span>)num_x_train = num_x_train.drop(high_cardinality_cols, axis=<span class="hljs-number">1</span>)num_x_valid = num_x_valid.drop(high_cardinality_cols, axis=<span class="hljs-number">1</span>)OH_x_train = pd.concat([num_x_train, OH_col_train], axis=<span class="hljs-number">1</span>)OH_x_valid = pd.concat([num_x_valid, OH_col_valid], axis=<span class="hljs-number">1</span>)</code></pre></div><h1 id="管道搭建模型"><a href="#管道搭建模型" class="headerlink" title="管道搭建模型"></a>管道搭建模型</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># "Cardinality" means the number of unique values in a column</span><span class="hljs-comment"># Select categorical columns with relatively low cardinality (convenient but arbitrary)</span>categorical_cols = [cname <span class="hljs-keyword">for</span> cname <span class="hljs-keyword">in</span> X_train_full.columns <span class="hljs-keyword">if</span>                    X_train_full[cname].nunique() &lt; <span class="hljs-number">10</span> <span class="hljs-keyword">and</span>                     X_train_full[cname].dtype == <span class="hljs-string">"object"</span>]<span class="hljs-comment"># Select numerical columns</span>numerical_cols = [cname <span class="hljs-keyword">for</span> cname <span class="hljs-keyword">in</span> X_train_full.columns <span class="hljs-keyword">if</span>                 X_train_full[cname].dtype <span class="hljs-keyword">in</span> [<span class="hljs-string">'int64'</span>, <span class="hljs-string">'float64'</span>]]<span class="hljs-comment"># Keep selected columns only</span>my_cols = categorical_cols + numerical_colsX_train = X_train_full[my_cols].copy()X_valid = X_valid_full[my_cols].copy()X_test = X_test_full[my_cols].copy()</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.compose <span class="hljs-keyword">import</span> ColumnTransformer<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline<span class="hljs-keyword">from</span> sklearn.impute <span class="hljs-keyword">import</span> SimpleImputer<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> OneHotEncoder<span class="hljs-comment"># Preprocessing for numerical data</span>numerical_transformer = SimpleImputer(strategy=<span class="hljs-string">'constant'</span>)<span class="hljs-comment"># Preprocessing for categorical data</span>categorical_transformer = Pipeline(steps=[    (<span class="hljs-string">'imputer'</span>, SimpleImputer(strategy=<span class="hljs-string">'most_frequent'</span>)),    (<span class="hljs-string">'onehot'</span>, OneHotEncoder(handle_unknown=<span class="hljs-string">'ignore'</span>))])<span class="hljs-comment"># Bundle preprocessing for numerical and categorical data</span>preprocessor = ColumnTransformer(    transformers=[        (<span class="hljs-string">'num'</span>, numerical_transformer, numerical_cols),        (<span class="hljs-string">'cat'</span>, categorical_transformer, categorical_cols)    ])</code></pre></div><h1 id="使用XGBoost训练"><a href="#使用XGBoost训练" class="headerlink" title="使用XGBoost训练"></a>使用XGBoost训练</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Define the model</span>my_model_2 = XGBRegressor(n_estimators=<span class="hljs-number">1000</span>, learning_rate=<span class="hljs-number">0.05</span>, n_jobs=<span class="hljs-number">4</span>)<span class="hljs-comment"># Fit the model</span>my_model_2.fit(X_train,                y_train,                early_stopping_rounds=<span class="hljs-number">5</span>,                eval_set=[(X_valid, y_valid)],               verbose=<span class="hljs-literal">False</span>) <span class="hljs-comment"># Your code here</span><span class="hljs-comment"># Get predictions</span>predictions_2 = my_model_2.predict(X_valid)<span class="hljs-comment"># Calculate MAE</span>mae_2 = mean_absolute_error(predictions_2, y_valid)<span class="hljs-comment"># print MAE</span>print(<span class="hljs-string">"Mean Absolute Error:"</span> , mae_2)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kaggle</tag>
      
      <tag>scikit-learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习项目（一）：泰坦尼克号的幸存者</title>
    <link href="/2020/10/17/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/"/>
    <url>/2020/10/17/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/</url>
    
    <content type="html"><![CDATA[<div style="color:white"></div><p style="text-indent: 2em;"></p><p class="note note-primary">    这里我们以泰坦尼克号幸存者数据集进行第一个机器学习项目</p><p>数据集的下载地址为：</p><p><a href="titanic_train.csv">titanic_train.csv</a></p><p>导包，导入数据集并分割数据集</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_splittitanic = pandas.read_csv(<span class="hljs-string">'./titanic_train.csv'</span>)</code></pre></div><p>输出输出的前几行，查看各列属性等</p><div class="hljs"><pre><code class="hljs python">titanic.head()</code></pre></div><img src="/2020/10/17/%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE%EF%BC%9A%E6%B3%B0%E5%9D%A6%E5%B0%BC%E5%85%8B%E5%8F%B7%E7%9A%84%E5%B9%B8%E5%AD%98%E8%80%85/head.JPG" srcset="/img/loading.gif" alt="数据前5行" style="zoom:100%;display: flex;margin: 0 auto;"><br><br><p>下面简单介绍一下各列属性的含义，详细信息请见链接：<a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a></p><table><tbody><tr><th><b>Variable</b></th><th><b>Definition</b></th><th><b>Key</b></th></tr><tr><td>survival</td><td>Survival</td><td>0 = No, 1 = Yes</td></tr><tr><td>pclass</td><td>Ticket class</td><td>1 = 1st, 2 = 2nd, 3 = 3rd</td></tr><tr><td>sex</td><td>Sex</td><td></td></tr><tr><td>Age</td><td>Age in years</td><td></td></tr><tr><td>sibsp</td><td># of siblings / spouses aboard the Titanic</td><td></td></tr><tr><td>parch</td><td># of parents / children aboard the Titanic</td><td></td></tr><tr><td>ticket</td><td>Ticket number</td><td></td></tr><tr><td>fare</td><td>Passenger fare</td><td></td></tr><tr><td>cabin</td><td>Cabin number</td><td></td></tr><tr><td>embarked</td><td>Port of Embarkation</td><td>C = Cherbourg, Q = Queenstown, S = Southampton</td></tr></tbody></table><p>下一步分离数据特征和预测目标</p><div class="hljs"><pre><code class="hljs python">y = titanic[<span class="hljs-string">'Survived'</span>]x = titanic.drop([<span class="hljs-string">'Survived'</span>], axis=<span class="hljs-number">1</span>)print(x.shape)print(y.shape)</code></pre></div><div class="hljs"><pre><code class="hljs python">(<span class="hljs-number">891</span>, <span class="hljs-number">11</span>)(<span class="hljs-number">891</span>,)</code></pre></div><p>统计缺失数据，数据类型等情况。</p><div class="hljs"><pre><code class="hljs python">print(x.info())</code></pre></div><div class="hljs"><pre><code class="hljs python">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">pandas</span>.<span class="hljs-title">core</span>.<span class="hljs-title">frame</span>.<span class="hljs-title">DataFrame</span>'&gt;</span><span class="hljs-class"><span class="hljs-title">RangeIndex</span>:</span> <span class="hljs-number">891</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">890</span>Data columns (total <span class="hljs-number">11</span> columns): <span class="hljs-comment">#   Column       Non-Null Count  Dtype  </span>---  ------       --------------  -----   <span class="hljs-number">0</span>   PassengerId  <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">1</span>   Pclass       <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">2</span>   Name         <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">3</span>   Sex          <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">4</span>   Age          <span class="hljs-number">714</span> non-null    float64 <span class="hljs-number">5</span>   SibSp        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">6</span>   Parch        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">7</span>   Ticket       <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">8</span>   Fare         <span class="hljs-number">891</span> non-null    float64 <span class="hljs-number">9</span>   Cabin        <span class="hljs-number">204</span> non-null    object  <span class="hljs-number">10</span>  Embarked     <span class="hljs-number">889</span> non-null    object dtypes: float64(<span class="hljs-number">2</span>), int64(<span class="hljs-number">4</span>), object(<span class="hljs-number">5</span>)memory usage: <span class="hljs-number">76.7</span>+ KB<span class="hljs-literal">None</span></code></pre></div><p>从上面的输出信息可以看到：</p><ol><li>数据中一共有11个属性列，891个训练样本。</li><li>这些数据类型中有2个属性的数据类型为<code>float</code>，4个属性的数据类型为<code>int</code>，5个属性的数据类型为字符串类型，即为分类变量。</li><li>这些属性列中，<code>Age</code>属性，<code>Cabin</code>属性和<code>Embarked</code>属性列有空值，需要进一步处理。</li></ol><p>下面对空值进行处理，数据类型和文本类型的处理手段不同。<br><code>Age</code>属性使用已有的年龄属性的平均值进行填充。<br>字符串类型的空值统一标记为<code>Unknown</code>。</p><div class="hljs"><pre><code class="hljs python">x[<span class="hljs-string">'Age'</span>].fillna(x[<span class="hljs-string">'Age'</span>].mean(), inplace=<span class="hljs-literal">True</span>)x.fillna(<span class="hljs-string">'Unknown'</span>, inplace=<span class="hljs-literal">True</span>)print(x.info())</code></pre></div><div class="hljs"><pre><code class="hljs python">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">pandas</span>.<span class="hljs-title">core</span>.<span class="hljs-title">frame</span>.<span class="hljs-title">DataFrame</span>'&gt;</span><span class="hljs-class"><span class="hljs-title">RangeIndex</span>:</span> <span class="hljs-number">891</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">890</span>Data columns (total <span class="hljs-number">11</span> columns): <span class="hljs-comment">#   Column       Non-Null Count  Dtype  </span>---  ------       --------------  -----   <span class="hljs-number">0</span>   PassengerId  <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">1</span>   Pclass       <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">2</span>   Name         <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">3</span>   Sex          <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">4</span>   Age          <span class="hljs-number">891</span> non-null    float64 <span class="hljs-number">5</span>   SibSp        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">6</span>   Parch        <span class="hljs-number">891</span> non-null    int64   <span class="hljs-number">7</span>   Ticket       <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">8</span>   Fare         <span class="hljs-number">891</span> non-null    float64 <span class="hljs-number">9</span>   Cabin        <span class="hljs-number">891</span> non-null    object  <span class="hljs-number">10</span>  Embarked     <span class="hljs-number">891</span> non-null    object dtypes: float64(<span class="hljs-number">2</span>), int64(<span class="hljs-number">4</span>), object(<span class="hljs-number">5</span>)memory usage: <span class="hljs-number">76.7</span>+ KB<span class="hljs-literal">None</span></code></pre></div><p>可以看到数据被补全了，可以进行下一步操作。</p><p>下一步分割数据集，<code>25%</code>的数据用于测试集，<code>75%</code>的数据用于训练集。</p><div class="hljs"><pre><code class="hljs python">X_train, X_test, y_train, y_test = train_test_split(x, y, train_size=<span class="hljs-number">.75</span>, random_state=<span class="hljs-number">33</span>)</code></pre></div><p>下一步要处理的是分类变量，即建立分类变量的编码问题，这里选择使用<code>DictVectorizer</code>。</p><p><code>DictVectorizer</code>的处理对象是符号化(非数字化)的但是具有一定结构的特征数据，如字典等，将符号转成数字<code>0/1</code>表示。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.feature_extraction <span class="hljs-keyword">import</span> DictVectorizervec = DictVectorizer()X_train = vec.fit_transform(X_train.to_dict(orient=<span class="hljs-string">'record'</span>))X_test = vec.transform(X_test.to_dict(orient=<span class="hljs-string">'record'</span>))print(len(vec.feature_names_))</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">1352</span></code></pre></div><p>输出建立分类变量的数据</p><div class="hljs"><pre><code class="hljs python">print(X_train.toarray()[:<span class="hljs-number">10</span>, :<span class="hljs-number">5</span>])</code></pre></div><div class="hljs"><pre><code class="hljs python">[[<span class="hljs-number">47.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">40.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">29.69911765</span>  <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">22.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">23.5</span>         <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">47.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">27.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">24.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">29.69911765</span>  <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ] [<span class="hljs-number">29.69911765</span>  <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>          <span class="hljs-number">0.</span>        ]]</code></pre></div><p>我们不难发现，<code>DictVectorizer</code>对非数字化的处理方式是，借助原特征的名称，组合成新的特征，并采用<code>0/1</code>的方式进行量化，而数值型的特征转化比较方便，一般情况维持原值即可。</p><p>对数据处理完毕后，开始对模型进行训练。这里我们使用随机森林模型对所有特征进行预测，并作性能评估。这里使用循环的方法找到最佳的参数<code>max_depth</code>。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifiermaxid, maxval = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">45</span>):    forest = RandomForestClassifier(max_depth=i, random_state=<span class="hljs-number">33</span>)    forest.fit(X_train, y_train)    score = forest.score(X_test, y_test)    <span class="hljs-keyword">if</span> maxval &lt; score:        maxval = score        maxid = iprint(maxid, maxval)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">28</span> <span class="hljs-number">0.874439461883408</span></code></pre></div><p>这里，我们选择<code>max_depth=10</code>为树的最大深度。开始训练模型：</p><div class="hljs"><pre><code class="hljs python">best_forest = RandomForestClassifier(max_depth=<span class="hljs-number">10</span>, random_state=<span class="hljs-number">33</span>)best_forest.fit(X_train, y_train)score = best_forest.score(X_test, y_test)print(score)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">0.8026905829596412</span></code></pre></div><p>总体来讲，良好的数据特征组合不需太多便可以使得模型的性能表现突出。比如，我们“良/恶性乳腺癌肿瘤预测”问题中，仅仅使用两个描述肿瘤形态的特征便可以取得很高的识别率。冗余的特征虽然不会影响到模型的性能，不过却使得CPU的计算做了无用功。比如，主成分分析主要用于去除多余的那些线性相关的特征组合，原因在于这些冗余的特征组合并不会对模型训练有更多贡献。而不良的特征自然会降低模型的精度。</p><p>特征筛选与<code>PCA</code>这类通过选择主成分对特征进行重建的方法略有区别:对于<code>PCA</code>而言，我们经常无法解释重建之后的特征；但是特征筛选不存在对特征值的修改，而更加侧重于寻找那些对模型的性能提升较大的少量特征。</p><p>这里我们在代码中继续沿用 Titanic据集，这次试图通过特征筛选来寻找最佳的特征组合，并且达到提高预测准确性的目标。</p><p>从<code>sklearn</code>中导入特征筛选器</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> feature_selectionfs = feature_selection.SelectPercentile(feature_selection.chi2, percentile=<span class="hljs-number">20</span>)</code></pre></div><div class="hljs"><pre><code class="hljs python">X_train_fs = fs.fit_transform(X_train, y_train)best_forest.fit(X_train_fs, y_train)fs_score = best_forest.score(fs.transform(X_test), y_test)print(fs_score)</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">0.8295964125560538</span></code></pre></div><p>可以看到结果，在选择了前<code>20%</code>的属性进行模型的训练得到了一个比全属性进行训练更好的结果。准确率达到了<code>82.96%</code>。</p><p>这样，我们就完成了一个简单的模型，虽然没有对模型做过多的优化，后续的优化环节，在后续的博客中进行介绍。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kaggle</tag>
      
      <tag>scikit-learn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更好，更快，更强壮的YOLOv2</title>
    <link href="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/"/>
    <url>/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/</url>
    
    <content type="html"><![CDATA[<style>    .center{        width: auto;        display: table;        margin-left: auto;        margin-right: auto;    }    .mine{       text-indent: 2em;          margin: 10px 0px;    }    .markdown-body p > img, .markdown-body p > a > img {    box-shadow: none;}</style><p class="note note-warning">    YOLO9000(YOLO9000：Better, Faster, Stronger)是YOLO算法的改进版，YOLOv2相对v1版本，在继续保持处理速度的基础上，从预测更准确（Better），速度更快（Faster），识别对象更多（Stronger）这三个方面进行了改进。其中识别更多对象也就是扩展到能够检测9000种不同对象，所以称之为YOLO9000。</p><p>在保证目标召回率的同时，为了提高准确率和速度，<code>YOLOv2</code>并没有使用太深的网络这样也使得网络容易学习，主要做了以下几方面的改进：</p><ol><li><strong>Batch Normalization</strong>：在每个卷积层中加入批归一化，使<strong>mAP</strong>有了<code>2%</code>的提高。批归一化处理能够获得更好的收敛速度和收敛效果，减少过拟合的发生。</li><li><strong>High Resolution Classifier</strong>：采用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/224.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">图像进行分类模型预训练后，再采用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/448.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的高分辨率样本对分类模型进行<code>10</code>个<strong>epoch</strong>的微调，使网络特征逐渐适应<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/448.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的分辨率。然后再使用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/448.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的检测样本进行训练，缓解了分辨率突然切换造成的影响。</li><li><strong>Anchor Boxes</strong>：引入<strong>Anchor Boxes</strong>的思想后，使原来的每张图片预测<code>98</code>个<strong>Bounding-box</strong>增长到每张图片可以预测上千个<strong>Bounding-box</strong>。<strong>YOLOv2</strong>移除了全连接层、去掉了一个池化层，使网络卷积层输出具有更高的分辨率。同时减小输入图像的尺寸到<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/416.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">，这样在下采样因子为<code>32</code>的情况下，<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/13.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征图能正好有一个网格在正中心。相对<strong>YOLOv1</strong>的<code>81%</code>的召回率，<strong>YOLOv2</strong>的召回率大幅提升到<code>88%</code>。同时<strong>mAP</strong>有<code>0.2%</code>的轻微下降。</li><li><strong>Dimension Clusters</strong>：对训练集中标注的边框进行<code>k-means</code>聚类分析，设计出更符合样本中对象尺寸的先验框（Prior Boxes），这样就可以减少网络微调先验框到实际位置的难度。<strong>YOLOv2</strong>选择<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/k=5.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">作为边框数量与<code>IOU</code>的折中。如图1所示。</li></ol><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/iou.png" srcset="/img/loading.gif" alt="k-means聚类得到的IOU" style="zoom:50%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 1 k-means聚类得到的IOU</div><p>对比手工选择的<strong>Anchor Boxes</strong>，使用<code>5</code>个聚类得到的<strong>Prior Boxes</strong>即可达到<code>61.0</code>的<strong>Avg IOU</strong>，相当于<code>9</code>个手工设置的<strong>Anchor Boxes</strong> <code>60.9</code>的<strong>Avg IOU</strong>。如下图2所示：</p><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/avgiou.png" srcset="/img/loading.gif" alt="k取不同值时的Avg IOU" style="zoom:70%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 2 k取不同值时的Avg IOU</div><ol start="5"><li><p><strong>Direct Location Prediction</strong>：在使用<strong>Anchor Box</strong>时出现了预测边框的中心可能出现在任何位置的情况，导致训练早期阶段不容易稳定。因此<strong>YOLO</strong>调整了预测公式，将预测边框的中心约束在特定<code>gird</code>网格内。预测边框的蓝色中心点被约束在蓝色背景的网格内。如图3所示，约束边框位置使得模型更容易学习，且预测更为稳定。这种方式将<strong>mAP</strong>提高了<code>5%</code>。</p><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/priorbox.png" srcset="/img/loading.gif" alt="利用Prior Box对预测框定位" style="zoom:30%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图3 利用Prior Box对预测框定位</div></li><li><p><strong>Passthrough Layer</strong>： 输入<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/416.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">经过卷积网络下采样最后输出是<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/13.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">，较小的对象可能特征已经不明显甚至被忽略掉了。为了更好的检测出一些比较小的对象，<strong>YOLOv2</strong>引入一种称为<code>passthrough</code>层的方法在特征图中保留上一次池化之前的<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/26.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征。也就是说将<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/26512.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征图转化为<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/132048.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。然后直接传递到<code>pooling</code>后（并且又经过一组卷积）的特征图，两者叠加到一起作为输出<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/133072.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">的特征图，使得<strong>MAP</strong>提高了<code>1%</code>。</p></li><li><p><strong>Multi-Scale Training</strong>：为了能使<strong>YOLOv2</strong>在不同尺寸的图片上鲁棒性更强，这里加入了多尺度的图像训练。因为去掉了全连接层，<strong>YOLOv2</strong>可以输入任何尺寸的图像。因为整个网络下采样倍数是<code>32</code>，作者采用了<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/seq.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">等<strong>10</strong>种输入图像的尺寸，这些尺寸的输入图像对应输出的特征图宽和高是<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/feaseq.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。训练时每<code>10</code>个<strong>batch</strong>就随机更换一种尺寸，使网络能够适应各种大小的对象检测。</p></li></ol><div class="mine">   YOLOv2提出了Darknet-19（有19个卷积层和5个池化层）网络结构。Darknet-19比VGG-16小一些，精度不弱于VGG-16。YOLOv2的训练主要包括三个阶段：</div><ul><li><p>第一阶段就是先预训练<strong>Darknet-19</strong>，模型输入为<code>224×224</code>，共训练<code>160</code>个<strong>epochs</strong>。</p></li><li><p>第二阶段将网络的输入调整为<code>448×448</code>，继续<strong>finetune</strong>分类模型。</p></li><li><p>第三个阶段就是修改<strong>Darknet-19</strong>分类模型为检测模型，移除最后一个卷积层、<strong><em>global avg pooling</em></strong>层以及<strong><em>softmax</em></strong>层，并且新增了三个<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/21024.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">卷积层，同时增加了一个<strong>passthrough</strong>层，最后使用<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/1.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">卷积层输出预测结果，输出的<strong>channels</strong>数为：<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/channel.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。由于<strong>Anchors</strong>数为<code>5</code>，对于<strong>VOC</strong>数据集（20种分类对象）输出的<strong>channels</strong>数就是<code>125</code>，最终的输出的特征大小为:</p></li></ul><p>$$<br>(13, 13, 5,25)<br>$$</p><div class="mine">   YOLOv2和其他的算法在Pascal VOC 2007数据集上的比较结果如下表：</div><div class="center">    <table><thead><tr><th>Detection Frameworks</th><th>Train</th><th>mAP</th><th>FPS</th></tr></thead><tbody><tr><td>YOLO</td><td>2007+2012</td><td>63.4</td><td>45</td></tr><tr><td>Fast R-CNN</td><td>2007+2012</td><td>70.0</td><td>0.5</td></tr><tr><td>Faster R-CNN VGG-16</td><td>2007+2012</td><td>73.2</td><td>7</td></tr><tr><td>YOLOv2 288×288</td><td>2007+2012</td><td>69.0</td><td>91</td></tr><tr><td>YOLOv2 352×352</td><td>2007+2012</td><td>73.7</td><td>81</td></tr><tr><td>YOLOv2 416×416</td><td>2007+2012</td><td>76.8</td><td>67</td></tr><tr><td>YOLOv2 480×480</td><td>2007+2012</td><td>77.8</td><td>59</td></tr><tr><td>YOLOv2 544×544</td><td>2007+2012</td><td>78.6</td><td>40</td></tr></tbody></table></div><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    表1 YOLOv2与其他算法的性能比较</div><div class="mine">    为了能够使模型检测出更多的分类，作者又提出了一种对COCO数据集和ImageNet数据集上联合训练的方式可以检测出9000个类别的物体的YOLO9000，使得YOLOv2即使没有学过很多对象的检测样本，也能检测出这些对象。</div><div class="mine">    由于ImageNet的对象类别与COCO的对象类别不是互斥的。这样就不适合用单个softmax来做对象分类，而是要采用一种多标签分类模型。将ImageNet和COCO中的名词对象一起构建了一个WordTree，以physical object为根节点，各名词依据相互间的关系构建树枝、树叶，节点间的连接表达了对象概念之间的蕴含关系。</div><img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/wordtree.png" srcset="/img/loading.gif" alt="利用Prior Box对预测框定位" style="zoom:50%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图4 WordTree名词关系树</div><p>对于单个节点，属于它的所有子节点之间是互斥关系，所以计算上可以进行<strong><em>softmax</em></strong>操作。实际中每个节点下的所有子节点都会进行<strong><em>softmax</em></strong>.</p><p>有标签的样本对应的<strong>WordTree</strong>中，该对象节点到根节点的所有节点概率都是<code>1</code>，其它节点概率是<code>0</code>。根据训练标签的设置，其实模型学习的是各节点的条件概率。</p><br><p>$$<br>Pr⁡(Norfolk terrier)=Pr⁡(Norfolk terrier│terrier)×Pr⁡(terrier│hunting dog)<br>$$</p><p>$$<br>×…×Pr⁡(mammal│animal)×Pr(animal|physical object)<br>$$<br>为了计算简便，从根节点开始向下遍历，对每一个节点，在它的所有子节点中，选择概率最大的那个，一直向下遍历直到某个节点的子节点概率低于设定的阈值，或达到叶子节点，那么该节点就是该<strong><em>WordTree</em></strong>对应的对象。</p><p><strong>YOLO9000</strong>依然采用<strong>YOLOv2</strong>的网络结构，使用<code>3</code>个先验框，现在<strong>YOLO9000</strong>的输出是<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/hahah.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">。由于对象分类改成<strong>WordTree</strong>的形式，相应的误差计算也需要一些调整。对一个检测样本，其分类误差只包含该标签节点以及到根节点的所有节点的误差。对于分类样本，则只计算分类误差。<strong>YOLO9000</strong>总共输出<img src="/2020/10/14/%E6%9B%B4%E5%A5%BD%EF%BC%8C%E6%9B%B4%E5%BF%AB%EF%BC%8C%E6%9B%B4%E5%BC%BA%E5%A3%AE%E7%9A%84YOLOv2/preboc.png" srcset="/img/loading.gif" alt style="zoom:100%;display: inline;margin: 0 auto;">个预测框，计算它们对样本标签的预测概率，选择概率最大的那个框负责预测该样本的对象，即计算其<strong>WordTree</strong>的误差。</p><p>总的来说，<strong>YOLOv2</strong>通过一些改进明显提升了预测准确性，同时继续保持其运行速度快的优势。<strong>YOLO9000</strong>则开创性的提出联合使用分类样本和检测样本的训练方法，使对象检测能够扩展到缺乏检测样本的对象。</p>]]></content>
    
    
    <categories>
      
      <category>目标检测（Object Detection）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>YOLO</tag>
      
      <tag>One-Stage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开创性的YOLO</title>
    <link href="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/"/>
    <url>/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/</url>
    
    <content type="html"><![CDATA[<style>    .center{        width: auto;        display: table;        margin-left: auto;        margin-right: auto;    }    .mine{       text-indent: 2em;          margin: 10px 0px;    }</style><p class="note note-primary">    Faster R-CNN系列等两阶段（Two-Stage）的目标检测算法有较好的检测效果和较高的检测精度，但从速度上来讲满足不了实时检测的要求。基于回归方法的深度学习目标检测就显得尤为重要了。使用回归的思想，输入的图片经过网络直接计算出物体的分类，位置信息以达到目标检测的目的。</p><p><strong>YOLO（You only look once：Unified ,Real-Time Object Detection）</strong>是基于回归的方法中最经典的算法之一。YOLO采用单个神经网络全图直接训练预测物品边界和类别概率，模型的最后直接输出Bounding-box 的坐标、 Bounding-box 中包含物体的置信度和物体的类别。从而实现真正意义上的端到端的物品检测。识别性能有了很大提升，在 Titan X 的 GPU 上能达到<strong>45 FPS</strong>，而在Fast YOLO(卷积层更少)中，可以达到155 FPS。<br>YOLO预测阶段的流程如下，流程图如图1所示：</p><img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/yolov1img2.png" srcset="/img/loading.gif" alt="YOLO网络结构" style="zoom:50%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 1 YOLO网络结构，整个网络由24个卷积层和2个全连接层。网络先在224×224尺寸的ImageNet数据集上进行预训练分类任务，之后将图像尺寸翻倍进行检测任务。</div><p>1)  将图像缩放到<code>448×448</code>尺寸作为卷积神经网络的输入，并对图像划分成<code>S×S</code>的网格。</p><p>2)  经过CNN后到达FC层，最后一层的FC输出<code>4096</code>个神经元 </p><p>3)  FC层的输出作为检测层（Detection层）的输入，在1）中将原图分为<code>7×7</code>的网格，对于每个网格，我们都预测<code>B</code>个Bounding-box，包括每个Bounding-box的<code>4</code>个位置信息，网格包含目标的置信度。另外每个网格还预测<code>C</code>个类别上的概率。最终得到<br>$$<br>S×S×(B×5+C)<br>$$<br>大小的特征图，输出的特征图结构如下。</p><img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/yolooutputt.png" srcset="/img/loading.gif" alt="YOLO网络结构" style="zoom:30%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图 2 输出的特征向量</div><p>YOLO在PASCAL VOC数据集上进行评估，数据集中类别有<code>C=20</code>个。所以输出的特征向量大小为<br>$$<br>S×S×(B×5+C) = 7×7×(2×5+20)=(7,7,30)<br>$$</p><div class="mine">    最后根据阈值去除分类概率比较低的目标窗口，最后使用NMS算法去除冗余窗口，得到最后的目标窗口。</div><div class="mine">可以看到整个预测过程非常简单，不需要中间的**region proposal**找目标，直接回归便完成了位置和类别的判定。</div><p>YOLO网络模型的架构思想如图3所示，我们将初始大小为<code>448×448</code>大小的图像分为<code>7×7</code>的网格，每个网格的大小为<code>64×64</code>。如果一个物体的中心点落在这个网格内，那么这个网格负责预测这个物体。每个网格预测两个Bounding-box，每个Bounding-box对应预测除了四个位置参数外，还有一个参数叫<strong>置信度(confidence)</strong>的值，表达式为如下所示：<br>$$<br>confidence= P_r (Object)×IOU(truth|pred)<br>$$</p><div class="mine">其中，<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image002.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">表示这个网格是否包含目标物体，若包含目标物体则<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image003.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">，否则<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image004.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">。<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image005.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">表示ground truth和prediction的重叠率。还会预测出网格中存在目标物体的条件下属于那一类别物体的后验概率!<img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/clip_image006.png" srcset="/img/loading.gif" alt="YOLO" style="zoom:100%;display: inline;margin: 0 auto;">。</div><img src="/2020/10/10/%E5%BC%80%E5%88%9B%E6%80%A7%E7%9A%84YOLO/yolov1img1.png" srcset="/img/loading.gif" alt="YOLO网络结构" style="zoom:40%;display: flex;margin: 0 auto;"><div style="    color:grey;    text-align: center;    font-size: 0.8em;    margin: 20px 0 20px 0;">    图3 将图像分为S×S的网格，每个网格预测两个边界框和对应网格的类别概率，最后回归得到物体的边界框和分类</div><div class="mine">    在预测分类时，每个Bounding-box的得分其实是confidence和后验概率的乘积。得分公式如下所示：</div><p>$$<br>Score=confidence×P_r (Class_i |Object)=P_r (Class_i )×IOU(truth|pred)<br>$$</p><div class="mine">    得到这个得分后再通过NMS算法过滤掉小于阈值的边界框，得到最终的边界框。    </div><div class="mine">    YOLO网络的卷积层采取的是类似GoogLeNet的结构，采用1×1大小的卷积核减少计算量。在ImageNet数据集上的预训练中，采用的是前20层的卷积层后加一个全连接层的结构。在预训练完分类任务后，将网络结构转化为检测网络，在20层卷积后又添加了4个卷积层和两个全连接层来执行检测任务。因为检测的过程中需要图像中更加细粒度的信息，所以将原图像尺寸增加到448×448进行检测任务。根据图片的宽高将Bounding-box的宽高归一化到[0,1]之间，中心点坐标设置为网格左上角顶点的偏移量，使用多任务的损失函数直接回归边界框，物体类别，置信度等信息。</div><div class="mine">    YOLO和其他的算法在Pascal VOC 2007数据集上的比较结果如下表：</div><div class="center">    <table><thead><tr><th>Real-Time Detectors</th><th>Train</th><th>mAP</th><th>FPS</th></tr></thead><tbody><tr><td>Fast YOLO</td><td>2007+2012</td><td>52.7</td><td>155</td></tr><tr><td>YOLO</td><td>2007+2012</td><td>63.4</td><td>45</td></tr></tbody></table></div><div class="center"><table><thead><tr><th>Less Than Real-Time</th><th>Train</th><th>mAP</th><th>FPS</th></tr></thead><tbody><tr><td>Fast R-CNN</td><td>2007+2012</td><td>70.0</td><td>0.5</td></tr><tr><td>Faster R-CNN VGG-16</td><td>2007+2012</td><td>73.2</td><td>7</td></tr></tbody></table></div><div class="mine">    可以看到回归方法的目标检测的FPS是很高的，但精度还有待提高。同时YOLO算法还存在几点不足：</div><ol><li>YOLO的每一个网格只预测两个边界框，一种类别。这导致模型对相邻目标预测准确率下降。因此，YOLO对集群的目标或小的目标识别准确率较低。</li><li>损失函数会同样的对待小边界框与大边界框的误差，导致了目标区域定位的误差偏大和召回率较低。</li></ol>]]></content>
    
    
    <categories>
      
      <category>目标检测（Object Detection）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>YOLO</tag>
      
      <tag>One-Stage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MMDetection教程（二）训练数据集并分析</title>
    <link href="/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E5%88%86%E6%9E%90/"/>
    <url>/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B9%B6%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="MMDetection（二）训练数据集并分析"><a href="#MMDetection（二）训练数据集并分析" class="headerlink" title="MMDetection（二）训练数据集并分析"></a>MMDetection（二）训练数据集并分析</h1><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><h3 id="查找模型配置文件"><a href="#查找模型配置文件" class="headerlink" title="查找模型配置文件"></a>查找模型配置文件</h3><p>以<code>Faster RCNN</code>为例，讲解如何找到模型的配置文件和权重文件</p><ol><li><p>首先找到模型的配置文件<code>mmdetection/configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py</code>,这里以<code>ResNet50</code>作为backbone, 使用<code>FPN</code>为多层特征提取的网络配置文件.</p></li><li><p>打开配置文件得到以下信息:</p><div class="hljs"><pre><code class="hljs python">_base_ = [    <span class="hljs-string">'../_base_/models/faster_rcnn_r50_fpn.py'</span>,    <span class="hljs-string">'../_base_/datasets/coco_detection.py'</span>,    <span class="hljs-string">'../_base_/schedules/schedule_1x.py'</span>, <span class="hljs-string">'../_base_/default_runtime.py'</span>]</code></pre></div><p>这里可以看到四个文件:</p><ul><li><code>../_base_/models/faster_rcnn_r50_fpn.py</code>为模型的源码,配置文件.</li><li><code>../_base_/datasets/coco_detection.py</code>为训练模型使用的数据集的一些配置,比如数据集的预处理,缩放,数据集路径等信息.</li><li><code>../_base_/schedules/schedule_1x.py</code>为模型训练方式,其中包含优化器,学习率修改测率和训练的轮回数.</li><li><code>../_base_/default_runtime.py</code>为默认的训练运行时,其中包含保存断点权重的间隔数等.一般不需要修改.</li></ul></li><li><p>得到这些<code>configs</code>后,可以对这些文件进行修改了,也可以创建新的文件</p></li></ol><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ol><li><p>定义数据种类，需要修改的地方在<code>mmdetection/mmdet/datasets/coco.py</code>。把CLASSES的那个tuple改为自己数据集对应的种类tuple即可。例如：</p><div class="hljs"><pre><code class="hljs python">CLASSES = (<span class="hljs-string">'0B'</span>, <span class="hljs-string">'1B'</span>, <span class="hljs-string">'2B'</span>)</code></pre></div></li><li><p>接着在<code>mmdetection/mmdet/core/evaluation/class_names.py</code>修改coco_classes数据集类别，这个关系到后面test的时候结果图中显示的类别名称。例如：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coco_classes</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">'0B'</span>, <span class="hljs-string">'1B'</span>, <span class="hljs-string">'2B'</span>]</code></pre></div></li></ol><ol start="3"><li><p>修改<code>configs/_base_/datasets/coco_detection.py</code>中<code>train_pipeline</code>和<code>test_pipeline</code>中的<code>img_scale</code>:</p><div class="hljs"><pre><code class="hljs python">dataset_type = <span class="hljs-string">'CocoDataset'</span>data_root = <span class="hljs-string">'data/coco/'</span>img_norm_cfg = dict(    mean=[<span class="hljs-number">0.471</span>,<span class="hljs-number">0.448</span>,<span class="hljs-number">0.408</span>], std=[<span class="hljs-number">0.234</span>,<span class="hljs-number">0.239</span>,<span class="hljs-number">0.242</span>], to_rgb=<span class="hljs-literal">True</span>)train_pipeline = [    dict(type=<span class="hljs-string">'LoadImageFromFile'</span>),    dict(type=<span class="hljs-string">'LoadAnnotations'</span>, with_bbox=<span class="hljs-literal">True</span>),    dict(type=<span class="hljs-string">'Resize'</span>, img_scale=(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>), keep_ratio=<span class="hljs-literal">True</span>),    dict(type=<span class="hljs-string">'RandomFlip'</span>, flip_ratio=<span class="hljs-number">0.5</span>),    dict(type=<span class="hljs-string">'Normalize'</span>, **img_norm_cfg),    dict(type=<span class="hljs-string">'Pad'</span>, size_divisor=<span class="hljs-number">32</span>),    dict(type=<span class="hljs-string">'DefaultFormatBundle'</span>),    dict(type=<span class="hljs-string">'Collect'</span>, keys=[<span class="hljs-string">'img'</span>, <span class="hljs-string">'gt_bboxes'</span>, <span class="hljs-string">'gt_labels'</span>]),]test_pipeline = [    dict(type=<span class="hljs-string">'LoadImageFromFile'</span>),    dict(        type=<span class="hljs-string">'MultiScaleFlipAug'</span>,        <span class="hljs-comment"># 图像大小尺寸缩放</span>        img_scale=(<span class="hljs-number">400</span>, <span class="hljs-number">300</span>),        flip=<span class="hljs-literal">False</span>,        transforms=[            dict(type=<span class="hljs-string">'Resize'</span>, keep_ratio=<span class="hljs-literal">True</span>),            dict(type=<span class="hljs-string">'RandomFlip'</span>),            dict(type=<span class="hljs-string">'Normalize'</span>, **img_norm_cfg),            dict(type=<span class="hljs-string">'Pad'</span>, size_divisor=<span class="hljs-number">32</span>),            dict(type=<span class="hljs-string">'ImageToTensor'</span>, keys=[<span class="hljs-string">'img'</span>]),            dict(type=<span class="hljs-string">'Collect'</span>, keys=[<span class="hljs-string">'img'</span>]),        ])]data = dict(    samples_per_gpu=<span class="hljs-number">2</span>,    workers_per_gpu=<span class="hljs-number">2</span>,    train=dict(        type=dataset_type,        <span class="hljs-comment"># 标记文件路径 和 数据集路径</span>        ann_file=data_root + <span class="hljs-string">'annotations/instances_train2017.json'</span>,        img_prefix=data_root + <span class="hljs-string">'train2017/'</span>,        pipeline=train_pipeline),    val=dict(        type=dataset_type,        ann_file=data_root + <span class="hljs-string">'annotations/instances_val2017.json'</span>,        img_prefix=data_root + <span class="hljs-string">'val2017/'</span>,        pipeline=test_pipeline),    test=dict(        type=dataset_type,        ann_file=data_root + <span class="hljs-string">'annotations/instances_test2017.json'</span>,        img_prefix=data_root + <span class="hljs-string">'test2017/'</span>,        pipeline=test_pipeline))evaluation = dict(interval=<span class="hljs-number">1</span>, metric=<span class="hljs-string">'bbox'</span>)</code></pre></div></li></ol><ol start="4"><li><p>修改<code>models/faster_rcnn_r50_fpn.py</code>中的<code>num_classes</code>:</p><div class="hljs"><pre><code class="hljs python">model = dict(    type=<span class="hljs-string">'FasterRCNN'</span>,    pretrained=<span class="hljs-string">'torchvision://resnet50'</span>,    backbone=dict(        type=<span class="hljs-string">'ResNet'</span>,        depth=<span class="hljs-number">50</span>,        num_stages=<span class="hljs-number">4</span>,        out_indices=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>),        frozen_stages=<span class="hljs-number">1</span>,        norm_cfg=dict(type=<span class="hljs-string">'BN'</span>, requires_grad=<span class="hljs-literal">True</span>),        norm_eval=<span class="hljs-literal">True</span>,        style=<span class="hljs-string">'pytorch'</span>),    neck=dict(        type=<span class="hljs-string">'FPN'</span>,        in_channels=[<span class="hljs-number">256</span>, <span class="hljs-number">512</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">2048</span>],        out_channels=<span class="hljs-number">256</span>,        num_outs=<span class="hljs-number">5</span>),    rpn_head=dict(        type=<span class="hljs-string">'RPNHead'</span>,        in_channels=<span class="hljs-number">256</span>,        feat_channels=<span class="hljs-number">256</span>,        anchor_generator=dict(            type=<span class="hljs-string">'AnchorGenerator'</span>,            scales=[<span class="hljs-number">8</span>],            ratios=[<span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>],            strides=[<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>]),        bbox_coder=dict(            type=<span class="hljs-string">'DeltaXYWHBBoxCoder'</span>,            target_means=[<span class="hljs-number">.0</span>, <span class="hljs-number">.0</span>, <span class="hljs-number">.0</span>, <span class="hljs-number">.0</span>],            target_stds=[<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>]),        loss_cls=dict(            type=<span class="hljs-string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="hljs-literal">True</span>, loss_weight=<span class="hljs-number">1.0</span>),        loss_bbox=dict(type=<span class="hljs-string">'L1Loss'</span>, loss_weight=<span class="hljs-number">1.0</span>)),    roi_head=dict(        type=<span class="hljs-string">'StandardRoIHead'</span>,        bbox_roi_extractor=dict(            type=<span class="hljs-string">'SingleRoIExtractor'</span>,            roi_layer=dict(type=<span class="hljs-string">'RoIAlign'</span>, output_size=<span class="hljs-number">7</span>, sampling_ratio=<span class="hljs-number">0</span>),            out_channels=<span class="hljs-number">256</span>,            featmap_strides=[<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>]),        bbox_head=dict(            type=<span class="hljs-string">'Shared2FCBBoxHead'</span>,            in_channels=<span class="hljs-number">256</span>,            fc_out_channels=<span class="hljs-number">1024</span>,            roi_feat_size=<span class="hljs-number">7</span>,            <span class="hljs-comment">#类别数</span>            num_classes=<span class="hljs-number">3</span>,            bbox_coder=dict(                type=<span class="hljs-string">'DeltaXYWHBBoxCoder'</span>,                target_means=[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],                target_stds=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.2</span>]),            reg_class_agnostic=<span class="hljs-literal">False</span>,            loss_cls=dict(                type=<span class="hljs-string">'CrossEntropyLoss'</span>, use_sigmoid=<span class="hljs-literal">False</span>, loss_weight=<span class="hljs-number">1.0</span>),            loss_bbox=dict(type=<span class="hljs-string">'L1Loss'</span>, loss_weight=<span class="hljs-number">1.0</span>))))<span class="hljs-comment"># model training and testing settings</span>.........</code></pre></div></li></ol><ol start="5"><li><p>修改<code>_base_/schedules/schedule_1x.py</code>中的配置:</p><div class="hljs"><pre><code class="hljs python">optimizer = dict(type=<span class="hljs-string">'SGD'</span>, lr=<span class="hljs-number">0.0025</span>, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">0.0001</span>) <span class="hljs-comment">#当gpu数量为8时,lr=0.02；当gpu数量为8时,lr=0.01；我只要一个gpu，所以设置lr=0.0025</span></code></pre></div><p>还可以修改训练的周期数.</p></li></ol><ol start="6"><li>在<code>mmdetection</code>的目录下新建<code>work_dirs</code>文件夹</li></ol><h3 id="使用单GPU训练"><a href="#使用单GPU训练" class="headerlink" title="使用单GPU训练"></a>使用单GPU训练</h3><div class="hljs"><pre><code class="hljs shell">python tools/train.py $&#123;CONFIG_FILE&#125; [optional arguments]</code></pre></div><p>如果您想在命令中指定工作目录（保存训练过程日志等信息）, 你可以添加参数 <code>--work-dir ${YOUR_WORK_DIR}</code>.</p><h3 id="使用多GPU训练"><a href="#使用多GPU训练" class="headerlink" title="使用多GPU训练"></a>使用多GPU训练</h3><div class="hljs"><pre><code class="hljs shell">./tools/dist_train.sh $&#123;CONFIG_FILE&#125; $&#123;GPU_NUM&#125; [optional arguments]</code></pre></div><p>可选参数:</p><ul><li><code>--work-dir ${WORK_DIR}</code>: 指定工作目录（保存训练过程日志等信息）</li><li><code>--resume-from ${CHECKPOINT_FILE}</code>: 从之前的断点文件中继续训练</li></ul><p>例如：</p><div class="hljs"><pre><code class="hljs shell">python tools/train.py configs/cascade_rcnn/cascade_rcnn_r101_fpn_20e_coco.py --work-dir cascade_rcnn</code></pre></div><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试数据集"><a href="#测试数据集" class="headerlink" title="测试数据集"></a>测试数据集</h3><p>可以使用单GPU和多GPU对测试数据进行测试，使用如下命令：</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 单GPU测试</span>python tools/test.py $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--out $&#123;RESULT_FILE&#125;] [--eval $&#123;EVAL_METRICS&#125;] [--show] [--cfg-options]<span class="hljs-meta">#</span><span class="bash"> 多GPU测试</span>./tools/dist_test.sh $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; $&#123;GPU_NUM&#125; [--out $&#123;RESULT_FILE&#125;] [--eval $&#123;EVAL_METRICS&#125;] [--cfg-options]</code></pre></div><p>可选参数:</p><ul><li><p><code>RESULT_FILE</code>: 输出结果保存为pickle格式在指定目录下，如果不指定该参数，输出结果不保存。</p></li><li><p><code>EVAL_METRICS</code>: 评价结果的标准。根据数据集可选择的评价标准有： <code>proposal_fast</code>, <code>proposal</code>, <code>bbox</code>, <code>segm</code> 可用在COCO数据集上； <code>mAP</code>, <code>recall</code> 可用在PASCAL VOC数据集上。</p></li><li><p><code>--show</code>: 如果指定，检测结果将绘制在图像上并显示在一个新窗口中。仅适用于单GPU测试，用于调试和可视化。请确保GUI在你的环境中可用，否则您可能会遇到类似“无法连接到X服务器”的错误。</p></li><li><p><code>--show-dir</code>: 如果指定，检测结果将绘制在图像上并保存到指定的目录中。仅适用于单GPU测试，用于调试和可视化。使用此选项时，环境中可以不需要可用的GUI。</p></li><li><p><code>--show-score-thr</code>: 如果指定，则将删除分数低于此阈值的检测。</p></li></ul><p>测试Faster R-CNN模型，并将结果可视化展示在窗口中，按任意键切换下一张图片：</p><div class="hljs"><pre><code class="hljs shell">python tools/test.py configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py save/epoch_9.pth --show detection_results --eval bbox</code></pre></div><p>测试Faster R-CNN模型，不将结果可视化展示在窗口中，保存在文件中，为方便后续的可视化：</p><div class="hljs"><pre><code class="hljs shell">python tools/test.py configs/grid_rcnn/grid_rcnn_x101_64x4d_fpn_gn-head_2x_coco.py grid_rcnn/epoch_25.pth --show-dir detection_results --eval bbox</code></pre></div><h3 id="测试单张图片"><a href="#测试单张图片" class="headerlink" title="测试单张图片"></a>测试单张图片</h3><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py $&#123;IMAGE_FILE&#125; $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--device $&#123;GPU_ID&#125;] [--score-thr $&#123;SCORE_THR&#125;]</code></pre></div><p>例如使用Faster R-CNN模型测试<code>demo.jpg</code>图片，输入如下命令：</p><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py demo/demo.jpg configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \    checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth --device cpu</code></pre></div><h2 id="分析训练日志"><a href="#分析训练日志" class="headerlink" title="分析训练日志"></a>分析训练日志</h2><p>通过训练生成的log文件可以画出loss/mAP曲线。首先需要安装<code>pip install seaborn</code>依赖。</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py plot_curve [--keys $&#123;KEYS&#125;] [--title $&#123;TITLE&#125;] [--legend $&#123;LEGEND&#125;] [--backend $&#123;BACKEND&#125;] [--style $&#123;STYLE&#125;] [--out $&#123;OUT_FILE&#125;]</code></pre></div><p>绘制分类损失：</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py plot_curve faster_rcnn_1x_res50/20200928_120614.log.json --keys loss_cls loss_bbox --legend loss_cls loss_bbox</code></pre></div><p>绘制分类损失和边界框损失：</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py plot_curve log.json --keys loss_cls loss_bbox</code></pre></div><p>计算平均训练时间：</p><div class="hljs"><pre><code class="hljs shell">python tools/analyze_logs.py cal_train_time log.json</code></pre></div><p>输出的格式如下：</p><div class="hljs"><pre><code class="hljs python">-----Analyze train time of save/<span class="hljs-number">20200927</span>_095440.log.json-----slowest epoch <span class="hljs-number">6</span>, average time <span class="hljs-keyword">is</span> <span class="hljs-number">0.1322</span>fastest epoch <span class="hljs-number">7</span>, average time <span class="hljs-keyword">is</span> <span class="hljs-number">0.1202</span>time std over epochs <span class="hljs-keyword">is</span> <span class="hljs-number">0.0033</span>average iter time: <span class="hljs-number">0.1271</span> s/iter</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>目标检测（Object Detection）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MMDetection教程（一）数据测试</title>
    <link href="/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/09/30/MMDetection%E6%95%99%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B0%E6%8D%AE%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MMDetection教程（一）数据测试"><a href="#MMDetection教程（一）数据测试" class="headerlink" title="MMDetection教程（一）数据测试"></a>MMDetection教程（一）数据测试</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试单张图片"><a href="#测试单张图片" class="headerlink" title="测试单张图片"></a>测试单张图片</h3><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py $&#123;IMAGE_FILE&#125; $&#123;CONFIG_FILE&#125; $&#123;CHECKPOINT_FILE&#125; [--device $&#123;GPU_ID&#125;] [--score-thr $&#123;SCORE_THR&#125;]</code></pre></div><p>例如使用Faster R-CNN模型测试<code>demo.jpg</code>图片，输入如下命令：</p><div class="hljs"><pre><code class="hljs shell">python demo/image_demo.py demo/demo.jpg configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py \    checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth --device cpu</code></pre></div><h3 id="高阶API整合"><a href="#高阶API整合" class="headerlink" title="高阶API整合"></a>高阶API整合</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmdet.apis <span class="hljs-keyword">import</span> inference_detector, init_detector<span class="hljs-comment"># 训练配置文件</span>config = <span class="hljs-string">'configs/faster_rcnn/faster_rcnn_r50_fpn_1x_coco.py'</span><span class="hljs-comment"># 网络权重路径</span>checkpoint = <span class="hljs-string">'checkpoints/faster_rcnn_r50_fpn_1x_coco_20200130-047c8118.pth'</span><span class="hljs-comment"># 创建模型</span>model = init_detector(config, checkpoint, device=<span class="hljs-string">'cuda:0'</span>)<span class="hljs-comment"># 示例图片</span>img = <span class="hljs-string">'demo/demo.jpg'</span><span class="hljs-comment"># inference</span>result = inference_detector(model, img)<span class="hljs-comment"># 在新窗口中展示检测结果</span>model.show_result(img, result)<span class="hljs-comment"># 将检测结果保存在文件中</span>model.show_result(img, result, out_file=<span class="hljs-string">'result.jpg'</span>)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>目标检测（Object Detection）</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一文学会回溯算法解题技巧</title>
    <link href="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>以下文章来源于码海 ，作者码海</p><blockquote><p>来源：码海</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650565386&idx=1&sn=e49c4418d462f742d3063de76959be85&chksm=f1fedd89c689549f1ef6b430132573546b80e3d278bc6c4cd1524ea51db2b5d564b8373e69e7&scene=21#wechat_redirect" target="_blank" rel="noopener">上文</a>我们学习了深度优先搜索和广度优先搜索，相信大家对这两者的算法有了比较清楚的认识，值得一提的，深度优先算法用到了回溯的算法思想，这个算法虽然相对比较简单，但很重要，在生产上广泛用在正则表达式，编译原理的语法分析等地方，很多经典的面试题也可以用回溯算法来解决，如八皇后问题，排列组合问题，0-1背包问题，数独问题等，也是一种非常重要的算法。</p><p>本文将会从以下几个方面来讲述回溯算法，相信大家看了肯定有收获！</p><ol><li>什么是回溯算法</li><li>回溯算法解题通用套路</li><li>经典习题讲解</li></ol><h2 id="什么是回溯算法"><a href="#什么是回溯算法" class="headerlink" title="什么是回溯算法"></a><strong>什么是回溯算法</strong></h2><p>回溯算法本质其实就是枚举，在给定的枚举集合中，不断从其中尝试搜索找到问题的解，如果在搜索过程中发现不满足求解条件 ，则「回溯」返回，尝试其它路径继续搜索解决，这种走不通就回退再尝试其它路径的方法就是回溯法，许多复杂的，规模较大的问题都可以使用回溯法，所以回溯法有「通用解题方法」的美称。</p><h2 id="回溯算法解题通用套路"><a href="#回溯算法解题通用套路" class="headerlink" title="回溯算法解题通用套路"></a><strong>回溯算法解题通用套路</strong></h2><p>为了有规律地求解问题，我们把问题分成多个阶段，每个阶段都有多个解，随机选择一个解，进入下一个阶段，下一个阶段也随机选择一个解，再进入下一个阶段…</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/0.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>每个阶段选中的解都放入一个 「已选解集合」 中，并且要判断 「已选解集合」是否满足问题的条件（base case）,有两种情况</p><ol><li>如果「已选解集合」满足问题的条件，则将 「已选解集合」放入「结果集」中，并且「回溯」换个解再遍历。</li><li>如果不满足，则「回溯」换个解再遍历</li></ol><p>根据以上描述不难得出回溯算法的通用解决套路伪代码如下:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">backtrace</span><span class="hljs-params">(已选解集合,每个阶段可选解)</span> </span>&#123;    <span class="hljs-keyword">if</span> (已选解集合满足条件) &#123;        结果集.add(已选解集合);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 遍历每个阶段的可选解集合</span>    <span class="hljs-keyword">for</span> (可选解 in 每个阶段的可选解) &#123;        <span class="hljs-comment">// 选择此阶段其中一个解,将其加入到已选解集合中</span>        已选解集合.add(可选解)        <span class="hljs-comment">// 进入下一个阶段</span>        backtrace(已选解集合,下个阶段可选的空间解)        <span class="hljs-comment">// 「回溯」换个解再遍历</span>        已选解集合.remove(可选解)    &#125;&#125;</code></pre></div><p>通过以上分析我们不难发现回溯算法本质上就是深度优先遍历，它一般解决的是树形问题（问题分解成多个阶段，每个阶段有多个解，这样就构成了一颗树），所以判断问题是否可以用回溯算法的关键在于它是否可以转成一个树形问题。</p><p>另外我们也发现如果能缩小每个阶段的可选解，就能让问题的搜索规模都缩小，这种就叫「剪枝」，通过剪枝能有效地降低整个问题的搜索复杂度！之前我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650564819&idx=1&sn=d9bb77b1f6da35198cea065eec697143&chksm=f1fede50c6895746de12e536961e49ec8bdd294254b7a1459296c66bf254be6d32fb7ee6a218&scene=21#wechat_redirect" target="_blank" rel="noopener">一文学会递归解题</a>中求解斐波那契问题时就用到了减枝的技巧，使问题的空间大大减少（如下图示）</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/1.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>综上，我们可以得出回溯算法的基本套路如下：</p><ol><li>将问题分成多个阶段，每个阶段都有多个不同的解，这样就将问题转化成了树形问题，这一步是问题的关键！如果能将问题转成树形问题，其实就成功了一半，需要注意的是树形问题要明确终止条件，这样可以在 DFS 的过程中及时终止遍历，达到剪枝的效果</li><li>套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解。</li></ol><p>只要两个步骤，是不是很简单！接下来我们套用以上的解题模板来看看怎么使用以上回溯算法解题套路来解几道经典的问题。</p><h2 id="经典习题讲解"><a href="#经典习题讲解" class="headerlink" title="经典习题讲解"></a><strong>经典习题讲解</strong></h2><p><strong>一、全排列</strong></p><blockquote><p>给定数字 1，2，3，求出 3 位不重复数字的全排列</p></blockquote><p><strong>1、将问题转为树形结构</strong></p><p>由于求的是 3 位数的全排列，所以问题分解为 3 个阶段，第一个阶段可以选 1，2，3 三个解，如果第一阶段选完数字后，第二个阶段可以选另外 2 个解，同理第三个阶段也可以选择剩下一个解。树形结构如下：</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/2.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>2、套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解</p><p>代码如下:</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结果集</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; RESULT = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">10</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 参与全排列的数字</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; NUMS = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 遍历当前阶段的解</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedNums   已选解集合</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectableNums 可选的解集合</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">permutation</span><span class="hljs-params">(List&lt;Integer&gt; selectedNums, List&lt;Integer&gt; selectableNums &#123;</span></span><span class="hljs-function"><span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">        // 满足条件，加入结果集</span></span><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">if</span> (selectedNums.size()</span> </span>== NUMS.size()) &#123;            RESULT.add(Arrays.toString(selectedNums.toArray()));            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">// 遍历每个阶段的可选解集合</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectableNums.size(); i++) &#123;            Integer num = selectableNums.get(i);            <span class="hljs-comment">// 去除不符合条件的解，减枝</span>            <span class="hljs-keyword">if</span> (selectedNums.contains(num)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 选择当前阶段其中一个解</span>            selectedNums.add(num);            <span class="hljs-comment">// 选完之后再进入下个阶段遍历</span>            permutation(selectedNums, selectableNums);            <span class="hljs-comment">// 回溯,换一个解继续遍历</span>            selectedNums.remove(num);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; selectedNums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        permutation(selectedNums, NUMS);        System.out.println(Arrays.toString(RESULT.toArray()));    &#125;&#125;</code></pre></div><p>为了让大家更好地理解上述代码，我一步步地画出了每个阶段的解题图解，对照着以上代码看相信大家应该能看明白</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/3.JPG" srcset="/img/loading.gif" style="zoom:100%;display: flex;margin: 0 auto;"><p><strong>二、0-1背包问题</strong></p><p>这里介绍一下一种比较简单的背包问题：</p><blockquote><p>有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？假设这 n 个物品的质量分别  3kg, 4kg, 6kg, 8kg，背包总的承载重量是 10kg。</p></blockquote><p>套用回溯算法解题思路</p><p><strong>1、将问题转为树形结构</strong></p><p>由于有 n 个物品，所以问题可以分解成 n 个阶段，第一个阶段可以有 n 个物品可选，第二个阶段有 n-1 个物品可选,,,,,,最后一个阶段有 1 个物品可选，不难画出以下递归树</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/4.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p>既然能转成树形结构，那我们进入步骤 2</p><p><strong>2、套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解</strong></p><p>需要注意的，进行 DFS 的终止条件是什么呢，显然是所选物品质量（遍历的节点）和大于等于背包质量，稍加变形不难得出以下代码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 结果集</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer RESULT = <span class="hljs-number">0</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 背包最大承载质量</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer KNAPSACK_MAX_WEIGHT = <span class="hljs-number">10</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 现有背包</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; WEIGHTS = Arrays.asList(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 遍历当前阶段的解</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedWeights  已选解集合</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectableWeight 可选的解集合</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(List&lt;Integer&gt; selectedWeights, List&lt;Integer&gt; selectableWeight)</span> </span>&#123;        &#123;            <span class="hljs-comment">// 求已选物品的总重量</span>            <span class="hljs-keyword">int</span> sumOfWeights = selectedWeights.stream().mapToInt(Integer::intValue).sum();            <span class="hljs-keyword">if</span> (sumOfWeights == KNAPSACK_MAX_WEIGHT) &#123;                RESULT = Math.max(RESULT, sumOfWeights);                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sumOfWeights &gt; KNAPSACK_MAX_WEIGHT) &#123;                <span class="hljs-comment">// 如果已选物品的总重量超过背包最大承受质量，则要把最后一个选择的物品移除，再求质量和</span>                selectedWeights.remove(selectedWeights.size() - <span class="hljs-number">1</span>);                sumOfWeights = selectedWeights.stream().mapToInt(Integer::intValue).sum();                RESULT = Math.max(RESULT, sumOfWeights);                <span class="hljs-keyword">return</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                RESULT = Math.max(RESULT, sumOfWeights);            &#125;        &#125;        <span class="hljs-comment">// 遍历每个阶段的可选解集合</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectableWeight.size(); i++) &#123;            Integer num = selectableWeight.get(i);            <span class="hljs-comment">// 去除不符合条件的解，减枝</span>            <span class="hljs-keyword">if</span> (selectedWeights.contains(num)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 选择子节点的其中一个解</span>            selectedWeights.add(num);            <span class="hljs-comment">// 选完之后再进行 dfs</span>            knapsack(selectedWeights, selectableWeight);            <span class="hljs-comment">// 「回溯」换个解再遍历</span>            selectedWeights.remove(num);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;Integer&gt; selectedNums = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        knapsack(selectedNums, WEIGHTS);        System.out.println(<span class="hljs-string">"result = "</span> + RESULT);    &#125;&#125;</code></pre></div><p>可以看到套用模板我们又轻松解决了0-1背包问题，可能有人会说以上问题比较简单，接下来我们来看看如何用上模板来解八皇后问题。</p><p><strong>3、八皇后</strong></p><p>老读者对八皇后问题应该并不陌生，之前我们在<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&mid=2650565284&idx=1&sn=33f7d3dc982b2b550f30a24479a9fe4f&chksm=f1fedc27c689553167f471b3b4d080bcb13bf60825d73262f55f2bbe2639835ff71ab4b78f33&scene=21#wechat_redirect" target="_blank" rel="noopener">位运算</a>的文章中详细地讲解了如何用位运算来求解八皇后问题，当时也说了，用位运算来求解，是效率最高的，其实八皇后问题也可以用我们的回溯算法来求解，只不过不是那么高效而已，不过可读性更好。</p><p>来简单回顾上什么是八皇后问题。</p><blockquote><p>八皇后问题：8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子</p></blockquote><p>如下所示是 8 皇后问题的一种放法。</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/5.JPG" srcset="/img/loading.gif" style="zoom:100%;display: flex;margin: 0 auto;"><p><strong>1、将问题转为树形结构</strong></p><p>对于 N 皇后问题，问题可以分解为 N 个阶段， 第一个阶段即第一行有 N 个解（N 列中的做生意一个解）， 第二阶段（第二行）由于受第一行限制（皇后所在列，斜线不能放），解肯定是少于 N 个解，它的解视第一行所放皇后位置而定,… ，第 N 个阶段的解受前面 N-1 个阶段解的影响。N 皇后树形结构如下</p><img src="/2020/09/20/%E4%B8%80%E6%96%87%E5%AD%A6%E4%BC%9A%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/6.JPG" srcset="/img/loading.gif" style="zoom:80%;display: flex;margin: 0 auto;"><p><strong>2、套用上述回溯算法的解题模板，进行深度优先遍历，直到找到问题的解</strong></p><p>套用以上模板时，注意终止条件与每个阶段（每一行）所选解是否合法（剪枝）即可。注意看下 queenSettle 的方法，这是套用我们的回溯算法解题模板所得出来的，其他方法都是在此模板上进行添砖加瓦而已。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer N = <span class="hljs-number">8</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedColumns 已选解集合,下标表示行,值表示queen存储在哪一列</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row             可选的空间解,第 n 行可选</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queenSettle</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] selectedColumns, <span class="hljs-keyword">int</span> row)</span> </span>&#123;        <span class="hljs-comment">// 终止条件</span>        <span class="hljs-keyword">if</span> (row &gt; N - <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">// 说明前 N 行都已经都选完皇后了，</span>            printQueens(selectedColumns);            <span class="hljs-keyword">return</span>;        &#125;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i ++) &#123;            <span class="hljs-comment">// 剔除不合法的格子</span>            <span class="hljs-keyword">if</span> (!isValid(row, i, selectedColumns)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 选择子节点（当前行）其中一个解</span>            selectedColumns[row] = i;            <span class="hljs-comment">// 选完之后再进入下个阶段的（下一行）遍历</span>            queenSettle(selectedColumns, row + <span class="hljs-number">1</span>);            <span class="hljs-comment">// 回溯,换一个解继续 dfs，回溯时要把回溯节点的解移除</span>            selectedColumns[row] = -<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 判断相应的格子放置皇后是否OK</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> row</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> column</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> selectedColumns</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> column, <span class="hljs-keyword">int</span>[] selectedColumns)</span> </span>&#123;        <span class="hljs-comment">//判断row行column列放置是否合适</span>        <span class="hljs-keyword">int</span> leftup = column - <span class="hljs-number">1</span>, rightup = column + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123; <span class="hljs-comment">// 逐行往上考察每一行</span>            <span class="hljs-keyword">if</span> (selectedColumns[i] == column) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 第i行的column列有棋子吗？</span>            <span class="hljs-keyword">if</span> (leftup &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 考察左上对角线：第i行leftup列有棋子吗？</span>                <span class="hljs-keyword">if</span> (selectedColumns[i] == leftup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            <span class="hljs-keyword">if</span> (rightup &lt; <span class="hljs-number">8</span>) &#123; <span class="hljs-comment">// 考察右上对角线：第i行rightup列有棋子吗？</span>                <span class="hljs-keyword">if</span> (selectedColumns[i] == rightup) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            --leftup; ++rightup;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] selectedColumn = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[N];        <span class="hljs-comment">// 从第 0 行开始 DFS</span>        queenSettle(selectedColumn, <span class="hljs-number">0</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] result)</span> </span>&#123; <span class="hljs-comment">// 打印出一个二维矩阵</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; <span class="hljs-number">8</span>; ++row) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> column = <span class="hljs-number">0</span>; column &lt; <span class="hljs-number">8</span>; ++column) &#123;                <span class="hljs-keyword">if</span> (result[row] == column) System.out.print(<span class="hljs-string">"Q "</span>);                <span class="hljs-keyword">else</span> System.out.print(<span class="hljs-string">"* "</span>);            &#125;            System.out.println();        &#125;        System.out.println();    &#125;&#125;</code></pre></div><p>可以看到八皇后这么复杂的问题套用以上的解题模板也被我们轻松解决了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>使用回溯算法解题的关键是把问题分成多阶段，每个阶段都有相应的解，于是就把问题转成了树形问题，转成树形问题后，剩下的只需要套用上文总结的解题模板即可，尤其需要注意的是，当遍历当前阶段解的时候，可以根据之前阶段的解作「剪枝」操作，这样使问题的搜索规模变小，有效降低了问题的复杂度。</p><p><strong>巨人的肩膀</strong></p><ul><li><a href="https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nMUHqvwzG2LmWA9jMIHwQQ</a> 回溯算法详解</li><li><a href="https://time.geekbang.org/column/article/74287" target="_blank" rel="noopener">https://time.geekbang.org/column/article/74287</a> 回溯算法：从电影《蝴蝶效应》中学习回溯算法的核心思想</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子集</title>
    <link href="/2020/09/20/%E5%AD%90%E9%9B%86/"/>
    <url>/2020/09/20/%E5%AD%90%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定一组<strong>不含重复元素</strong>的整数数组&nbsp;<em>nums</em>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><p><strong>示例:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> nums = [1,2,3]<strong>输出:</strong>[  [3],&nbsp; [1],&nbsp; [2],&nbsp; [1,2,3],&nbsp; [1,3],&nbsp; [2,3],&nbsp; [1,2],&nbsp; []]</div></pre></div><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们可以使用经典的回溯法解题模板，来求解这个问题：</p><p>相关代码如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>        result = []        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recursive</span><span class="hljs-params">(select, allnums)</span>:</span>            <span class="hljs-keyword">if</span> select <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> result:                result.append(select.copy())            <span class="hljs-keyword">for</span> i, num <span class="hljs-keyword">in</span> enumerate(allnums):                select.append(num)                recursive(select, allnums[i + <span class="hljs-number">1</span>:])                select.remove(num)        recursive([], nums)        <span class="hljs-keyword">return</span> result</code></pre></div><p style="text-indent: 2em;">    这种经典的回溯解法当然是万能的，但是时间复杂度稍微有点高。我们在这里来介绍一种新的方法。</p><p class="note note-primary">迭代法实现子集枚举</p><p>记原序列中元素的总数为 <code>n</code>。原序列中的每个数字 <code>a_i</code>的状态可能有两种，即「在子集中」和「不在子集中」。我们用 <code>1</code> 表示「在子集中」，<code>0</code> 表示不在子集中，那么每一个子集可以对应一个长度为 <code>n</code> 的 0/1序列，第 <code>i</code> 位表示 <code>a_i</code>是否在子集中。例如，<code>n = 3 ，a = { 5, 2, 9 }</code> 时：</p><table><thead><tr><th>0/1 <strong>序列</strong></th><th><strong>子集</strong></th><th>0/10/1 序列对应的二进制数</th></tr></thead><tbody><tr><td>000</td><td>{ }</td><td>0</td></tr><tr><td>001</td><td>{ 9 }</td><td>1</td></tr><tr><td>010</td><td>{ 2 }</td><td>2</td></tr><tr><td>011</td><td>{ 2, 9 }</td><td>3</td></tr><tr><td>100</td><td>{ 5 }</td><td>4</td></tr><tr><td>101</td><td>{ 5, 9 }</td><td>5</td></tr><tr><td>110</td><td>{ 5, 2 }</td><td>6</td></tr><tr><td>111</td><td>{ 5, 2, 9 }</td><td>7</td></tr></tbody></table><p>可以发现 0/1序列对应的二进制数正好从 0 到 2^n - 1。我们可以枚举 mask∈[0,2^n−1]，mask 的二进制表示是一个 0/1序列，我们可以按照这个 0/1序列在原集合当中取数。当我们枚举完所有 2^n个 mask，我们也就能构造出所有的子集。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>        result = []        n = len(nums)        <span class="hljs-keyword">for</span> mask <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>&lt;&lt;n):            select = []            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):                <span class="hljs-keyword">if</span> mask &amp; <span class="hljs-number">1</span>&lt;&lt;i != <span class="hljs-number">0</span>:                    select.append(nums[i])            result.append(select)        <span class="hljs-keyword">return</span> result</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    List&lt;Integer&gt; t = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;        <span class="hljs-keyword">int</span> n = nums.length;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>; mask &lt; (<span class="hljs-number">1</span> &lt;&lt; n); ++mask) &#123;            t.clear();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;                <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) != <span class="hljs-number">0</span>) &#123;                    t.add(nums[i]);                &#125;            &#125;            ans.add(<span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;(t));        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;</code></pre></div><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/</a></p></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1+2+3+....+n=???</title>
    <link href="/2020/09/20/1-2-3-n/"/>
    <url>/2020/09/20/1-2-3-n/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>求 <code>1+2+...+n</code> ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> n = 3<strong>输出:&nbsp;</strong>6</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> n = 9<strong>输出:&nbsp;</strong>45</div></pre></div><p><strong>限制：</strong></p><ul>    <li><code>1 &lt;= n&nbsp;&lt;= 10000</code></li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p style="text-indent: 2em;">    首先我们梳理一下，这题要求我们不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句，因此我们手里能用的工具很少，列举出来发现只有加减法，赋值，位运算符以及逻辑运算符。</p><p style="text-indent: 2em;">    试想一下如果不加限制地使用递归的方法来实现这道题，相信大家都能很容易地给出下面的实现（以 C++ 为例）：</p><div class="hljs"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> n == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : n + sumNums(n - <span class="hljs-number">1</span>);    &#125;&#125;;</code></pre></div><p style="text-indent: 2em;">    通常实现递归的时候我们都会利用条件判断语句来决定递归的出口，但由于题目的限制我们不能使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。</p><p style="text-indent: 2em;">    以逻辑运算符 && 为例，对于 A && B 这个表达式，如果 A 表达式返回False，那么 A && B 已经确定为False ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回True ，那么 A || B 已经确定为True ，此时不会去执行表达式 B。</p><p style="text-indent: 2em;">    利用这一特性，我们可以将判断是否为递归的出口看作 A && B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回 True，并继续执行表达式 B 的部分，否则递归结束。当然，你也可以用逻辑运算符 || 给出类似的实现，这里我们只提供结合逻辑运算符 && 的递归实现。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumNums</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        <span class="hljs-keyword">return</span> n <span class="hljs-keyword">and</span> (n + self.sumNums(n<span class="hljs-number">-1</span>))</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2的幂？3的幂？4的幂？</title>
    <link href="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/"/>
    <url>/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定一个整数，写一个函数来判断它是否是 3&nbsp;的幂次方。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 27<strong>输出:</strong> true</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 0<strong>输出:</strong> false</div></pre></div><p><strong>示例 3:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 9<strong>输出:</strong> true</div></pre></div><p><strong>示例 4:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 45<strong>输出:</strong> false</div></pre></div><p><strong>进阶：</strong><br>你能不使用循环或者递归来完成本题吗？</p><p class="note note-primary">2和4的幂次问题同理</p><p>​         对于求解幂次的问题，我们第一反应会是想到系统提供的库函数<br>$$<br>n = pow(x, y) \ 9 = pow(3, 2) \ 即3^2=9<br>$$<br>，那么最笨的方法就是使用这个库函数，设置一个计数变量i，表示幂次，然后依次计算pow，直到等于n为止。这种方法是时间复杂度最高的，也是计算量最大的方法，俗称‘笨’方法。我将在接下里的方法中介绍一种通用的求解幂问题的通用，较为快捷的方法，和针对一些特殊情况的小技巧方法。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="方法一：循环迭代"><a href="#方法一：循环迭代" class="headerlink" title="方法一：循环迭代"></a>方法一：循环迭代</h2><p>找出数字 <code>n</code> 是否是数字 <code>b</code> 的幂的一个简单方法是，<code>n%3</code>  只要余数为 0，就一直将 <code>n</code> 除以 <code>b</code>。</p><p>$$<br>n=b^x<br>$$</p><p>因此，应该可以将 <code>n</code> 除以 <code>b</code>  x 次，每次都有 0 的余数，最终结果是 1。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">while</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>: n //= <span class="hljs-number">3</span>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">1</span></code></pre></div><p>注意我们需要一个警卫来检查那个 <code>n！=0</code>，否则 while 循环将永远不会结束。对于负数，该算法没有意义，因此我们也将包括该保护。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O<em>(log*b</em>(<em>n</em>))，在我们的例子中是 O(\log n)*。除数是用对数表示的。</li></ul><ul><li>空间复杂度：O(1)，没有使用额外的空间。</li></ul><p>这种做法同样适用2和4的幂次。</p><h2 id="方法二：log运算法"><a href="#方法二：log运算法" class="headerlink" title="方法二：log运算法"></a>方法二：log运算法</h2><p>我们可以用下面的数学公式，也就是高中所学的换底公式：<br>$$<br>n=3^i<br>$$</p><p>$$<br>i=log_3(n)={log_b(n)\over log_b(3)}<br>$$</p><p>若 <code>n</code> 是 3 的幂则 <code>i</code> 是整数。在 Java 中，我们通过取小数部分（利用 <code>% 1</code>）来检查数字是否是整数，并检查它是否是 0。</p><p>我们取<code>b=10</code>，进行换底计算，代码实现如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">return</span> (Math.log10(n) / Math.log10(<span class="hljs-number">3</span>)) % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>;    &#125;&#125;</code></pre></div><p>其他编程语言的实现要看对应的API。</p><p><strong>常见的陷阱 :</strong><br>这个解决方案是有问题的，因为我们开始使用 <code>double s</code>，这意味着我们会遇到精度错误。说明在比较双精度数时不应使用 ==。这是因为 <code>Math.log10(n)/Math.log10(3)</code> 的结果可能是 <code>5.0000001</code> 或 <code>4.9999999</code>。使用 <code>Math.log()</code> 函数而不是<code>Math.log10()</code> 可以观察到这种效果。</p><p>为了解决这个问题，我们需要将结果与 <code>epsilon</code> 进行比较。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">return</span> (Math.log(n) / Math.log(<span class="hljs-number">3</span>) + epsilon) % <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> * epsilon;</code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：Unknown。这里主要消耗时间的运算是 <code>Math.log</code>，它限制了我们算法的时间复杂性。实现依赖于我们使用的语言和编译器 。</p></li><li><p>空间复杂度： <code>O(1)</code>，我们没有使用任何额外的内存。<code>epsilon</code> 变量可以是内联的。</p></li></ul><p>这种做法也同样适用2和4的幂次。</p><h2 id="方法三：整数限制"><a href="#方法三：整数限制" class="headerlink" title="方法三：整数限制"></a>方法三：整数限制</h2><p>这种解法的精髓就在于求出在编程语言中能够表示的最大的幂次结果，然后模上这个数<code>n</code>，如果结果为<code>0</code>，那么这个<code>n</code>就是幂次结果。</p><p>举例，比如在python中，整数所能表示的最大数是30。当然这只是个假设，为了方便理解！！！，那么在30之内最大的3的幂次就是27了。因为<code>3*3*3=27</code>，所以我直接用这个最大的27模上<code>n</code>，比如<code>n=9</code>。显然，若要使模后的结果为<code>0</code>，那么n必须也得是3的倍数，<code>n=3, n=9</code>。所以，直接用最大的能表示的幂次数直接模<code>n</code>，看看结果是否为<code>0</code>，就可以判断了。</p><p>那么问题是怎么找到这个在整数表示内的最大幂次数呢？<br>$$<br>MaxInt = \frac{ 2^{32} }{2} - 1<br>$$<br> 因为我们使用 32 位来表示数字，所以范围的一半用于负数，0 是正数的一部分。</p><p>知道了 <code>n</code> 的限制，我们现在可以推断出 <code>n</code> 的最大值，也就是 3 的幂，是 <strong>1162261467</strong>。我们计算如下：<br>$$<br>3 ^{⌊log 3​     MaxInt⌋} =3^{⌊19.56⌋} =3^{19} =1162261467<br>$$</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        maxInt = <span class="hljs-number">2147483647</span> <span class="hljs-comment">#python所能表达的最大正整数</span>        max_exp = pow(<span class="hljs-number">3</span>, math.floor(math.log(maxInt, <span class="hljs-number">3</span>)))        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> max_exp % n == <span class="hljs-number">0</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。我们只做了一次操作。</p></li><li><p>空间复杂度： <code>O(1)</code>，没有使用额外空间。</p></li></ul><p class="note note-danger">这种方法只适用于底数为质数的数字，如3，5。</p><h2 id="方法四：位运算（2为底）"><a href="#方法四：位运算（2为底）" class="headerlink" title="方法四：位运算（2为底）"></a>方法四：位运算（2为底）</h2><p>该方法将通过位运算在 <code>O(1)</code> 的时间复杂度解决，通过使用如下的按位技巧：</p><ul><li><p>如何获取二进制中最右边的 <code>1</code>：<code>x &amp; (-x)</code>。</p></li><li><p>如何将二进制中最右边的 <code>1</code> 设置为 <code>0</code>：<code>x &amp; (x - 1)</code>。</p></li></ul><p>以下的两种解决方案背后的思想都是一样的：2 的幂在二进制中是有一个 <code>1</code> 后跟一些 <code>0</code>：<br>$$<br>1=(00000001) _2<br>$$</p><p>$$<br>2 = (0000 0010)_2<br>$$</p><p>$$<br>4 = (0000 0100)_2<br>$$</p><p>$$<br>8 = (0000 1000)_2<br>$$</p><p>不是 2 的幂的二进制中有一个以上的 <code>1</code>。<br>$$<br>3 = (00000011) _2<br>$$</p><p>$$<br>5 = (0000 0101)_2<br>$$</p><p>$$<br>6 = (0000 0110)_2<br>$$</p><p>$$<br>7 = (0000 0111)_2<br>$$</p><p>除了 <code>0</code>，我们应该单独处理。</p><h3 id="获取最右边的-1"><a href="#获取最右边的-1" class="headerlink" title="获取最右边的 1"></a><strong>获取最右边的 1</strong></h3><p>首先讨论为什么 <code>x &amp; (-x)</code> 可以获取到二进制中最右边的 1，且其它位设置为 0。如下图所示：</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m1.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p>因此，<em>x</em> 和 −<em>x</em> 只有一个共同点：最右边的 1。这说明 <code>x &amp; (-x)</code> 将保留最右边的 1。并将其他的位设置为 0。</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m2.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p><strong>检测是否为 2 的幂：</strong></p><p>我们通过 <code>x &amp; (-x)</code> 保留了最右边的 1，并将其他位设置为 0 若 <code>x</code> 为 2 的幂，则它的二进制表示中只包含一个 1，则有 <code>x &amp; (-x) = x</code>。</p><p>若 <code>x</code> 不是 2 的幂，则在二进制表示中存在其他 1，因此 <code>x &amp; (-x) != x</code>。</p><p>因此判断是否为 2 的幂的关键是：判断 <code>x &amp; (-x) == x</code>。</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m3.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> n &amp; (-n) == n</code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><h3 id="去除二进制中最右边的-1"><a href="#去除二进制中最右边的-1" class="headerlink" title="去除二进制中最右边的 1"></a>去除二进制中最右边的 1</h3><p>首先讨论为什么 <code>x &amp; (x - 1)</code> 可以将最右边的 1 设置为 0。</p><p><code>(x - 1)</code> 代表了将 <code>x</code> 最右边的 1 设置为 0，并且将较低位设置为 1。</p><p>再使用与运算：则 <code>x</code> 最右边的 1 和就会被设置为 0，因为 <code>1 &amp; 0 = 0</code>。</p><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m4.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p><strong>检测是否为 2 的幂：</strong></p><ul><li><p>2 的幂二进制表示只含有一个 1。</p></li><li><p><code>x &amp; (x - 1)</code> 操作会将 2 的幂设置为 0，因此判断是否为 2 的幂是：判断 <code>x &amp; (x - 1) == 0</code>。</p></li></ul><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/2m5.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> n &amp; (n - <span class="hljs-number">1</span>) == <span class="hljs-number">0</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><p class="note note-danger">这种方法只适用于底数为2或者4的数字</p><h2 id="方法五：暴力破解法"><a href="#方法五：暴力破解法" class="headerlink" title="方法五：暴力破解法"></a>方法五：暴力破解法</h2><p>我们提前计算所有可能答案。</p><p>我们知道输入的整数是 32 位整数<br>$$<br>x \le 2^{31} - 1<br>$$<br>因此我们最大 3的幂次为<br>$$<br>[\log_3\left(2^{31} - 1\right)] = 19<br>$$<br>那么我们总共有 20 种可能：<br>$$<br>3^0 , 3^1 , 3^2 , …, 3^{19}<br>$$<br>我们预计算全部可能，然后运行时检查输入数字是否在预计算列表中。</p><p>预计算：</p><div class="hljs"><pre><code class="hljs python">result = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>):    result.append(pow(<span class="hljs-number">3</span>, i))</code></pre></div><p>得到这样的一个列表：</p><div class="hljs"><pre><code class="hljs python">[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">27</span>, <span class="hljs-number">81</span>, <span class="hljs-number">243</span>, <span class="hljs-number">729</span>, <span class="hljs-number">2187</span>, <span class="hljs-number">6561</span>, <span class="hljs-number">19683</span>, <span class="hljs-number">59049</span>, <span class="hljs-number">177147</span>, <span class="hljs-number">531441</span>, <span class="hljs-number">1594323</span>, <span class="hljs-number">4782969</span>, <span class="hljs-number">14348907</span>, <span class="hljs-number">43046721</span>, <span class="hljs-number">129140163</span>, <span class="hljs-number">387420489</span>, <span class="hljs-number">1162261467</span>]</code></pre></div><p>然后判断n是否在列表中：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfThree</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        result = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">27</span>, <span class="hljs-number">81</span>, <span class="hljs-number">243</span>, <span class="hljs-number">729</span>, <span class="hljs-number">2187</span>, <span class="hljs-number">6561</span>, <span class="hljs-number">19683</span>, <span class="hljs-number">59049</span>, <span class="hljs-number">177147</span>, <span class="hljs-number">531441</span>, <span class="hljs-number">1594323</span>, <span class="hljs-number">4782969</span>, <span class="hljs-number">14348907</span>, <span class="hljs-number">43046721</span>, <span class="hljs-number">129140163</span>, <span class="hljs-number">387420489</span>, <span class="hljs-number">1162261467</span>]        <span class="hljs-keyword">return</span> n <span class="hljs-keyword">in</span> result</code></pre></div><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：<code>O(1)</code>。</p></li><li><p>空间复杂度：<code>O(1)</code>。</p></li></ul><p class="note note-danger">这种方法适用于所有情况</p><h2 id="方法六：位运算（4为底）"><a href="#方法六：位运算（4为底）" class="headerlink" title="方法六：位运算（4为底）"></a>方法六：位运算（4为底）</h2><ul><li><p>我们首先检查 <code>num</code> 是否为 <code>2</code> 的幂：<code>x &gt; 0 and x &amp; (x - 1) == 0</code>。</p></li><li><p>现在的问题是区分 <code>2</code> 的偶数幂（当 <em>x</em> 是 <code>4</code> 的幂时）和 <code>2</code> 的奇数幂（当 <em>x</em> 不是 <code>4</code> 的幂时）。在二进制表示中，这两种情况都只有一位为 <code>1</code>，其余为 <code>0</code>。</p></li><li><p>有什么区别？在第一种情况下（<code>4</code> 的幂），<code>1</code> 处于偶数位置：第 <code>0</code> 位、第 <code>2</code> 位、第 <code>4</code> 位等；在第二种情况下，<code>1</code> 处于奇数位置。</p></li></ul><img src="/2020/09/01/2%E7%9A%84%E5%B9%82%EF%BC%9F3%E7%9A%84%E5%B9%82%EF%BC%9F4%E7%9A%84%E5%B9%82%EF%BC%9F/4mi.jpg" srcset="/img/loading.gif" style="zoom:50%;display: flex;margin: 0 auto;"><p>因此 <code>4</code> 的幂与数字<br>$$<br>(101010…10)_2<br>$$<br> 相与会得到 <code>0</code>。即<br>$$<br>4^a \land (101010…10)_2 == 0<br>$$<br>(101010…10)2 用十六进制表示为 ：</p><p>$$<br>(aaaaaaaa)_{16}<br>$$</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPowerOfFour</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n &amp; (-n) == n <span class="hljs-keyword">and</span> n &amp; <span class="hljs-number">0xaaaaaaaa</span> == <span class="hljs-number">0</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(1)</code>。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://leetcode-cn.com/problems/power-of-four/solution/4de-mi-by-leetcode/" target="_blank" rel="noopener">4的幂</a></p><p><a href="https://leetcode-cn.com/problems/power-of-three/solution/3de-mi-by-leetcode/" target="_blank" rel="noopener">3的幂</a></p><p><a href="https://leetcode-cn.com/problems/power-of-two/solution/2de-mi-by-leetcode/" target="_blank" rel="noopener">2的幂</a></p></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树层序遍历的思考</title>
    <link href="/2020/08/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2020/08/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><div class="notranslate"><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><div class="hljs"><pre><div style="color:white">    3   / \  9  20    /  \   15   7</div></pre></div><p>返回其层次遍历结果：</p><div class="hljs"><pre><div style="color:white">[  [3],  [9,20],  [15,7]]</div></pre></div><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p style="text-indent: 2em;">    二叉树的层序遍历比较基础，想法很简单，就是用一个queue就可以实现，一次把弹出节点的左右子节点放入queue中，然后读出就行。</p><p style="text-indent: 2em;">    然而这个题，要求同一层结点数据放在一个[]中，这个地方就是我们要思考的地方！</p><p style="text-indent: 2em;">    在队列中添加子节点的同时，要把同一层的结点放在一起操作，这里就需要获得这一层结点的数量，然后在这个数量中再循环看看是否还有子节点，然后继续放入队列中。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, x)</span>:</span>        self.val = x        self.left = <span class="hljs-literal">None</span>        self.right = <span class="hljs-literal">None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span>        results = [] <span class="hljs-comment">#放最终结果</span>        que = Queue() <span class="hljs-comment">#暂存队列</span>        <span class="hljs-keyword">if</span> root:            results.append([root.val])            que.put(root)        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            quelength = que.qsize() <span class="hljs-comment">#获取同层结点的数量，因为同层的结点同时在队列里</span>            cell = [] <span class="hljs-comment">#存放每层的结点val</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(quelength):                node = que.get()                <span class="hljs-keyword">if</span> node.left:                    cell.append(node.left.val)                    que.put(node.left)                <span class="hljs-keyword">if</span> node.right:                    cell.append(node.right.val)                    que.put(node.right)                quelength -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> cell :                results.append(cell)        <span class="hljs-keyword">return</span> results</code></pre></div><h1 id="问题变种"><a href="#问题变种" class="headerlink" title="问题变种"></a>问题变种</h1><p class="note note-success">如何求每层的平均值？</p><div class="notranslate"><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>    3   / \  9  20    /  \   15   7<strong>输出：</strong>[3, 14.5, 11]<strong>解释：</strong>第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</div></pre></div><p><strong>提示：</strong></p><ul>    <li>节点值的范围在32位有符号整数范围内。</li></ul>代码实现：<div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[float]:</span>        results = []        que = Queue()        <span class="hljs-keyword">if</span> root:            results.append(root.val)            que.put(root)        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> que.empty():            quelength = que.qsize()            sum = <span class="hljs-number">0</span>            count = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(quelength):                node = que.get()                <span class="hljs-keyword">if</span> node.left:                    sum += node.left.val                    que.put(node.left)                    count += <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> node.right:                    sum += node.right.val                    que.put(node.right)                    count += <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> count!=<span class="hljs-number">0</span>:                avg = sum / count                results.append(avg)        <span class="hljs-keyword">return</span> results</code></pre></div></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模拟求和问题</title>
    <link href="/2020/08/26/%E6%A8%A1%E6%8B%9F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2020/08/26/%E6%A8%A1%E6%8B%9F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一-二进制的加法"><a href="#一-二进制的加法" class="headerlink" title="一. 二进制的加法"></a>一. 二进制的加法</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><div class="notranslate"><p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p><p>输入为 <strong>非空 </strong>字符串且只包含数字&nbsp;<code>1</code>&nbsp;和&nbsp;<code>0</code>。</p><p><strong>示例&nbsp;1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> a = "11", b = "1"<strong>输出:</strong> "100"</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> a = "1010", b = "1011"<strong>输出:</strong> "10101"</div></pre></div><p>&nbsp;</p><p><strong>提示：</strong></p><ul>    <li>每个字符串仅由字符 <code>'0'</code> 或 <code>'1'</code> 组成。</li>    <li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>    <li>字符串如果不是 <code>"0"</code> ，就都不含前导零。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p class="note note-primary">方法一： 转十进制相加</p><p>考虑一个最朴素的方法：先将<code>a</code>和<code>b</code>转化成十进制数，求和后再转化为二进制数。利用 Python 和 Java 自带的高精度运算，我们可以很简单地写出这个程序：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(self, a, b)</span> -&gt; str:</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'&#123;0:b&#125;'</span>.format(int(a, <span class="hljs-number">2</span>) + int(b, <span class="hljs-number">2</span>))</code></pre></div><p>如果 <code>a</code> 的位数是 <code>n</code>，<code>b</code> 的位数为 <code>m</code>，这个算法的渐进时间复杂度为 <code>O(n+m)</code>。但是这里非常简单的实现基于 Python 和 Java 本身的高精度功能，在其他的语言中可能并不适用，并且在 Java 中：</p><ul><li>如果字符串超过 3333 位，不能转化为 <code>Integer</code></li><li>如果字符串超过 6565 位，不能转化为 <code>Long</code></li><li>如果字符串超过 500000001500000001 位，不能转化为 <code>BigInteger</code></li></ul><p>因此，为了适用于长度较大的字符串计算，我们应该使用更加健壮的算法。</p><p class="note note-primary">方法二： 竖式模拟相加</p><p>我们可以借鉴「列竖式」的方法，末尾对齐，逐位相加。在十进制的计算中「逢十进一」，二进制中我们需要「逢二进一」。</p><p>具体的，我们可以取<br>$$<br>n = max{ |a|, |b| }<br>$$<br>，循环 <code>n</code> 次，从最低位开始遍历。我们使用一个变量 <code>carry</code> 表示上一个位置的进位，初始值为 <code>0</code>。记当前位置对其的两个位为<br>$$<br>a^i,b^i<br>$$<br>，则每一位的答案为<br>$$<br>(carry + a^i+b^i)mod2<br>$$<br>，下一位的进位为<br>$$<br>⌊(carry + a^i+b^i)/2⌋<br>$$<br>。重复上述步骤，直到数字 <code>a</code> 和 <code>b</code> 的每一位计算完毕。最后如果 <code>carry</code> 的最高位不为 <code>0</code>，则将最高位添加到计算结果的末尾。</p><p>注意，为了让各个位置对齐，你也可以直接把 <code>a</code> 和 <code>b</code> 中短的那一个补 <code>0</code> 直到和长的那个一样长，然后从高位向低位遍历，对应位置的答案按照顺序存入答案字符串内，最终将答案串反转.</p><img src="/2020/08/26/%E6%A8%A1%E6%8B%9F%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/IMG_3114.jpg" srcset="/img/loading.gif" alt="IMG_3114.jpg" style="zoom:25%;display: flex;margin: 0 auto;"><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addBinary</span><span class="hljs-params">(self, a: str, b: str)</span> -&gt; str:</span>        results = []        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(max(len(a), len(b))):            carry += int(a[len(a) - i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &lt; len(a) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            carry += int(b[len(b) - i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> i &lt; len(b) <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            results.append(str(carry % <span class="hljs-number">2</span>))            carry //= <span class="hljs-number">2</span>            i += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> carry &gt; <span class="hljs-number">0</span> :            results.append(<span class="hljs-string">'1'</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(results[::<span class="hljs-number">-1</span>])</code></pre></div><p>复杂度分析</p><p>假设 <code>n=max{∣a∣,∣b∣}</code>。</p><ul><li>时间复杂度：<code>O(n)</code>，这里的时间复杂度来源于顺序遍历 <code>a</code> 和 <code>b</code>。</li><li>空间复杂度：<code>O(1)</code>，除去答案所占用的空间，这里使用了常数个临时变量。</li></ul><h1 id="二-链表求和"><a href="#二-链表求和" class="headerlink" title="二. 链表求和"></a>二. 链表求和</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><div class="notranslate"><p>给定两个用链表表示的整数，每个节点包含一个数位。</p><p>这些数位是反向存放的，也就是个位排在链表首部。</p><p>编写函数对这两个整数求和，并用链表形式返回结果。</p><p><strong>示例：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295<strong>输出：</strong>2 -&gt; 1 -&gt; 9，即912</div></pre></div><p><strong>进阶：</strong>假设这些数位是正向存放的，请再做一遍。</p><p><strong>示例：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295<strong>输出：</strong>9 -&gt; 1 -&gt; 2，即912</div></pre></div><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>解题思路和上一题样，只不过这里增加了尾插法插入链表的操作。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span>        end = results = ListNode(<span class="hljs-number">-1</span>)        carry = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">or</span> l2:            carry += l1.val <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            carry += l2.val <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>            end.next = ListNode(carry % <span class="hljs-number">10</span>)            end = end.next            carry //= <span class="hljs-number">10</span>            l1 = l1.next <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>            l2 = l2.next <span class="hljs-keyword">if</span> l2 <span class="hljs-keyword">else</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> carry &gt;= <span class="hljs-number">1</span>:            end.next = ListNode(<span class="hljs-number">1</span>)            end = end.next        <span class="hljs-keyword">return</span> results.next</code></pre></div></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文串的那些事儿（一）</title>
    <link href="/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p class="note note-success">回顾经典回文串链问题</p><h1 id="一-回文数"><a href="#一-回文数" class="headerlink" title="一.  回文数"></a>一.  回文数</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 121<strong>输出:</strong> true</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> -121<strong>输出:</strong> false<strong>解释:</strong> 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</div></pre></div><p><strong>示例 3:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 10<strong>输出:</strong> false<strong>解释:</strong> 从右向左读, 为 01 。因此它不是一个回文数。</div></pre></div><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">    在这道题中，我们可以借助列表的反转方法来判断数字是否是一个回文数字。首先，由于回文串的对称性，负数一定不是回文数，那么我们只需对正数进行字符串转换。之后将字符串放到list中，使用reverse方法来判断反转之后的list和原list是否相同。若相同表示是回文数字，否则不是回文数字。</p><p style="text-indent: 2em;">    这种方法的一个缺点就是另外开辟了新的数组空间，空间复杂度偏高。</p><p style="text-indent: 2em;">    另外一种做法就是通过取整和取余操作获取整数中对应的数字进行比较。举个例子：1221 这个数字。通过计算 1221 / 1000， 得首位1；通过计算 1221 % 10， 可得末位 1；进行比较；再将 22 取出来继续比较</p><img src="/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/p1.gif" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:50%;display: flex;margin: 0 auto;"><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, x: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">else</span>:            num_list = list(str(x))            reverse = <span class="hljs-string">''</span>.join(num_list[::<span class="hljs-number">-1</span>])            <span class="hljs-keyword">if</span> str(x) == reverse:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        <span class="hljs-comment">//边界判断</span>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">int</span> div = <span class="hljs-number">1</span>;        <span class="hljs-comment">//</span>        <span class="hljs-keyword">while</span> (x / div &gt;= <span class="hljs-number">10</span>) div *= <span class="hljs-number">10</span>;        <span class="hljs-keyword">while</span> (x &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">int</span> left = x / div;            <span class="hljs-keyword">int</span> right = x % <span class="hljs-number">10</span>;            <span class="hljs-keyword">if</span> (left != right) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            x = (x % div) / <span class="hljs-number">10</span>;            div /= <span class="hljs-number">100</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;&#125;</code></pre></div><h1 id="二-验证回文串"><a href="#二-验证回文串" class="headerlink" title="二. 验证回文串"></a>二. 验证回文串</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "A man, a plan, a canal: Panama"<strong>输出:</strong> true</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "race a car"<strong>输出:</strong> false</div></pre></div><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">    在这道题中，我们的限定条件是只考虑字符串其中的字母和数字部分，并且字母大小写可忽略。我们可以使用双指针的方法，一个只指向开头字符，一个指向末尾字符，两指针所指字符分别比较。如果当前指针所指字符不是字母或数字，那么就越过这一字符，指向下一个字符，直到是字母或数字为止。这种双指针的方法，只需遍历一遍字符串即可判断。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        i, j = <span class="hljs-number">0</span>, len(s)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> i &lt; j :            <span class="hljs-keyword">while</span> i&lt;j <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[i].isalnum():                i += <span class="hljs-number">1</span>            <span class="hljs-keyword">while</span> i&lt;j <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> s[j].isalnum():                j -= <span class="hljs-number">1</span>            <span class="hljs-keyword">if</span> i &lt; j :                <span class="hljs-keyword">if</span> s[i].lower() != s[j].lower():                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>                i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(|s|)</code>，其中<code>∣s∣</code> 是字符串s 的长度。</li><li>空间复杂度：<code>O(1)</code>。</li></ul><h1 id="三-验证回文字符串Ⅱ"><a href="#三-验证回文字符串Ⅱ" class="headerlink" title="三. 验证回文字符串Ⅱ"></a>三. 验证回文字符串Ⅱ</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>给定一个非空字符串&nbsp;<code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "aba"<strong>输出:</strong> True</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> "abca"<strong>输出:</strong> True<strong>解释:</strong> 你可以删除c字符。</div></pre></div><p><strong>注意:</strong></p><ol>    <li>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</li></ol><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">    考虑最朴素的方法：首先判断原串是否是回文串，如果是，就返回 true；如果不是，则枚举每一个位置作为被删除的位置，再判断剩下的字符串是否是回文串。这种做法的渐进时间复杂度是 O(n^2)的，会超出时间限制。</p><p style="text-indent: 2em;">我们换一种想法。首先考虑如果不允许删除字符，如何判断一个字符串是否是回文串。常见的做法是使用双指针。定义左右指针，初始时分别指向字符串的第一个字符和最后一个字符，每次判断左右指针指向的字符是否相同，如果不相同，则不是回文串；如果相同，则将左右指针都往中间移动一位，直到左右指针相遇，则字符串是回文串。</p><p style="text-indent: 2em;">    在允许最多删除一个字符的情况下，同样可以使用双指针，通过贪心算法实现。初始化两个指针 low 和 high 分别指向字符串的第一个字符和最后一个字符。每次判断两个指针指向的字符是否相同，如果相同，则更新指针，令 low = low + 1 和 high = high - 1，然后判断更新后的指针范围内的子串是否是回文字符串。如果两个指针指向的字符不同，则两个字符中必须有一个被删除，此时我们就分成两种情况：即删除左指针对应的字符，留下子串s[low + 1], ..., s[high]，或者删除右指针对应的字符，留下子串 s[low], s[low + 1], ..., s[high - 1]。当这两个子串中至少有一个是回文串时，就说明原始字符串删除一个字符之后就以成为回文串。</p><img src="/2020/08/04/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/680_fig1.png" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:50%;display: flex;margin: 0 auto;"><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deletePalindrome</span><span class="hljs-params">(low, high)</span>:</span>            <span class="hljs-keyword">while</span> low &lt; high:                <span class="hljs-keyword">if</span> s[low] == s[high]:                    low += <span class="hljs-number">1</span>                    high -= <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        low, high = <span class="hljs-number">0</span>, len(s)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> low&lt;high:            <span class="hljs-keyword">if</span> s[low] == s[high]:                low += <span class="hljs-number">1</span>                high -= <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> deletePalindrome(low+<span class="hljs-number">1</span>, high) <span class="hljs-keyword">or</span> deletePalindrome(low, high<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre></div><h1 id="四-回文链表"><a href="#四-回文链表" class="headerlink" title="四. 回文链表"></a>四. 回文链表</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><div class="notranslate"><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 1-&gt;2<strong>输出:</strong> false</div></pre></div><p><strong>示例 2:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入:</strong> 1-&gt;2-&gt;2-&gt;1<strong>输出:</strong> true</div></pre></div><p><strong>进阶：</strong><br>你能否用&nbsp;O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p style="text-indent: 2em;">第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。</p><p style="text-indent: 2em;">执行第二部的最佳方法取决于你使用的变成语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。</p><p style="text-indent: 2em;">在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val==node_2.val。而 node_1==node_2 是错误的。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, head: ListNode)</span> -&gt; bool:</span>        listt = []        <span class="hljs-keyword">while</span> head:            listt.append(head.val)            head = head.next        <span class="hljs-keyword">return</span> listt == listt[::<span class="hljs-number">-1</span>]</code></pre></div><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p style="text-indent: 2em;">避免使用 O(n) 额外空间的方法就是改变输入。</p><p style="text-indent: 2em;">我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，因为使用该函数的人不希望链表结构被更改。</p><p><strong>算法：</strong></p><p>我们可以分为以下几个步骤：</p><ol><li><p>找到前半部分链表的尾节点。</p></li><li><p>反转后半部分链表。</p></li><li><p>判断是否为回文。</p></li><li><p>恢复链表。</p></li><li><p>返回结果。</p><p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p></li></ol><p style="text-indent: 2em;">或者可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针到链表的中间。通过慢指针将链表分为两部分。</p><p style="text-indent: 2em;">若链表有奇数个节点，则中间的节点应该看作是前半部分。</p><p style="text-indent: 2em;">步骤二可以使用在反向链表问题中找到解决方法来反转链表的后半部分。</p><p style="text-indent: 2em;">步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p><p style="text-indent: 2em;">步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(self, head: ListNode)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> head <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-comment"># Find the end of first half and reverse second half.</span>        first_half_end = self.end_of_first_half(head)        second_half_start = self.reverse_list(first_half_end.next)        <span class="hljs-comment"># Check whether or not there's a palindrome.</span>        result = <span class="hljs-literal">True</span>        first_position = head        second_position = second_half_start        <span class="hljs-keyword">while</span> result <span class="hljs-keyword">and</span> second_position <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">if</span> first_position.val != second_position.val:                result = <span class="hljs-literal">False</span>            first_position = first_position.next            second_position = second_position.next        <span class="hljs-comment"># Restore the list and return the result.</span>        first_half_end.next = self.reverse_list(second_half_start)        <span class="hljs-keyword">return</span> result        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">end_of_first_half</span><span class="hljs-params">(self, head)</span>:</span>        fast = head        slow = head        <span class="hljs-keyword">while</span> fast.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> fast.next.next <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            fast = fast.next.next            slow = slow.next        <span class="hljs-keyword">return</span> slow    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_list</span><span class="hljs-params">(self, head)</span>:</span>        previous = <span class="hljs-literal">None</span>        current = head        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:            next_node = current.next            current.next = previous            previous = current            current = next_node        <span class="hljs-keyword">return</span> previous</code></pre></div><p>反转链表使用的是头插法。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<code>O(n)</code>，其中 <code>n</code> 指的是链表的大小。</li><li>空间复杂度：<code>O(1)</code>，我们是一个接着一个的改变指针，我们在堆栈上的堆栈帧不超过 <code>O(1)</code>。<br>该方法的缺点是，在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执执行过程中链表暂时断开。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p style="text-indent: 2em;">回文串问题是经典的初级算法，回顾这一文章，不难发现解决回文的问题追根溯源可以归结以下几种方法：</p><ul><li>借助list反转实现判断</li><li>借助双指针，前后分别进行判断</li><li>链表借助list空间</li><li>求出回文的中间节点，将后一半的回文反转后，与前一半回文依次进行比较</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/" target="_blank" rel="noopener">回文数</a></p><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/" target="_blank" rel="noopener">验证回文字符串 Ⅱ</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/hui-wen-lian-biao-by-leetcode/" target="_blank" rel="noopener">回文链表</a></p></div></div></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>数组</tag>
      
      <tag>回文串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重要！Java最新全套学习路线</title>
    <link href="/2020/08/01/%E9%87%8D%E8%A6%81%EF%BC%81Java%E6%9C%80%E6%96%B0%E5%85%A8%E5%A5%97%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2020/08/01/%E9%87%8D%E8%A6%81%EF%BC%81Java%E6%9C%80%E6%96%B0%E5%85%A8%E5%A5%97%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Java课程涉及知识点"><a href="#Java课程涉及知识点" class="headerlink" title="Java课程涉及知识点"></a>Java课程涉及知识点</h1><p class="note note-info">本文仅介绍Java学习路线，不包含学习资源，学习资源会在后续的博客中补充。</p><h2 id="阶段一-（夯实基础）"><a href="#阶段一-（夯实基础）" class="headerlink" title="阶段一 （夯实基础）"></a><strong>阶段一 （夯实基础）</strong></h2><h3 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a><strong>Java基础语法</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>熟悉Java等基本概念<span class="hljs-number">2.</span>掌握Eclipse/IDEA集成开发工具的安装、配置和应用<span class="hljs-number">3.</span>熟悉Java基本语法、基本类型、运算符和表达式<span class="hljs-number">4.</span>掌握分支、循环逻辑语句、数组等知识的应用</code></pre></div><p>知识点列表:</p><ul><li>​    JDK、JRE、JVM基本概念</li><li>​    Java环境搭建和配置</li><li>​    安装和使用Eclipse/IDEA开发环境</li><li>​    Java基本数据类型</li><li>​    变量,运算符,表达式</li><li>​    分支语句,循环语句</li><li>​    数组，数组应用</li></ul><h3 id="Java面向对象编程"><a href="#Java面向对象编程" class="headerlink" title="Java面向对象编程"></a><strong>Java面向对象编程</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>理解面向对象思想和概念<span class="hljs-number">2.</span>学会面向对象分析方法<span class="hljs-number">3.</span>掌握类、对象、继承、多态的使用<span class="hljs-number">4.</span>熟悉重写、重载、抽象类、内部类以及设计模式的应用</code></pre></div><p>知识点列表:</p><ul><li>​    类、对象、属性、方法、构造器</li><li>​    封装、继承、多态</li><li>​    重写、重载</li><li>​    访问权限控制符</li><li>​    this和super、static、final</li><li>​    抽象类和接口,内部类</li><li>​    各种设计模式</li><li>​    Java设计原则</li></ul><h3 id="Java核心类库"><a href="#Java核心类库" class="headerlink" title="Java核心类库"></a><strong>Java核心类库</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>掌握Java核心类库的应用，例如字符串、日期、集合的处理<span class="hljs-number">2.</span>掌握异常处理、IO流对文件读写、多线程应用、网络编程实现计算机之间通讯<span class="hljs-number">3.</span>熟悉Java泛型和反射技术的应用</code></pre></div><p>知识点列表:</p><ul><li>​    Java核心类</li><li>​    Java字符串、日期处理</li><li>​    包装类、集合、数据结构</li><li>​    异常和异常处理</li><li>​    Java IO、NIO、多线程编程</li><li>​    线程同步机制、并发包</li><li>​    JAVA网络编程</li><li>​    Java泛型和注解</li><li>​    Java反射机制</li></ul><h3 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a><strong>算法与数据结构</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs plain">掌握常用算法和数据结构</code></pre></div><p>知识点列表:</p><ul><li>​    常用排序算法</li><li>​    常用查找算法</li><li>​    常用数据结构</li><li>​    一阶段刷题( 20道大厂面试题 )</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><strong>数据库</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 熟悉MySQL数据库的安装和使用<span class="hljs-number">2.</span> 精通SQL语句的编写和优化<span class="hljs-number">3.</span> 掌握数据库设计原则和方法<span class="hljs-number">4.</span> 了解视图、序列、索引概念和应用<span class="hljs-number">5.</span> 创建用户、给用户授权操作</code></pre></div><p>知识点列表:</p><ul><li>​    精通mysql</li></ul><h3 id="JDBC技术"><a href="#JDBC技术" class="headerlink" title="JDBC技术"></a><strong>JDBC技术</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 熟悉JDBC API应用，掌握Java对数据库的访问方法<span class="hljs-number">2.</span> 掌握如何实现对数据库的增删改查<span class="hljs-number">3.</span> 如何使用安全的数据库访问方式<span class="hljs-number">4.</span> 如何提升数据库操作性能，学会DAO模式的封装</code></pre></div><p>知识列表:</p><ul><li>​    JDBC 核心API</li><li>​    CRUD操作</li><li>​    Statement应用</li><li>​    PreparedStatement应用</li><li>​    预防SQL注入攻击</li><li>​    事务安全控制、高并发控制</li><li>​    批处理技术</li><li>​    dbcp、druid各种连接池的使用</li><li>​    DAO封装模式</li></ul><h3 id="XML与JSON"><a href="#XML与JSON" class="headerlink" title="XML与JSON"></a><strong>XML与JSON</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 熟悉XML文件的基本语法和规范<span class="hljs-number">2.</span> 了解SAX和DOM的区别<span class="hljs-number">3.</span> 掌握Dom4j工具的使用和XPATH的快速解析技术<span class="hljs-number">4.</span> 掌握JSON语法与解析</code></pre></div><p>知识点列表:</p><ul><li>​    XML基本语法</li><li>​    DTD和Schema</li><li>​    XML解析SAX和DOM</li><li>​    Java核心类Dom4j应用</li><li>​    XPATH技术应用</li><li>​    JSON语法</li><li>​    JSON解析库</li></ul><h3 id="H5前端"><a href="#H5前端" class="headerlink" title="H5前端"></a><strong>H5前端</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 熟悉HTML5语法和标记<span class="hljs-number">2.</span> 能熟练设计体验度高的HTML页面<span class="hljs-number">3.</span> 能实现对特殊功能的界面设计，例如画图表、视频音频播放、地理定位等<span class="hljs-number">4.</span> 熟悉CSS3语法和属性<span class="hljs-number">5.</span> 能熟悉对HTML内容进行渲染，例如文字样式、列表和表格样式、动画、元素定位和布局<span class="hljs-number">6.</span> 熟悉JavaScript基本语法<span class="hljs-number">7.</span> 掌握对HTML元素的处理、浏览器窗体的处理、事件处理等<span class="hljs-number">8.</span> 熟练实现对HTML页面的表单校验和页面特效的处理 HTML5应用程序缓存，本地存储技术localStorage和 sessionStorage的使用</code></pre></div><p>知识点列表:</p><ul><li>​    HTML5基本文档结构</li><li>​    标题、图片标记</li><li>​    链接、列表、表格标记</li><li>​    表单标记</li><li>​    CSS基础语法</li><li>​    CSS文本、列表、表格样式</li><li>​    CSS盒子模型</li><li>​    CSS浮动布局、定位</li><li>​    CSS弹性盒子</li><li>​    JavaScript语言基础</li><li>​    JavaScript闭包和自执行</li><li>​    JavaScript DOM编程</li><li>​    JavaScript事件模型</li><li>​    Window对象模型</li><li>​    HTML5画布</li><li>​    Web存储、音频/视频、拖放</li><li>​    本地存储</li><li>​    移动端适配</li><li>​    CSS3边框、背景</li><li>​    CSS3动画、特效</li><li>​    C33文字特效、盒子模型</li><li>​    JDBC jQuery选择器、事件</li><li>​    jQuery文档处理、特效</li><li>​    Bootstrap按钮、表格、列表等样式处理</li><li>​    Bootstrap布局、弹框、特效样式处理</li></ul><h3 id="JavaEE基础"><a href="#JavaEE基础" class="headerlink" title="JavaEE基础"></a><strong>JavaEE基础</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1</span>、掌握Tomcat的安装和使用<span class="hljs-number">2</span>、熟悉Servlet概念和开发规范<span class="hljs-number">3</span>、掌握session和cookie状态管理技术<span class="hljs-number">4</span>、掌握Filter和Listener组件的使用<span class="hljs-number">5</span>、掌握Servlet实现验证码和文件上传功能<span class="hljs-number">6.</span>熟悉JSP基本语法和标记<span class="hljs-number">7.</span>掌握JSP中<span class="hljs-number">9</span>大内置对象应用<span class="hljs-number">8.</span>能熟练使用JSTL和EL显示数据掌握<span class="hljs-number">4.</span>JSP+Servlet+JavaBean技术构建的MVC应用<span class="hljs-number">9.</span>熟悉Ajax作用和原理<span class="hljs-number">10.</span>掌握XMLHttpRequest对象的使用<span class="hljs-number">11.</span>熟悉JSON语法并熟练与Ajax结合运用<span class="hljs-number">12.</span>熟练掌握jQuery中$.ajax、$.load、$.post、$.<span class="hljs-keyword">get</span>等函数的使用<span class="hljs-number">13.</span>掌握ajax表单提交和文件上传功能</code></pre></div><p>知识点列表:</p><ul><li>​    HTTP协议</li><li>​    Tomcat配置和部署</li><li>​    Servlet生命周期</li><li>​    Servlet编写规范和配置</li><li>​    GET请求与POST请求的区别</li><li>​    接收用户请求的参数</li><li>​    中文接收乱码处理</li><li>​    ServletContext</li><li>​    ServletConfig</li><li>​    重定向与转发</li><li>​    Servlet+DAO工厂模式应用</li><li>​    Cookie与Session</li><li>​    Servlet实现文件上传功能</li><li>​    JSP 基本语法</li><li>​    JSP三大指令</li><li>​    JSP标记应用</li><li>​    JSP九内置对象</li><li>​    JSP四域对象</li><li>​    JSP异常处理</li><li>​    JSTL和 EL表达式</li><li>​    JSP新特性</li><li>​    Filter</li><li>​    Listener</li><li>​    MVC设计模式</li><li>​    Ajax作用和原理</li><li>​    XMLHttpRequest对象</li><li>​    Ajax局部刷新、异步处理</li><li>​    jQuery与Ajax技术</li><li>​    Ajax异步提交表单</li><li>​    Ajax异步上传文件</li><li>​    $.ajax函数的使用</li><li>​    $.get函数的使用</li><li>​    $.post函数的使用</li><li>​    $.load函数的使用</li><li>​    业务分层架构</li><li>​    前后端分离架构</li></ul><h3 id="操作系统训练"><a href="#操作系统训练" class="headerlink" title="操作系统训练"></a><strong>操作系统训练</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs plain">熟练掌握linux系统</code></pre></div><p>知识点列表:</p><ul><li>​    虚拟机安装与使用</li><li>​    centos操作系统安装</li><li>​    乌班图操作系统安装</li><li>​    常用命令</li><li>​    linux环境搭建</li><li>​    linux项目部署上线</li></ul><h2 id="阶段二-（前沿框架）"><a href="#阶段二-（前沿框架）" class="headerlink" title="阶段二 （前沿框架）"></a><strong>阶段二 （前沿框架）</strong></h2><h3 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a><strong>Maven</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs plain">熟练使用maven</code></pre></div><p>知识点列表:</p><ul><li>​    Maven 环境配置</li><li>​    Maven POM</li><li>​    Maven 构建生命周期</li><li>​    Maven 构建配置文件</li><li>​    Maven 仓库</li><li>​    Maven 插件</li><li>​    Maven 构建 Java 项目</li><li>​    Maven 构建 &amp; 项目测试</li><li>​    Maven 引入外部依赖</li><li>​    Maven 项目模板</li><li>​    Maven 快照(SNAPSHOT)</li><li>​    Maven 自动化构建</li><li>​    Maven 依赖管理</li><li>​    Maven 自动化部署</li><li>​    Maven IDEA</li></ul><h3 id="NoSql"><a href="#NoSql" class="headerlink" title="NoSql"></a><strong>NoSql</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>了解NoSQL概念<span class="hljs-number">2.</span>熟练掌握Redis的安装和命令<span class="hljs-number">3.</span>掌握Java对Redis的操作<span class="hljs-number">4.</span>了解Redis的事务、备份<span class="hljs-number">5.</span>解Redis的订阅\发布式消息系统的使用<span class="hljs-number">6.</span>熟练掌握如何使用Redis做缓存<span class="hljs-number">7.</span>了解MongoDB概念和安装<span class="hljs-number">8.</span>掌握MongoDB的结构和命令<span class="hljs-number">9.</span>掌握Java对MongoDB操作<span class="hljs-number">10.</span>掌握MongoDB CRUD操作<span class="hljs-number">11.</span>掌握排序、索引、备份和恢复等<span class="hljs-number">12.</span>了解对MongoDB的管理和维护</code></pre></div><p>知识点列表:</p><ul><li>​    Redis概念安装</li><li>​    Redis命令操作</li><li>​    Java Redis API</li><li>​    Redis 字符串操作命令</li><li>​    Redis 哈希操作命令</li><li>​    Redis列表操作命令</li><li>​    Redis集合操作命令</li><li>​    Redis 有序集合操作命令</li><li>​    Redis事务处理、备份和恢复</li><li>​    Redis消息发布系统</li><li>​    Redis集群搭建</li><li>​    MongoDB概念和安装</li><li>​    MongoDB命令操作</li><li>​    Java MongoDB API</li><li>​    MongoDB排序、索引</li><li>​    MongoDB备份恢复</li><li>​    MongoDB集群搭建</li></ul><h3 id="Java框架基础（Spring）"><a href="#Java框架基础（Spring）" class="headerlink" title="Java框架基础（Spring）"></a><strong>Java框架基础（Spring）</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> 熟悉Spring框架的模块结构<span class="hljs-number">2.</span> 掌握SpringIOC管理组件<span class="hljs-number">3.</span> 掌握如何对组件对象参数注入<span class="hljs-number">4.</span> 掌握JdbcTemplate对象的使用<span class="hljs-number">5.</span> 掌握Spring声明式事务处理<span class="hljs-number">6.</span> 熟练掌握SpringMVC流程<span class="hljs-number">7.</span> 掌握SpringMVC拦截器、异常处理、文件上传等功能的应用<span class="hljs-number">8.</span> 熟悉Spring中AOP概念及应用<span class="hljs-number">9.</span> 掌握Spring国际化概念和应用<span class="hljs-number">10.</span> 掌握SpringMVC中如何使用RESTFUL</code></pre></div><p>知识点列表:</p><ul><li>​    Spring IOC概念</li><li>​    ApplicationContext \ FactoryBean</li><li>​    IOC对象创建和生命周期</li><li>​    基本类型参数注入</li><li>​    集合类型参数注入</li><li>​    对象高级装配</li><li>​    组件扫描特性</li><li>​    Spring JdbcTemplate应用</li><li>​    Spring 事务及安全管理</li><li>​    Spring MVC框架原理</li><li>​    Spring MVC基本流程</li><li>​    Spring MVC拦截器</li><li>​    Spring MVC异常处理</li><li>​    Spring MVC文件上传</li><li>​    Restful服务架构</li><li>​    SpringAOP原理</li><li>​    AspectJ注解配置</li><li>​    Spring+JPA数据访问</li></ul><h3 id="Java框架基础（MyBatis）"><a href="#Java框架基础（MyBatis）" class="headerlink" title="Java框架基础（MyBatis）"></a><strong>Java框架基础（MyBatis）</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>掌握MyBatis开发环境的搭建<span class="hljs-number">2.</span>了解MyBatis框架结构和原理<span class="hljs-number">3.</span>掌握DQL/DML语句的定义<span class="hljs-number">4.</span>掌握Mapper映射器规则和应用<span class="hljs-number">5.</span>掌握MyBatis分页原理和优化<span class="hljs-number">6.</span>掌握MyBatis和PageHelper集成应用<span class="hljs-number">7.</span>了解动态SQL和多表关联映射<span class="hljs-number">8.</span>掌握Spring和MyBatis的整合应用</code></pre></div><p>知识点列表:</p><ul><li>​    MyBatis体系结构</li><li>​    SqlSession的使用</li><li>​    MyBatis映射基础</li><li>​    DQL 映射，DML映射</li><li>​    resultType/resultMap结果映射</li><li>​    Mapper映射器</li><li>​    MyBatis分页原理和优化</li><li>​    高级动态SQL映射</li><li>​    @Many关联映射</li><li>​    @One关联映射</li><li>​    MyBatis常见问题</li><li>​    JdbcType属性作用</li><li>​    Spring和MyBatis整合Mapper</li><li>​    Spring和MyBatis整合SqlSessionTemplate</li></ul><h3 id="Java框架进阶（SSM整合）"><a href="#Java框架进阶（SSM整合）" class="headerlink" title="Java框架进阶（SSM整合）"></a><strong>Java框架进阶（SSM整合）</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>掌握SSM基本使用<span class="hljs-number">2.</span>熟悉SSM应用常见问题和解决方法<span class="hljs-number">4.</span>熟悉SSM流程设计和实现<span class="hljs-number">5.</span>掌握SSM事务控制<span class="hljs-number">6.</span>掌握Restful架构运用</code></pre></div><h2 id="阶段三-（高级架构）"><a href="#阶段三-（高级架构）" class="headerlink" title="阶段三 （高级架构）"></a>阶段三 （高级架构）</h2><h3 id="Java框架高级-（微服务与分布式）"><a href="#Java框架高级-（微服务与分布式）" class="headerlink" title="Java框架高级 （微服务与分布式）"></a><strong>Java框架高级 （微服务与分布式）</strong></h3><p>学习目标：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>掌握Maven安装和使用<span class="hljs-number">2.</span>了解SpringBoot和SpringCloud的关系和作用<span class="hljs-number">3.</span>掌握SpringBoot基础原理<span class="hljs-number">4.</span>掌握SpringBoot开发过程<span class="hljs-number">5.</span>掌握SpringBoot对JDBC支持<span class="hljs-number">6.</span>掌握SpringBoot对MyBatis集成应用<span class="hljs-number">7.</span>熟悉SpringBoot MVC开发<span class="hljs-number">8.</span>掌握SpringBoot集成Servlet、过滤器、拦截器<span class="hljs-number">9.</span>熟悉SpringCloud如何发布服务、查找、调用<span class="hljs-number">10.</span>掌握SpringCloud断路器、网关技术的使用<span class="hljs-number">11.</span>了解SpringCloud服务监控技术和使用</code></pre></div><p>知识点列表：</p><ul><li>​    SpringBoot开发环境搭建</li><li>​    SpringBoot启动加载原理</li><li>​    SpringBoot自动配置原理</li><li>​    SpringBoot参数注入</li><li>​    SpringBoot数据库连接</li><li>​    SpringBoot多数据源</li><li>​    SpringBoot动态数据源</li><li>​    SpringBoot整合JDBC技术</li><li>​    SpringBoot整合MyBatis技术</li><li>​    SpringBoot整合JPA技术</li><li>​    SpringBoot MVC环境搭建</li><li>​    SpringBoot MVC异常处理</li><li>​    SpringBoot MVC拦截器</li><li>​    SpringBoot MVC开发Restful</li><li>​    SpringBoot MVC开发Thymeleaf</li><li>​    SpringBoot MVC 开发JSP</li><li>​    SpringBoot 任务调度</li><li>​    SpringBoot 集成Servlet、过滤器等</li><li>​    SpringBoot SSM综合开发运用</li><li>​    SpringCloud概念</li><li>​    SpringCloud Eureka服务中心搭建</li><li>​    SpringCloud Eureka 服务注册</li><li>​    SpringCloud RestTemplate/Feign 服务调用</li><li>​    SpringCloud Ribbon集群负载和策略</li><li>​    SpringCloud Hystrix断路器概念和使用</li><li>​    SpringCloud actuator健康监控</li><li>​    SpringCloud Hystrix监控</li><li>​    SpringCloud Zuul网关概念和使用</li><li>​    SpringCloud Config统一配置</li><li>​    SpringCloud Bus配置刷新</li></ul><h3 id="Java容器化开发-Docker-与-K8s"><a href="#Java容器化开发-Docker-与-K8s" class="headerlink" title="Java容器化开发 (Docker 与 K8s)"></a><strong>Java容器化开发 (Docker 与 K8s)</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>熟练掌握容器化开发和部署技术</code></pre></div><p>知识点列表:</p><ul><li>​     容器与虚拟机比较</li><li>​     Docker环境安装</li><li>​     Docker命令使用</li><li>​     Docker容器化开发和部署技术</li><li>​     docker组件</li><li>​     docker安装</li><li>​     docker启动与停止</li><li>​     镜像相关命令</li><li>​     创建启动与查看容器</li><li>​     容器停止与启动和目录挂载</li><li>目录挂载查看IP与删除容器</li><li>mysql部署</li><li>tomcat部署</li><li>nginx部署</li><li>redis部署</li><li>迁移与备份</li><li>Dockerfile常用命令</li><li>Dockerfile构建jdk1.8镜像</li><li>Docker私有仓库的搭建与配置</li><li>Docker私有仓库镜像上传</li><li>​     K8s</li></ul><h3 id="架构设计与解决方案-框架补充"><a href="#架构设计与解决方案-框架补充" class="headerlink" title="架构设计与解决方案(框架补充)"></a><strong>架构设计与解决方案(框架补充)</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>具备架构设计能力<span class="hljs-number">2.</span>掌握常见解决方案</code></pre></div><p>知识点列表:</p><ul><li>​    SSO单点登录</li><li>​    分布式服务和集群搭建</li><li>​    RabbitMQ/ActiveMQ/Kafka消息服务解决方案、</li><li>​    Elasticsearch/Lucene搜索服务解决方案</li><li>​    Tomcat/Ngnix负载均衡解决方案</li><li>​    Shiro安全服务解决方案  Spring整合Shiro</li><li>​    Dubbo/zookeeper分布式解决方案、</li><li>​    Cache/Ehcache/Memcache/Redis缓存解决方案</li><li>​    FastDFS分布式文件处理方案</li><li>​    Netty </li><li>​    高并发处理方案</li><li>​    系统安全服务解决方案</li><li>​    JVM调优处理方案</li></ul><h3 id="项目实战训练"><a href="#项目实战训练" class="headerlink" title="项目实战训练"></a><strong>项目实战训练</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs plain">能独立开发具备交付能力的项目</code></pre></div><p>知识点列表:</p><ul><li>​    项目流程训练 ( 从需求阶段 → 项目交付 → 项目上线 → 项目升级维护 )</li></ul><h2 id="阶段四（前沿生态与团队协同）"><a href="#阶段四（前沿生态与团队协同）" class="headerlink" title="阶段四（前沿生态与团队协同）"></a><strong>阶段四（前沿生态与团队协同）</strong></h2><h3 id="前沿生态"><a href="#前沿生态" class="headerlink" title="前沿生态"></a><strong>前沿生态</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs plain">熟练运用前沿生态</code></pre></div><p>知识点列表:</p><ul><li>​    图像识别</li><li>​    语音识别</li><li>​    阿里云/百度云/华为云等云服务器生态</li><li>​    微信生态</li><li>​    支付宝生态</li><li>​    等其他常用组件</li></ul><h3 id="协同项目实战"><a href="#协同项目实战" class="headerlink" title="协同项目实战"></a><strong>协同项目实战</strong></h3><p>学习目标:</p><div class="hljs"><pre><code class="hljs plain">具备参与实施团队协同开发的能力</code></pre></div><p>知识点列表:</p><ul><li>​    项目协同开发训练</li><li>​    项目实战规范训练</li><li>​    项目流程训练 ( 从需求阶段 → 项目交付 → 项目上线 → 项目升级维护 )</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>学习路线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]对称的二叉树</title>
    <link href="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p><p><code>&nbsp; &nbsp; 1<br>&nbsp; &nbsp;/ \<br>&nbsp; 2 &nbsp; 2<br>&nbsp;/ \ / \<br>3 &nbsp;4 4 &nbsp;3</code><br>但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p><p><code>&nbsp; &nbsp; 1<br>&nbsp; &nbsp;/ \<br>&nbsp; 2 &nbsp; 2<br>&nbsp; &nbsp;\ &nbsp; \<br>&nbsp; &nbsp;3 &nbsp; &nbsp;3</code></p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>root = [1,2,2,3,4,4,3]<strong>输出：</strong>true</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>root = [1,2,2,null,3,null,3]<strong>输出：</strong>false</div></pre></div><p>&nbsp;</p><p><strong>限制：</strong></p><p><code>0 &lt;= 节点个数 &lt;= 1000</code></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题的做法可以采用递归实现。</p><p>对称二叉树定义： 对于树中 任意两个对称节点 <code>LL</code> 和 <code>RR</code> ，一定有：</p><ul><li><code>L.val</code> = <code>R.val</code> ：即此两对称节点值相等。</li><li><code>L.left.val</code> = <code>R.right.val</code>：即 <code>LL</code> 的 左子节点 和 <code>RR</code> 的 右子节点 对称；</li><li><code>L.right.val</code> = <code>R.left.val</code>：即 <code>LL</code> 的 右子节点 和 <code>RR</code> 的 左子节点 对称。</li></ul><p>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</p><img src="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/systree.png" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:40%;display: flex;margin: 0 auto;"><p>在python的语法中，我们可以用内部方法的方式来进行递归调用，代码如下：</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-comment"># class TreeNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.left = None</span><span class="hljs-comment">#         self.right = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; bool:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recur</span><span class="hljs-params">(l, r)</span>:</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> l <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> r: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> l <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> r <span class="hljs-keyword">or</span> l.val != r.val: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> recur(l.left, r.right) <span class="hljs-keyword">and</span> recur(l.right, r.left)        <span class="hljs-keyword">return</span> recur(root.left, root.right) <span class="hljs-keyword">if</span> root <span class="hljs-keyword">else</span> <span class="hljs-literal">True</span></code></pre></div><p>复杂度分析：</p><ul><li>时间复杂度 <code>O(N)</code> ： 其中 <code>N</code> 为二叉树的节点数量，每次执行 <code>recur()</code> 可以判断一对节点是否对称，因此最多调用 <code>N/2</code> 次 <code>recur()</code> 方法。</li><li>空间复杂度 <code>O(N)</code> ： 最差情况下，二叉树退化为链表，系统使用<code>O(N)</code> 大小的栈空间。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/solution/mian-shi-ti-28-dui-cheng-de-er-cha-shu-di-gui-qing/" target="_blank" rel="noopener">面试题28. 对称的二叉树</a></p></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]最小栈</title>
    <link href="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul>    <li><code>push(x)</code> —— 将元素 x 推入栈中。</li>    <li><code>pop()</code>&nbsp;—— 删除栈顶的元素。</li>    <li><code>top()</code>&nbsp;—— 获取栈顶元素。</li>    <li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>["MinStack","push","push","push","getMin","pop","top","getMin"][[],[-2],[0],[-3],[],[],[],[]]<strong>输出：</strong>[null,null,null,null,-3,null,0,-2]<strong>解释：</strong>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</div></pre></div><p><strong>提示：</strong></p><ul>    <li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p style="text-indent: 2em;">这道题目看起来很简单，很容易将题目理解不到位。如果我们仅设置一个变量min，来存储最小值的话，那么在进行栈的pop操作的时候，会发生栈内数值得变化，从而引起最小值发生变化。因此，只定义一个变量是不够的。或许你可以选择一个集合来存储动态发生的最小值，我们考虑用栈这个结构做min的存储。</p><p style="text-indent: 2em;">对于栈来说，如果一个元素 `a` 在入栈时，栈里有其它的元素 `b`, `c`, `d`，那么无论这个栈在之后经历了什么操作，只要 `a` 在栈中，`b`, `c`, `d` 就一定在栈中，因为在 `a` 被弹出之前，`b`, `c`, `d` 不会被弹出。</p><p style="text-indent: 2em;">因此，在操作过程中的任意一个时刻，只要栈顶的元素是 `a`，那么我们就可以确定栈里面现在的元素一定是 `a`, `b`, `c`, `d`。</p><p style="text-indent: 2em;">那么，我们可以在每个元素 `a` 入栈时把当前栈的最小值 `m` 存储起来。在这之后无论何时，如果栈顶元素是 `a`，我们就可以直接返回存储的最小值 `m`。</p><img src="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E5%B0%8F%E6%A0%88/min_stack.gif" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:80%;display: flex;margin: 0 auto;"><p style="text-indent: 2em;">按照上面的思路，我们只需要设计一个数据结构，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。</p><ul><li><p>当一个元素要入栈时，我们取当前辅助栈的栈顶存储的最小值，与当前元素比较得出最小值，将这个最小值插入辅助栈中；</p></li><li><p>当一个元素要出栈时，我们把辅助栈的栈顶元素也一并弹出；</p></li><li><p>在任意一个时刻，栈内元素的最小值就存储在辅助栈的栈顶元素中。</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.stack = []        self.minStack = [math.inf]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span><span class="hljs-params">(self, x: int)</span> -&gt; <span class="hljs-keyword">None</span>:</span>        self.stack.append(x)        self.minStack.append(min(self.minStack[<span class="hljs-number">-1</span>], x))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span><span class="hljs-params">(self)</span> -&gt; <span class="hljs-keyword">None</span>:</span>        self.stack.pop()        self.minStack.pop()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">top</span><span class="hljs-params">(self)</span> -&gt; int:</span>        <span class="hljs-keyword">return</span> self.stack[<span class="hljs-number">-1</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMin</span><span class="hljs-params">(self)</span> -&gt; int:</span>        <span class="hljs-keyword">return</span> self.minStack[<span class="hljs-number">-1</span>]</code></pre></div><p>复杂度分析</p><ul><li><p>时间复杂度：对于题目中的所有操作，时间复杂度均为<code>O(1)</code>。因为栈的插入、删除与读取操作都是<code>O(1)</code>，我们定义的每个操作最多调用栈操作两次。</p></li><li><p>空间复杂度：<code>O(n)</code>，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 <code>O(n)</code>。</p></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]爬楼梯问题带来的思考</title>
    <link href="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>假设你正在爬楼梯。需要 <em>n</em>&nbsp;阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong> 2<strong>输出：</strong> 2<strong>解释：</strong> 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong> 3<strong>输出：</strong> 3<strong>解释：</strong> 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</div></pre></div><h1 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h1><p style="text-indent: 2em;">我们用 f(x) 表示爬到第x级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子：</p><p>$$<br>f(x)=f(x−1)+f(x−2)<br>$$</p><p style="text-indent: 2em;">它意味着爬到第 x 级台阶的方案数是爬到第 x−1 级台阶的方案数和爬到第 x−2 级台阶的方案数的和。很好理解，因为每次只能爬 1 级或 2 级，所以 f(x) 只能从f(x−1) 和f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。</p><p style="text-indent: 2em;">看到这里我们不禁想起了一个与之相似的问题，那就是斐波那契数列问题！在解决这一类问题的时候我们可以选择递归和动态规划的方法实现，但是使用递归的方法牺牲比较大，时间复杂度成指数级，其中还包括了大量的重复计算。因此这里采取动态规划的思想来解决这一问题。</p><p>动态规划基本思路如下（解题四步曲）</p><ol><li>判断是否可用递归来解，可以的话进入步骤 2</li><li>分析在递归的过程中是否存在大量的重复子问题</li><li>采用备忘录的方式来存子问题的解以避免大量的重复计算（剪枝）</li><li>改用自底向上的方式来递推，即动态规划</li></ol><p class="note note-primary">采用备忘录的方式来存子问题的解以避免大量的重复计算既然以上中间子问题中存在着大量的重复计算，那么我们可以把这些中间结果给缓存住（可以用哈希表缓存）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">if</span> (n = <span class="hljs-number">1</span>) return1;    <span class="hljs-keyword">if</span> (n = <span class="hljs-number">2</span>) return2;    <span class="hljs-keyword">if</span> (map.get(n) != <span class="hljs-keyword">null</span>)  &#123;        <span class="hljs-keyword">return</span> map.get(n);    &#125;    <span class="hljs-keyword">int</span> result = climbStairs(n - <span class="hljs-number">1</span>) + climbStairs(n - <span class="hljs-number">2</span>);    map.put(n, result);    <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>这么缓存之后再看我们的递归树</p><img src="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83/640.png" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:50%;display: flex;margin: 0 auto;"><p style="text-indent: 2em;">可以看到通过缓存中间的数据，做了大量地剪枝的工作，同样的f(4),f(3),f(2)，都只算一遍了,省去了大量的重复计算，问题的规模从二叉树变成了单链表（即 n），时间复杂度变成了 O(n)，不过由于哈希表缓存了所有的子问题的结果，空间复杂度是 O(n)。</p><p class="note note-warning">改用自底向上的方式来递推，即动态规划我们注意到如下规律</p><div class="hljs"><pre><code class="hljs python">f(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>f(<span class="hljs-number">2</span>) = <span class="hljs-number">2</span>f(<span class="hljs-number">3</span>) = f(<span class="hljs-number">1</span>) + f(<span class="hljs-number">2</span>) = <span class="hljs-number">3</span>f(<span class="hljs-number">4</span>) = f(<span class="hljs-number">3</span>) + f(<span class="hljs-number">2</span>) = <span class="hljs-number">5</span>....f(n) = f(n<span class="hljs-number">-1</span>) + f(n<span class="hljs-number">-2</span>)</code></pre></div><p>所以只要依次自底向上求出 f(3),f(4),…,自然而然地就求出了 f(n)</p><img src="/2020/07/31/LeetCode-%E5%88%9D%E7%BA%A7-%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%9D%E8%80%83/641.png" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:70%;display: flex;margin: 0 auto;"><p style="text-indent: 2em;">f(n) 就是定义的每个子问题的状态（DP 状态），f(n) = f(n-1) + f(n-2) 就是状态转移方程，即 f(n) 由 f(n-1), f(n-2) 这两个状态转移而来,由于每个子问题只与它前面的两个状态，所以我们只要定义三个变量，自底向上不断循环迭代即可，如下:</p><h1 id="爬楼梯的代码实现"><a href="#爬楼梯的代码实现" class="headerlink" title="爬楼梯的代码实现"></a>爬楼梯的代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> n==<span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>        result = <span class="hljs-number">0</span>        pre = <span class="hljs-number">1</span>        nextt = <span class="hljs-number">2</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>, n+<span class="hljs-number">1</span>):            result = pre + nextt            pre = nextt            nextt = result        <span class="hljs-keyword">return</span> result</code></pre></div><p style="text-indent: 2em;">这样时间复杂度虽然还是O(n)，但空间复杂度只由于只定义了三个变量（result,pre,next）所以是常量 O(1)。</p><h1 id="第-N-个泰波那契数"><a href="#第-N-个泰波那契数" class="headerlink" title="第 N 个泰波那契数"></a>第 N 个泰波那契数</h1><div class="notranslate"><p>泰波那契序列&nbsp;T<sub>n</sub>&nbsp;定义如下：&nbsp;</p><p>T<sub>0</sub> = 0, T<sub>1</sub> = 1, T<sub>2</sub> = 1, 且在 n &gt;= 0&nbsp;的条件下 T<sub>n+3</sub> = T<sub>n</sub> + T<sub>n+1</sub> + T<sub>n+2</sub></p><p>给你整数&nbsp;<code>n</code>，请返回第 n 个泰波那契数&nbsp;T<sub>n </sub>的值。</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>n = 4<strong>输出：</strong>4<strong>解释：</strong>T_3 = 0 + 1 + 1 = 2T_4 = 1 + 1 + 2 = 4</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white"><strong>输入：</strong>n = 25<strong>输出：</strong>1389537</div></pre></div><p><strong>提示：</strong></p><ul>    <li><code>0 &lt;= n &lt;= 37</code></li>    <li>答案保证是一个 32 位整数，即&nbsp;<code>answer &lt;= 2^31 - 1</code>。</li></ul># 解题思路<p>与斐波那契数列问题非常相似，但是这个问题的状态方程由三种状态组成，即：<br>$$<br>f(x)=f(x−1)+f(x−2)+f(x-3)<br>$$</p><ul><li>如果 <code>n &lt; 3</code>，答案可直接得出。</li></ul><ul><li><p>否则，初始化前 3 个斐波那契数字 <code>x = 0, y = z = 1</code>，并执行 <code>n - 2</code> 步循环。循环的每一步：</p><p>令 <code>x = y</code>。令 <code>y = z</code>。令 <code>z = x + y + z</code>。</p></li></ul><ul><li>返回 <code>z</code>。</li></ul><p>代码实现如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tribonacci</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n == <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        first = <span class="hljs-number">0</span>        second = <span class="hljs-number">1</span>        third = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n<span class="hljs-number">-2</span>):            result = first + second + third            first = second            second = third            third = result        <span class="hljs-keyword">return</span> third</code></pre></div><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://mp.weixin.qq.com/s/PlGaIsbSixmXyyPDGI965g" target="_blank" rel="noopener">一文学会动态规划解题技巧</a></p></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>递归</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenCV快速入门</title>
    <link href="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p class="note note-warning">为什么使用Python-OpenCV ?</p><p class="note note-info">虽然python 很强大，而且也有自己的图像处理库PIL，但是相对于OpenCV 来讲，它还是弱小很多。跟很多开源软件一样OpenCV 也提供了完善的python 接口，非常便于调用。OpenCV 的稳定版是2.4.8，最新版是3.0，包含了超过2500 个算法和函数，几乎任何一个能想到的成熟算法都可以通过调用OpenCV 的函数来实现，超级方便。</p><h1 id="第1章-opencv基本操作"><a href="#第1章-opencv基本操作" class="headerlink" title="第1章 opencv基本操作"></a>第1章 opencv基本操作</h1><h2 id="1-1-打开图片"><a href="#1-1-打开图片" class="headerlink" title="1.1 打开图片"></a>1.1 打开图片</h2><p>使用函数<code>cv2.imread()</code> 读入图像。这幅图像应该在此程序的工作路径，或者给函数提供完整路径，第二个参数是要告诉函数应该如何读取这幅图片。</p><p>• <code>cv2.IMREAD_COLOR</code>：读入一副彩色图像。图像的透明度会被忽略， 这是默认参数。 </p><p>• <code>cv2.IMREAD_GRAYSCALE</code>：以灰度模式读入图像</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'lena.jpg'</span>,<span class="hljs-number">0</span>)</code></pre></div><p>PS：调用opencv，就算图像的路径是错的，OpenCV 也不会提醒你的，但是当你使用命<br>令print img时得到的结果是None。</p><h2 id="1-2-显示图片"><a href="#1-2-显示图片" class="headerlink" title="1.2 显示图片"></a>1.2 显示图片</h2><p>使用函数<code>cv2.imshow()</code> 显示图像。窗口会自动调整为图像大小。第一个参数是窗口的名字，其次才是我们的图像。你可以创建多个窗口，只要你喜欢，但是必须给他们不同的名字。</p><div class="hljs"><pre><code class="hljs python">cv2.imshow(<span class="hljs-string">'image'</span>,img)cv2.waitKey(<span class="hljs-number">0</span>) cv2.destroyAllWindows() <span class="hljs-comment">#dv2.destroyWindow(wname)</span></code></pre></div><ol><li><code>cv2.waitKey</code>顾名思义等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。</li><li><code>cv2.destroyAllWindow()</code>销毁所有窗口</li><li><code>cv2.destroyWindow(wname)</code>销毁指定窗口</li></ol><h2 id="1-3-保存图片"><a href="#1-3-保存图片" class="headerlink" title="1.3 保存图片"></a>1.3 保存图片</h2><p>使用函数cv2.imwrite(file，img，num)保存一个图像。第一个参数是要保存的文件名，第二个参数是要保存的图像。可选的第三个参数，它针对特定的格式：对于JPEG，其表示的是图像的质量，用0 - 100的整数表示，默认95;对于png ,第三个参数表示的是压缩级别。默认为3.<br>注意:</p><ol><li><code>cv2.IMWRITE_JPEG_QUALITY</code>类型为 long ,必须转换成 int</li><li><code>cv2.IMWRITE_PNG_COMPRESSION</code>, 从0到9 压缩级别越高图像越小。</li></ol><div class="hljs"><pre><code class="hljs python">cv2.imwrite(<span class="hljs-string">'1.png'</span>,img, [int( cv2.IMWRITE_JPEG_QUALITY), <span class="hljs-number">95</span>])cv2.imwrite(<span class="hljs-string">'1.png'</span>,img, [int(cv2.IMWRITE_PNG_COMPRESSION), <span class="hljs-number">9</span>])</code></pre></div><h2 id="1-4-图片操作"><a href="#1-4-图片操作" class="headerlink" title="1.4 图片操作"></a>1.4 图片操作</h2><h3 id="1-翻转图像"><a href="#1-翻转图像" class="headerlink" title="1. 翻转图像"></a>1. 翻转图像</h3><p>使用函数cv2.flip(img,flipcode)翻转图像，flipcode控制翻转效果。<br>flipcode = 0：沿x轴翻转<br>flipcode &gt; 0：沿y轴翻转<br>flipcode &lt; 0：x,y轴同时翻转</p><div class="hljs"><pre><code class="hljs python">imgflip = cv2.flip(img,<span class="hljs-number">1</span>)</code></pre></div><h3 id="2-复制图像"><a href="#2-复制图像" class="headerlink" title="2. 复制图像"></a>2. 复制图像</h3><div class="hljs"><pre><code class="hljs python">imgcopy = img.copy()</code></pre></div><h1 id="第2章-计算机视觉入门"><a href="#第2章-计算机视觉入门" class="headerlink" title="第2章 计算机视觉入门"></a>第2章 计算机视觉入门</h1><h2 id="2-11-tensorflow常量变量定义"><a href="#2-11-tensorflow常量变量定义" class="headerlink" title="2.11 tensorflow常量变量定义"></a>2.11 tensorflow常量变量定义</h2><p>定义一个data的常量，取值为2</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfdata1 = tf.constant(<span class="hljs-number">2</span>,dtype=tf.int32)session = tf.Session()print(data1)print(session.run(data1))</code></pre></div><p>输出结果如下：</p><div class="hljs"><pre><code class="hljs python">Tensor(<span class="hljs-string">"Const:0"</span>, shape=(), dtype=int32)<span class="hljs-number">2</span></code></pre></div><p>直接输出data1对象，并不能输出2，而是输出data1的tensorflow描述信息。</p><p>在定义一个变量，命名为var。像其他语言一样，要是有变量之前，要对该变量进行初始化。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfdata2 = tf.Variable(<span class="hljs-number">10</span>,name=<span class="hljs-string">'var'</span>)session = tf.Session()init = tf.global_variables_initializer() <span class="hljs-comment">#初始化</span>session.run(init)print(session.run(data2))</code></pre></div><p>先初始化变量，然后再输出变量：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">10</span></code></pre></div><h2 id="2-12-tensorflow运算原理"><a href="#2-12-tensorflow运算原理" class="headerlink" title="2.12 tensorflow运算原理"></a>2.12 tensorflow运算原理</h2><p>tensorflow的实质：张量tensor + 计算图graphs</p><p>张量表示的就是数据，可以是常量，可以是变量</p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/p1.jpg" srcset="/img/loading.gif" alt="img" style="zoom: 25%;"><p>本质 tf = tensor + 计算图</p><p>tensor数据，op可以是赋值运算或加减运算，计算图就是张量和运算一起的结构</p><p>在tf中，所有的计算图(graphs)都要放在会话(session)中来执行，所有session是执行的核心，可以理解为运算的一个交互环境。需要把当前的交互环境放到session中，使用它的run()方法。比如上一个例子中的：</p><div class="hljs"><pre><code class="hljs python">session.run(data1) <span class="hljs-comment">#data1为张量</span>session.run(init) <span class="hljs-comment">#init理解为op</span></code></pre></div><p>最后，使用完session后要关闭</p><div class="hljs"><pre><code class="hljs python">session.close()</code></pre></div><p>如果不主动关闭session的话，可以使用with关键字</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfdata = tf.constant(<span class="hljs-string">'hello world!'</span>)session = tf.Session()<span class="hljs-keyword">with</span> session:    out = session.run(data)    print(out)</code></pre></div><h2 id="2-13-常量变量的四则运算"><a href="#2-13-常量变量的四则运算" class="headerlink" title="2.13 常量变量的四则运算"></a>2.13 常量变量的四则运算</h2><p>常量的四则运算</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfdata1 = tf.constant(<span class="hljs-number">6</span>)data2 = tf.constant(<span class="hljs-number">2</span>)dataAdd = tf.add(data1,data2) <span class="hljs-comment">#加法</span>dataMultiply = tf.multiply(data1,data2) <span class="hljs-comment">#乘法</span>dataSubtraction = tf.subtract(data1,data2) <span class="hljs-comment">#减法</span>dataDivision = tf.divide(data1,data2) <span class="hljs-comment">#除法</span><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:    print(session.run(dataAdd))    print(session.run(dataMultiply))    print(session.run(dataSubtraction))    print(session.run(dataDivision))print(<span class="hljs-string">"End!............"</span>)</code></pre></div><p>输出结果：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">8</span><span class="hljs-number">12</span><span class="hljs-number">4</span><span class="hljs-number">3.0</span>End!............</code></pre></div><p>常量与变量的四则运算</p><div class="hljs"><pre><code class="hljs python">data1 = tf.constant(<span class="hljs-number">6</span>) data2 = tf.Variable(<span class="hljs-number">2</span>) <span class="hljs-comment">#改为变量</span>dataAdd = tf.add(data1,data2)dataMultiply = tf.multiply(data1,data2)dataSubtraction = tf.subtract(data1,data2)dataDivision = tf.divide(data1,data2)init  = tf.global_variables_initializer() <span class="hljs-comment">#初始化</span><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:    session.run(init)  <span class="hljs-comment">#初始化</span>    print(session.run(dataAdd))    print(session.run(dataMultiply))    print(session.run(dataSubtraction))    print(session.run(dataDivision))print(<span class="hljs-string">"End!............"</span>)</code></pre></div><p>输出结构与上面的相同</p><p>下面说下assign()函数的使用：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfnum1 = tf.Variable(tf.constant(<span class="hljs-number">6</span>)) <span class="hljs-comment">#tensor</span>num2 = tf.Variable(tf.constant(<span class="hljs-number">3</span>)) <span class="hljs-comment">#tensor</span>dataMultiply1 = tf.multiply(num1,num2) <span class="hljs-comment">#op-&gt;graphs</span>dataMultiply2 = tf.multiply(num1,num2) <span class="hljs-comment">#op-&gt;graphs</span><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:    session.run(tf.global_variables_initializer())    print(session.run(dataMultiply1))    print(<span class="hljs-string">'DataCopy: '</span>, session.run(tf.assign(num2,dataMultiply1))) <span class="hljs-comment">#将dataMultiply1的结果赋值给num2中</span>    print(session.run(dataMultiply2))</code></pre></div><p>事实上，<code>tf.assign(ref, new_value)</code>函数返回的结果就是参数中的<code>new_value</code>，因此我们只需要用<code>ref</code>来接收返回值也可以达到直接更新的效果。上图中可以很好的看清tensorflow的执行原理。</p><p>下面说下eval()的使用：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfnum1 = tf.Variable(tf.constant(<span class="hljs-number">3</span>)) <span class="hljs-comment">#tensor</span>num2 = tf.Variable(tf.constant(<span class="hljs-number">2</span>)) <span class="hljs-comment">#tensor</span>dataMultiply1 = tf.multiply(num1,num2) <span class="hljs-comment">#op-&gt;graphs</span>dataMultiply2 = tf.multiply(num1,num2) <span class="hljs-comment">#op-&gt;graphs</span><span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:    session.run(tf.global_variables_initializer())    print(session.run(dataMultiply1))    print(<span class="hljs-string">'DataCopy: '</span>, session.run(tf.assign(num2,dataMultiply1))) <span class="hljs-comment">#将dataMultiply1的结果赋值给num2中</span>    print(<span class="hljs-string">'Eval: '</span>,tf.assign(num2,dataMultiply1).eval())    print(session.run(dataMultiply2))</code></pre></div><p>输出结果：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">6</span>DataCopy:  <span class="hljs-number">6</span>Eval:  <span class="hljs-number">18</span><span class="hljs-number">54</span></code></pre></div><p>eval() <strong><em>其实就是tf.Tensor的Session.run() 的另外一种写法</em></strong>，但两者有差别</p><ul><li>eval(): 将字符串string对象转化为有效的表达式参与求值运算返回计算结果</li><li>eval()也是启动计算的一种方式。基于Tensorflow的基本原理，首先需要定义图，然后计算图，其中计算图的函数常见的有run()函数，如sess.run()。同样eval()也是此类函数，</li><li>要注意的是，eval()只能用于tf.Tensor类对象，也就是有输出的Operation。对于没有输出的Operation, 可以用.run()或者Session.run()；Session.run()没有这个限制。</li></ul><p>placeholder的使用</p><div class="hljs"><pre><code class="hljs python">data1 = tf.placeholder(tf.float32)data2 = tf.placeholder(tf.float32)dataAdd = tf.add(data1,data2)<span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> session:    print(session.run(dataAdd,feed_dict=&#123;data1:<span class="hljs-number">6</span>,data2:<span class="hljs-number">2</span>&#125;))    <span class="hljs-comment">#1 dataAdd 2 data(feed_dict=&#123;1:6,2:2&#125;)</span></code></pre></div><p>输出：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">8.0</span></code></pre></div><h2 id="2-14-矩阵基础"><a href="#2-14-矩阵基础" class="headerlink" title="2.14 矩阵基础"></a>2.14 矩阵基础</h2><p>详细见numpy教程</p><h1 id="第3章-计算机视觉加强之几何变换"><a href="#第3章-计算机视觉加强之几何变换" class="headerlink" title="第3章 计算机视觉加强之几何变换"></a>第3章 计算机视觉加强之几何变换</h1><h2 id="3-1-图片缩放"><a href="#3-1-图片缩放" class="headerlink" title="3.1 图片缩放"></a>3.1 图片缩放</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]channel = imgInfo[<span class="hljs-number">2</span>]factor = <span class="hljs-number">0.5</span><span class="hljs-comment">#1. 放大 缩小 2. 等比例 非等比例缩放</span>dstHeight = int(height*factor)dstWidth = int(width*factor)dst = cv2.resize(img, (dstWidth, dstHeight))cv2.imshow(<span class="hljs-string">'Pineapple'</span>,dst)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows() <span class="hljs-comment"># esc可退出，不然会busy</span></code></pre></div><p>图片的宽高都乘以了一个缩放因子<code>factor</code>实现图片的等比例缩放</p><p>下面讲解图像的四种缩放方法：</p><ol><li><strong>最近邻域插值</strong> </li><li><strong>双线性插值</strong> </li><li><strong>像素关系重采样</strong> </li><li><strong>立方插值</strong></li></ol><h4 id="1-最近邻域插值"><a href="#1-最近邻域插值" class="headerlink" title="1.最近邻域插值"></a>1.最近邻域插值</h4><p>假设有一个10×20 的图片，我们要缩放到 5×10（记为dst），那么dst中的每一个点都来自于原图片，比如dst中（1，2）&lt;– (2，4)</p><p>那么我们如何计算并找到这些点呢？</p><p>即已知dst中的点，要求出原图片中的点。这里有个公式：</p><p>$$<br>srcX=dstX* (srcWidth/dstWidth)<br>$$<br>例如，想要计算目标图片中 x为 1 的点对应的是原图像中的哪个点的x值<br>srcX = 1 * （10 / 5） = 2<br> 同样的，<br>$$<br>srcY = dstY * (srcHeight/dstHeight)<br>$$<br>srcY = 2 * (20 / 10) = 4<br>有时，我们计算出来的结果并不为整数，例如 12.3 ，则取最近的像素 12，<br>这种方法即为最近临域。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#1. info</span>img = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)imgInfo = img.shapeprint(imgInfo)height = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]dstHeight = int(height/<span class="hljs-number">2</span>)dstWidth = int(width/<span class="hljs-number">2</span>)<span class="hljs-comment">#最近邻域插值</span>dstImg = np.zeros((dstHeight, dstWidth, <span class="hljs-number">3</span>), np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,dstHeight): <span class="hljs-comment">#row number</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,dstWidth): <span class="hljs-comment">#column number</span>        iNew = int(i*(height*<span class="hljs-number">1.0</span>/dstHeight))        jNew = int(j*(width*<span class="hljs-number">1.0</span>/dstWidth))        dstImg[i, j] = img[iNew, jNew]print(dstImg.shape)cv2.imshow(<span class="hljs-string">'dest'</span>, dstImg)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><p>其他算法在这里不介绍</p><h2 id="3-2-图片剪切"><a href="#3-2-图片剪切" class="headerlink" title="3.2 图片剪切"></a>3.2 图片剪切</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)imgInfo = img.shapeprint(imgInfo)dst = img[<span class="hljs-number">100</span>:<span class="hljs-number">200</span>, <span class="hljs-number">100</span>:<span class="hljs-number">300</span>]cv2.imshow(<span class="hljs-string">'dst'</span>,dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="https://img-blog.csdnimg.cn/20190629095803910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0OTM0ODk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom: 33%;"><h2 id="3-3-图片移位"><a href="#3-3-图片移位" class="headerlink" title="3.3 图片移位"></a>3.3 图片移位</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'src'</span>, img)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]matShift = np.float32([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">200</span>]])<span class="hljs-comment">#2*3</span><span class="hljs-comment"># 1 data 2 mat 3 info</span><span class="hljs-comment">#完成位移和矩阵的运算</span>dst = cv2.warpAffine(img, matShift, (height, width))cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="https://img-blog.csdnimg.cn/20190116141505171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxMDQzMDE=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img" style="zoom: 50%;"><p>API级别的移位实现原理：</p><p><img src="https://img-blog.csdnimg.cn/20190629095816576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0OTM0ODk=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>代码实现图像的位移，其实就是将x,y分别移动位置：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'src'</span>, img)imgInfo = img.shapedst = np.zeros(img.shape, np.uint8)height = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width<span class="hljs-number">-100</span>):        dst[i, j+<span class="hljs-number">100</span>] = img[i, j]cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="https://img-blog.csdnimg.cn/20190116141642584.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTAxMDQzMDE=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img" style="zoom:50%;"><h2 id="3-4-图像镜像"><a href="#3-4-图像镜像" class="headerlink" title="3.4 图像镜像"></a>3.4 图像镜像</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'src'</span>, img)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]channel = imgInfo[<span class="hljs-number">2</span>]newImgInfo = (height*<span class="hljs-number">2</span>, width, channel)dst = np.zeros(newImgInfo, np.uint8)<span class="hljs-comment">#反转图像填充</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,width):        dst[i, j] = img[i, j]        <span class="hljs-comment"># x不变 y = 2*h -y -1</span>        dst[height*<span class="hljs-number">2</span>-i<span class="hljs-number">-1</span>, j] = img[i, j]<span class="hljs-comment">#添加水平分割线</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,width):    dst[height, i] = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="https://img-blog.csdnimg.cn/20190813181604741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYzNTY0Nw==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:33%;"><h2 id="3-5-图片仿射变换"><a href="#3-5-图片仿射变换" class="headerlink" title="3.5 图片仿射变换"></a>3.5 图片仿射变换</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'src'</span>, img)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-comment">#src中的3个点转换到dst中的3个新点，然后确定唯一的图像平面</span>matSrc = np.float32([[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, height<span class="hljs-number">-1</span>], [width<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>]])matDst = np.float32([[<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], [<span class="hljs-number">300</span>, height<span class="hljs-number">-200</span>], [width<span class="hljs-number">-300</span>, <span class="hljs-number">100</span>]])<span class="hljs-comment">#组合</span>matAffine = cv2.getAffineTransform(matSrc, matDst)dst = cv2.warpAffine(img, matAffine, (width, height))cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/70.jpg" srcset="/img/loading.gif" alt="img" style="zoom: 67%;"><h2 id="3-6-图片旋转"><a href="#3-6-图片旋转" class="headerlink" title="3.6 图片旋转"></a>3.6 图片旋转</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'src'</span>, img)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-comment">#Three parameter: center, angle, scale</span>matRotate = cv2.getRotationMatrix2D((height*<span class="hljs-number">0.5</span>, width*<span class="hljs-number">0.5</span>), <span class="hljs-number">45</span>, <span class="hljs-number">0.5</span>)dst = cv2.warpAffine(img,matRotate,(height, width))cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/80.jpg" srcset="/img/loading.gif" alt="img" style="zoom: 67%;"><h1 id="第4章-计算机视觉加强之图像特效"><a href="#第4章-计算机视觉加强之图像特效" class="headerlink" title="第4章 计算机视觉加强之图像特效"></a>第4章 计算机视觉加强之图像特效</h1><h2 id="4-1-图像灰度处理"><a href="#4-1-图像灰度处理" class="headerlink" title="4.1 图像灰度处理"></a>4.1 图像灰度处理</h2><h3 id="方法一：通过imread读取灰度图片"><a href="#方法一：通过imread读取灰度图片" class="headerlink" title="方法一：通过imread读取灰度图片"></a>方法一：通过imread读取灰度图片</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img0 = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">0</span>)print(img0.shape)cv2.imshow(<span class="hljs-string">'img0'</span>, img0)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h3 id="方法二：通过cvtColor方法"><a href="#方法二：通过cvtColor方法" class="headerlink" title="方法二：通过cvtColor方法"></a>方法二：通过cvtColor方法</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)dst = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h3 id="方法三：RGB取均值方法"><a href="#方法三：RGB取均值方法" class="headerlink" title="方法三：RGB取均值方法"></a>方法三：RGB取均值方法</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-comment">#RGB三值取相同=gray</span>dst = np.zeros((height, width,<span class="hljs-number">3</span> ), np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width):        (B, G, R) = img[i, j]        mean = (int(B)+int(G)+int(R))/<span class="hljs-number">3</span>        dst[i, j] = np.uint8(mean)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h3 id="方法四：心理学公式"><a href="#方法四：心理学公式" class="headerlink" title="方法四：心理学公式"></a>方法四：心理学公式</h3><p>$$<br>Gray = R * 0.299 + G * 0.587 + B * 0.114<br>$$</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-comment">#RGB三值取相同=gray</span>dst = np.zeros((height, width,<span class="hljs-number">3</span> ), np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width):        (B, G, R) = img[i, j]        <span class="hljs-comment"># R = np.float32(R)</span>        <span class="hljs-comment"># G = np.float32(G)</span>        <span class="hljs-comment"># B = np.float32(B)</span>        mean = R * <span class="hljs-number">0.299</span> + G * <span class="hljs-number">0.587</span> + B * <span class="hljs-number">0.114</span>        dst[i, j] = np.uint8(mean)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h2 id="4-2-算法优化"><a href="#4-2-算法优化" class="headerlink" title="4.2 算法优化"></a>4.2 算法优化</h2><p>为什么我们这么强调灰度处理？原因如下：</p><ol><li>灰度很重要</li><li>灰度处理很基础</li><li>能体现出实时性</li></ol><p>鉴于此，我们还可以在算法的性能上继续进行优化，往往的经验告诉我们定点数运算快于浮点数运算，加减法运算快于乘除法运算，其中位运算更快。</p><h2 id="4-3-图片颜色反转"><a href="#4-3-图片颜色反转" class="headerlink" title="4.3 图片颜色反转"></a>4.3 图片颜色反转</h2><p>颜色反转就是用255减去当前的灰度值</p><p>彩色图片的颜色反转：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]dst = np.zeros((height, width, <span class="hljs-number">3</span>), np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width):        pixels = img[i, j]        dst[i, j] = <span class="hljs-number">255</span> - pixels <span class="hljs-comment">#可以直接用255减去，不能写成元组的形式</span>cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/90.jpg" srcset="/img/loading.gif" alt="bgr反转图像"></p><p>灰度图片的颜色反转：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-comment">#使用cvtColor函数转化为灰度图像</span>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)dst = np.zeros((height, width, <span class="hljs-number">3</span>), np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width):        pixels = gray[i, j]        dst[i, j] = <span class="hljs-number">255</span> - pixelscv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/100.jpg" srcset="/img/loading.gif" alt="图像反转"></p><h2 id="4-4-马赛克效果"><a href="#4-4-马赛克效果" class="headerlink" title="4.4 马赛克效果"></a>4.4 马赛克效果</h2><p>马赛克效果就是将原图进行了一定形状的分割。在每个分割出来的形状中用同一个颜色填充得到。而这个颜色一般取分割得到形状的中心点像素的颜色。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'timg.jpg'</span>, <span class="hljs-number">1</span>)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]<span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>, <span class="hljs-number">300</span>):    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>):        <span class="hljs-keyword">if</span> m % <span class="hljs-number">20</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> n % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>):                    (B, G, R) = img[m, n]                    img[i+m, j+n] = (B, G, R)cv2.imshow(<span class="hljs-string">'dst'</span>, img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20190610233841994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x0MzI2MDMwNDM0,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="4-5-毛玻璃效果"><a href="#4-5-毛玻璃效果" class="headerlink" title="4.5 毛玻璃效果"></a>4.5 毛玻璃效果</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> randomimg = cv2.imread(<span class="hljs-string">'timg.jpg'</span>,<span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'img'</span>, img)imgInfo = img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]dst = np.zeros((height, width, <span class="hljs-number">3</span>), np.uint8)mm = <span class="hljs-number">100</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width):        num = int(random.random()*mm)        <span class="hljs-keyword">if</span> i + num &gt;= height <span class="hljs-keyword">or</span> j + num &gt;= width: <span class="hljs-comment">#######</span>            (B, G, R) = img[i - num, j - num]        <span class="hljs-keyword">else</span>:            (B, G, R) = img[i + num, j + num]        dst[i, j] = (B, G, R)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><p>注释的地方是为了保证边界处的宽高像素不会产生矩阵越界的错误，这里需要注意！</p><img src="https://img-blog.csdnimg.cn/20190610234327503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x0MzI2MDMwNDM0,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:67%;"><h2 id="4-6-图像融合效果"><a href="#4-6-图像融合效果" class="headerlink" title="4.6 图像融合效果"></a>4.6 图像融合效果</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img1 = cv2.imread(<span class="hljs-string">'../timg.jpg'</span>, <span class="hljs-number">1</span>)img2 = cv2.imread(<span class="hljs-string">'../timgjpg.jpg'</span>, <span class="hljs-number">1</span>)dst = cv2.addWeighted(img1, <span class="hljs-number">0.5</span>, img2, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre></div><p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/110.jpg" srcset="/img/loading.gif" alt="clipboard.png"></p><h2 id="4-7-Canny边缘检测"><a href="#4-7-Canny边缘检测" class="headerlink" title="4.7 Canny边缘检测"></a>4.7 Canny边缘检测</h2><p>Canny边缘检测是一种非常流行的边缘检测算法，是John Canny在1986年提出的。它是一个多阶段的算法，即由多个步骤构成。</p><ol><li><strong>图像降噪</strong></li><li><strong>计算图像梯度</strong></li><li><strong>非极大值抑制</strong></li><li><strong>阈值筛选</strong></li></ol><p>OpenCV-Python中Canny函数的原型为：</p><div class="hljs"><pre><code class="hljs python">edge = cv2.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient ]]])</code></pre></div><p>必要参数：</p><ul><li>第一个参数是需要处理的原图像，该图像必须为单通道的灰度图；</li><li>第二个参数是阈值1；</li><li>第三个参数是阈值2。</li></ul><p>其中较大的阈值2用于检测图像中明显的边缘，但一般情况下检测的效果不会那么完美，边缘检测出来是断断续续的。所以这时候用较小的第一个阈值用于将这些间断的边缘连接起来。</p><p>可选参数中apertureSize就是Sobel算子的大小。而L2gradient参数是一个布尔值，如果为真，则使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放），否则使用L1范数（直接将两个方向导数的绝对值相加）。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  img = cv2.imread(<span class="hljs-string">"D:/lion.jpg"</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 由于Canny只能处理灰度图，所以将读取的图像转成灰度图</span>img = cv2.GaussianBlur(img,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>) <span class="hljs-comment"># 用高斯平滑处理原图像降噪。若效果不好可调节高斯核大小</span>canny = cv2.Canny(img, <span class="hljs-number">50</span>, <span class="hljs-number">150</span>)     <span class="hljs-comment"># 调用Canny函数，指定最大和最小阈值，其中apertureSize默认为3。</span>cv2.imshow(<span class="hljs-string">'Canny'</span>, canny)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre></div><p>这个程序只是静态的，下面是可以在运行时调整阈值大小的程序。其代码如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">CannyThreshold</span><span class="hljs-params">(lowThreshold)</span>:</span>    detected_edges = cv2.GaussianBlur(gray,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),<span class="hljs-number">0</span>)    detected_edges =cv2.Canny(detected_edges,lowThreshold,lowThreshold*ratio,apertureSize = kernel_size)    dst = cv2.bitwise_and(img,img,mask = detected_edges)  <span class="hljs-comment"># just add some colours to edges from original image.</span>    cv2.imshow(<span class="hljs-string">'canny demo'</span>,dst)lowThreshold = <span class="hljs-number">0</span>max_lowThreshold = <span class="hljs-number">100</span>ratio = <span class="hljs-number">3</span>kernel_size = <span class="hljs-number">3</span>img = cv2.imread(<span class="hljs-string">'D:/lion.jpg'</span>)gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)cv2.namedWindow(<span class="hljs-string">'canny demo'</span>)cv2.createTrackbar(<span class="hljs-string">'Min threshold'</span>,<span class="hljs-string">'canny demo'</span>,lowThreshold, max_lowThreshold, CannyThreshold)CannyThreshold(<span class="hljs-number">0</span>)  <span class="hljs-comment"># initialization</span><span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">0</span>) == <span class="hljs-number">27</span>:    cv2.destroyAllWindows()</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20190911172931419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhb2hhb211YQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"></p><h2 id="4-8-Sobel边缘检测"><a href="#4-8-Sobel边缘检测" class="headerlink" title="4.8 Sobel边缘检测"></a>4.8 Sobel边缘检测</h2><p>Sobel边缘检测算法比较简单，实际应用中效率比canny边缘检测效率要高，但是边缘不如Canny检测的准确，Sobel算子是高斯平滑与微分操作的结合体，所以其抗噪声能力很强，用途较多。尤其是效率要求较高，而对细纹理不太关系的时候，<strong>对于一个彩色图要先把它转换为灰度图</strong></p><p><img src="https://img-blog.csdnimg.cn/20190514114056525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzMzNjQx,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190514114110308.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzMzNjQx,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>核心语句</p><div class="hljs"><pre><code class="hljs python">Sobel_x_or_y = cv2.Sobel(src, ddepth, dx, dy, dst, ksize, scale, delta, borderType)</code></pre></div><p>参数：<br>第一个参数是需要处理的图像；<br>第二个参数是图像的深度，-1表示采用的是与原图像相同的深度。目标图像的深度必须大于等于原图像的深度；<br>dx和dy表示的是求导的阶数，0表示这个方向上没有求导，一般为0、1、2。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'../timg.jpg'</span>, <span class="hljs-number">0</span>)x = cv2.Sobel(img, cv2.CV_16S, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)y = cv2.Sobel(img, cv2.CV_16S, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># cv2.convertScaleAbs(src[, dst[, alpha[, beta]]])</span><span class="hljs-comment"># 可选参数alpha是伸缩系数，beta是加到结果上的一个值，结果返回uint类型的图像</span>Scale_absX = cv2.convertScaleAbs(x)  <span class="hljs-comment"># convert 转换  scale 缩放</span>Scale_absY = cv2.convertScaleAbs(y)result = cv2.addWeighted(Scale_absX, <span class="hljs-number">0.5</span>, Scale_absY, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">"result"</span>, <span class="hljs-number">0</span>)cv2.imshow(<span class="hljs-string">'result'</span>, result)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre></div><img src="https://img-blog.csdnimg.cn/20190514114342607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMzMzNjQx,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:50%;"><p>在Sobel函数的第二个参数这里使用了cv2.CV_16S。因为OpenCV文档中对Sobel算子的介绍中有这么一句：“in the case of 8-bit input images it will result in truncated derivatives”。即Sobel函数求完导数后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以Sobel建立的图像位数不够，会有截断。因此要使用16位有符号的数据类型，即cv2.CV_16S。</p><p>在经过处理后，别忘了用convertScaleAbs()函数将其转回原来的uint8形式。否则将无法显示图像，而只是一副灰色的窗口。</p><div class="hljs"><pre><code class="hljs python">result = cv2.addWeighted(src1, alpha, src2, beta, gamma[, dst[, dtype]])</code></pre></div><p>其中alpha是第一幅图片中元素的权重，beta是第二个的权重，gamma是加到最后结果上的一个值。</p><h2 id="4-9-浮雕和雕刻效果"><a href="#4-9-浮雕和雕刻效果" class="headerlink" title="4.9 浮雕和雕刻效果"></a>4.9 浮雕和雕刻效果</h2><p><strong>原理：</strong> 根据像素与周围像素的差值确定滤波后的像素值，差别较大的像素（边缘点通常像素差别较大）像素值较大，在灰度图中表现为较亮，边缘凸显，形成浮雕状，然后加上一个灰度偏移值128，作为图片的整体底色。</p><p><strong>实现：</strong> 浮雕算法是对图像的每一个点进行卷积处理，采用的矩阵如下：<br>$$<br>[[1,0],<br>[0,-1]]<br>$$<br><strong>雕刻效果卷积核算子：</strong><br>$$<br>[[-1,0],<br>[0,1]]<br>$$</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 浮雕和雕刻</span>img = cv2.imread(<span class="hljs-string">'../timgjpg.jpg'</span>, <span class="hljs-number">1</span>)gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)imgInfo = gray_img.shapeheight = imgInfo[<span class="hljs-number">0</span>]width = imgInfo[<span class="hljs-number">1</span>]relief_filter = [[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>]]sculpt_filter = [[<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]]relief_img = np.zeros([height<span class="hljs-number">-1</span>, width<span class="hljs-number">-1</span>], np.uint8)sculpt_img = np.zeros([height<span class="hljs-number">-1</span>, width<span class="hljs-number">-1</span>], np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, height<span class="hljs-number">-1</span>):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width<span class="hljs-number">-1</span>):        <span class="hljs-comment">#relief effect</span>        relief_value = np.sum(gray_img[i:i + <span class="hljs-number">2</span>, j:j + <span class="hljs-number">2</span>] * relief_filter) + <span class="hljs-number">128</span>        relief_value = <span class="hljs-number">255</span> <span class="hljs-keyword">if</span> relief_value &gt; <span class="hljs-number">255</span> <span class="hljs-keyword">else</span> relief_value        relief_value = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> relief_value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> relief_value        relief_img[i, j] = relief_value        <span class="hljs-comment">#sculpt effect</span>        sculpt_value = np.sum(gray_img[i:i + <span class="hljs-number">2</span>, j:j + <span class="hljs-number">2</span>] * sculpt_filter) + <span class="hljs-number">128</span>        sculpt_value = <span class="hljs-number">255</span> <span class="hljs-keyword">if</span> sculpt_value &gt; <span class="hljs-number">255</span> <span class="hljs-keyword">else</span> sculpt_value        sculpt_value = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> sculpt_value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> sculpt_value        sculpt_img[i, j] = sculpt_valuecv2.namedWindow(<span class="hljs-string">'Relief Image'</span>, <span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">'Sculpt Image'</span>, <span class="hljs-number">0</span>)cv2.imshow(<span class="hljs-string">'Relief Image'</span>, relief_img)cv2.imshow(<span class="hljs-string">'Sculpt Image'</span>, sculpt_img)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><img src="https://img-blog.csdnimg.cn/20190418191709932.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3MzY2NjI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img" style="zoom: 50%;"><img src="https://img-blog.csdnimg.cn/20190418191906436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3MzY2NjI=,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img" style="zoom:50%;"><h2 id="4-10-颜色映射"><a href="#4-10-颜色映射" class="headerlink" title="4.10 颜色映射"></a>4.10 颜色映射</h2><p>图像颜色映射的实质是色彩通道的变换计算，即通过对图像的颜色通道值进行修改实现图像的颜色映射，说白了就是用新的bgr值替换掉旧的bgr值。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npimage = cv2.imread(<span class="hljs-string">"wuhuan.jpg"</span>, <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'image'</span>, image)image_info = image.shapeheight = image_info[<span class="hljs-number">0</span>]width = image_info[<span class="hljs-number">1</span>]dst = np.zeros((height, width, <span class="hljs-number">3</span>), np.uint8)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(width):        (b, g, r) = image[i, j]        b = b * <span class="hljs-number">1.5</span>   <span class="hljs-comment">#蓝色增强</span>        <span class="hljs-keyword">if</span> b &gt; <span class="hljs-number">255</span>:            b = <span class="hljs-number">255</span>        dst[i, j] = (b, g, r)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)<span class="hljs-comment"># cv2.imshow("dst",dst)</span>cv2.waitKey()</code></pre></div><p>上述代码中，我们遍历原图像的像素点，并将像素点的蓝色通道值进行增强，具体来说，就是将bgr中的b（蓝色通道）值在原基础上乘以1.5。当然，颜色通道值的范围为0~255，因此对于乘积结果我们需要做范围判断，对于超过255的结果需要置为255。</p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/1502586-20200201133243421-246601062.png" srcset="/img/loading.gif" alt="img" style="zoom:50%;"><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/1502586-20200201133503935-1269129577.png" srcset="/img/loading.gif" alt="img" style="zoom:50%;"><h2 id="4-11-彩色映射"><a href="#4-11-彩色映射" class="headerlink" title="4.11 彩色映射"></a>4.11 彩色映射</h2><p>与图像颜色映射用于增强某个或某几个颜色通道值不同的是，图像彩色映射主要应用于灰度图，并利用色度图产生伪彩色图像。 </p><p>例如，假设我们想在地图上显示不同地区的温度。我们可以把地图上不同地区的温度数据叠加为灰度图像。其中，温度较低的地方用较暗的区域表示，温度较高的地区用较亮的区域表示。这样就形成了一个温度数据图像。这样的图像是很有意义的，我们能通过颜色的变化更好地感知不同区域温度的高地。除此之外，还有高度、压力、密度、湿度等我们都可以通过将其转换为彩色数据图像以实现数据的可视化。 </p><p> OpenCV中一共定义了12种色度图，可以应用于灰度图像，产生不同的伪彩色图像。</p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/1502586-20200202090339118-441973867.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;"><p>上图中显示了一个关于色度图的视觉表示及OpenCV中的对应数值，其中，颜色条从左到右分别表示灰度值从小到大，即越小的灰度值将呈现越靠左边的颜色。 </p><p>OpenCV中使用applyColorMap（src，colormap，dst=None）函数来产生伪彩色图像</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2image = cv2.imread(<span class="hljs-string">"wuhuan.jpg"</span>,<span class="hljs-number">1</span>)gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)cv2.imshow(<span class="hljs-string">'gray'</span>,gray)colormap=cv2.applyColorMap(gray,cv2.COLORMAP_JET)  <span class="hljs-comment">#彩色映射--制作伪彩色图像</span><span class="hljs-string">'''</span><span class="hljs-string">参数1 src：必选参数。表示输入的原图像数组，原图像必须为灰度图或者是CV_8UC1、CV_8UC的彩色图</span><span class="hljs-string">参数2 colormap：必选参数。用于设置图像彩色映射的参考色度图</span><span class="hljs-string">'''</span>cv2.imshow(<span class="hljs-string">'color'</span>,colormap)cv2.waitKey()</code></pre></div><p>效果图：</p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/1502586-20200202093755511-1472659532.png" srcset="/img/loading.gif" alt="img" style="zoom:50%;"><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/1502586-20200202093820857-1784080258.png" srcset="/img/loading.gif" alt="img" style="zoom:50%;"><h1 id="第5章-计算机视觉加强之图像绘制"><a href="#第5章-计算机视觉加强之图像绘制" class="headerlink" title="第5章 计算机视觉加强之图像绘制"></a>第5章 计算机视觉加强之图像绘制</h1><h2 id="5-1-形状绘制"><a href="#5-1-形状绘制" class="headerlink" title="5.1 形状绘制"></a>5.1 形状绘制</h2><h3 id="5-1-1-线段绘制"><a href="#5-1-1-线段绘制" class="headerlink" title="5.1.1 线段绘制"></a>5.1.1 线段绘制</h3><p>在使用OpenCV处理图像时，我们有时候会需要在图像上画线段、矩形等。OpenCV中使用</p><div class="hljs"><pre><code class="hljs python">line（img，pt1，pt2，color，thickness=<span class="hljs-literal">None</span>，lineType=<span class="hljs-literal">None</span>，shift=<span class="hljs-literal">None</span>）</code></pre></div><p>函数进行线段的绘制</p><ul><li>参数2和参数3 pt1，pt2：必选参数。线段的坐标点，分别表示起始点和终止点</li><li>参数4 color：必选参数。用于设置线段的颜色</li><li>参数5 thickness：可选参数。用于设置线段的宽度</li><li>参数6 lineType：可选参数。用于设置线段的类型，可选8（8邻接连接线-默认）、4（4邻接连接线）和cv2.LINE_AA 为抗锯齿</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npnew_ImageInfo = (<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">3</span>)dst = np.zeros(new_ImageInfo, np.uint8)cv2.line(dst, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">300</span>, <span class="hljs-number">300</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))cv2.line(dst, (<span class="hljs-number">290</span>, <span class="hljs-number">430</span>), (<span class="hljs-number">330</span>, <span class="hljs-number">305</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">30</span>)cv2.line(dst, (<span class="hljs-number">190</span>, <span class="hljs-number">430</span>), (<span class="hljs-number">230</span>, <span class="hljs-number">305</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">30</span>, cv2.LINE_AA)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h3 id="5-1-2-矩形绘制"><a href="#5-1-2-矩形绘制" class="headerlink" title="5.1.2 矩形绘制"></a>5.1.2 矩形绘制</h3><p>OpenCV中为我们提供了绘制矩形的函数</p><div class="hljs"><pre><code class="hljs python">rectangle（img，pt1，pt2，color，thickness=<span class="hljs-literal">None</span>，lineType=<span class="hljs-literal">None</span>，shift=<span class="hljs-literal">None</span>）</code></pre></div><ul><li>参数2和参数3 pt1，pt2：必选参数。矩形的顶点，分别表示顶点与对角顶点，即矩形的左上角与右下角（这两个顶点可以确定一个唯一的矩形）</li><li>参数4 color：必选参数。用于设置矩形的颜色</li><li>参数5 thickness：可选参数。用于设置矩形边的宽度，<strong><em>当值为负数时，表示对矩形进行填充</em></strong></li><li>参数6 lineType：可选参数。用于设置线段的类型，可选8（8邻接连接线-默认）、4（4邻接连接线）和cv2.LINE_AA 为抗锯齿</li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#矩形的绘制</span>new_ImageInfo = (<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">3</span>)dst = np.zeros(new_ImageInfo, np.uint8)cv2.rectangle(dst, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">300</span>, <span class="hljs-number">300</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>))cv2.rectangle(dst, (<span class="hljs-number">290</span>, <span class="hljs-number">430</span>), (<span class="hljs-number">330</span>, <span class="hljs-number">305</span>), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)cv2.rectangle(dst, (<span class="hljs-number">190</span>, <span class="hljs-number">430</span>), (<span class="hljs-number">230</span>, <span class="hljs-number">305</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h3 id="5-1-3-圆形绘制"><a href="#5-1-3-圆形绘制" class="headerlink" title="5.1.3 圆形绘制"></a>5.1.3 圆形绘制</h3><div class="hljs"><pre><code class="hljs python">cv2.circle(img, center, radius, color, thickness, lineType, shift)</code></pre></div><p><strong>img：</strong>要画的圆所在的矩形或图像</p><p><strong>center：</strong>圆心坐标</p><p><strong>radius：</strong>圆的半径值</p><p><strong>color：</strong>圆边框颜色，颜色值为BGR，即：（0，0，255）为红色</p><p><strong>thickness：</strong>圆边框大小，负值表示该圆是一个填充图形</p><p><strong>lineType：</strong>线条类型，三个参数可选0，4，8，感兴趣的亲测</p><p><strong>shift：</strong>圆心坐标和半径的小数点位数</p><p>【注】img、center、radius、color为必须参数，其它为可选项。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#圆形的绘制</span>new_ImageInfo = (<span class="hljs-number">500</span>, <span class="hljs-number">500</span>, <span class="hljs-number">3</span>)dst = np.zeros(new_ImageInfo, np.uint8)cv2.circle(dst, (<span class="hljs-number">100</span>, <span class="hljs-number">90</span>), <span class="hljs-number">50</span>, (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">-1</span>)cv2.circle(dst, (<span class="hljs-number">190</span>, <span class="hljs-number">250</span>), <span class="hljs-number">100</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)cv2.imshow(<span class="hljs-string">'dst'</span>, dst)cv2.waitKey(<span class="hljs-number">0</span>)</code></pre></div><h3 id="5-1-4-椭圆形绘制"><a href="#5-1-4-椭圆形绘制" class="headerlink" title="5.1.4 椭圆形绘制"></a>5.1.4 椭圆形绘制</h3><div class="hljs"><pre><code class="hljs python">cv2.ellipse(img, center, axes, rotateAngle, startAngle, endAngle, color, thickness, lineType, shift)</code></pre></div><p><strong>img：</strong>要画的椭圆所在的矩形或图像</p><p><strong>center：</strong>椭圆的圆心坐标，注意这是一个坐标值</p><p><strong>axes：</strong>椭圆的长轴和短轴的长度，这是一个元组信息</p><p><strong>rotateAngle：</strong>椭圆旋转的角度</p><p><strong>startAngle：</strong>椭圆弧起始角度</p><p><strong>endAngle：</strong>椭圆弧终止角度</p><p><strong>color：</strong>椭圆线条颜色，颜色值为BGR，即：（0，0，255）为红色</p><p><strong>thickness：</strong>椭圆的线条宽度</p><p><strong>lineType：</strong>线条类型，三个参数可选LINE_4、LINE_8、LINE_AA，感兴趣的可以亲测</p><p><strong>shift：</strong>椭圆坐标点小数点位数</p><h3 id="5-1-5-多边形绘制"><a href="#5-1-5-多边形绘制" class="headerlink" title="5.1.5 多边形绘制"></a>5.1.5 多边形绘制</h3><div class="hljs"><pre><code class="hljs python">cv2.polylines(img, pts, isClosed, color, thickness, lineType, shift)</code></pre></div><p><strong>img：</strong>多边形所在的矩形或图像</p><p><strong>pts：</strong>多边形各边的坐标点组成的一个列表，是一个numpy的数组类型</p><p><strong>isClosed：</strong>值为True或False，若为True则表示一个闭合的多边形，若为False则不闭合</p><p><strong>color：</strong>线条颜色，颜色值为BGR，即：（0，0，255）为红色</p><p><strong>thickness：</strong>线条宽度</p><p><strong>lineType：</strong>线条类型，三个参数可选LINE_4、LINE_8、LINE_AA，感兴趣的可以亲测</p><p><strong>shift：</strong>坐标点小数点位数</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 多边形绘制</span>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)pts = np.array([[<span class="hljs-number">100</span>, <span class="hljs-number">50</span>], [<span class="hljs-number">200</span>, <span class="hljs-number">300</span>], [<span class="hljs-number">70</span>, <span class="hljs-number">20</span>], [<span class="hljs-number">250</span>, <span class="hljs-number">250</span>], [<span class="hljs-number">500</span>, <span class="hljs-number">100</span>]], np.int32)pts = pts.reshape((<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>))cv2.polylines(img, [pts], <span class="hljs-literal">True</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>))cv2.imshow(<span class="hljs-string">'line'</span>, img)cv2.waitKey()</code></pre></div><h2 id="5-2-文字绘制"><a href="#5-2-文字绘制" class="headerlink" title="5.2 文字绘制"></a>5.2 文字绘制</h2><div class="hljs"><pre><code class="hljs python">cv2.putText(img, text, org, fontFace, fontScale, color, thickness, lineType, bottomLeftOrigin)</code></pre></div><p><strong>img：</strong>文字要放置的矩形或图像</p><p><strong>text：</strong>文字内容</p><p><strong>org：</strong>文字在图像中的左下角坐标</p><p><strong>fontFace：</strong>字体类型，可选参数有以下几种</p><p>FONT_HERSHEY_SIMPLEX,FONT_HERSHEY_PLAIN,FONT_HERSHEY_DUPLEX,FONT_HERSHEY_COMPLEX, FONT_HERSHEY_TRIPLEX, FONT_HERSHEY_COMPLEX_SMALL, FONT_HERSHEY_SCRIPT_SIMPLEX, orFONT_HERSHEY_SCRIPT_COMPLEX</p><p>上述类型的字体可以结合 FONT_HERSHEY_ITALIC一起来使用，从而使字体产生斜体效果。</p><p><strong>fontScale：</strong>缩放比例，用该值乘以程序字体默认大小即为字体大小</p><p><strong>color：</strong>字体颜色，颜色值为BGR，即：（0，0，255）为红色</p><p><strong>thickness：</strong>字体线条宽度</p><p><strong>lineType:</strong>  线条类型。为了更好看，建议使用lineType = cv.LINE_AA。</p><p><strong>bottomLeftOrigin：</strong>默认为 true，即表示图像数据原点在左下角；若为False则表示图像数据原点在左上角。</p><p>【注】color（含）之前的参数为必须参数，其它为可选项。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#文字的绘制</span>img = np.zeros((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>, <span class="hljs-number">3</span>), np.uint8)font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img, <span class="hljs-string">'I love Chestnut!!'</span>, (<span class="hljs-number">120</span>, <span class="hljs-number">250</span>), font, <span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, cv2.LINE_AA, <span class="hljs-literal">False</span>)cv2.imshow(<span class="hljs-string">'show'</span>, img)cv2.waitKey()</code></pre></div><h2 id="5-3-图像绘制"><a href="#5-3-图像绘制" class="headerlink" title="5.3 图像绘制"></a>5.3 图像绘制</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-comment">#图形的绘制</span>img1 = cv2.imread(<span class="hljs-string">'../timgjpg.jpg'</span>, <span class="hljs-number">1</span>)img2 = cv2.imread(<span class="hljs-string">'../timg.jpg'</span>, <span class="hljs-number">1</span>)height = int(img2.shape[<span class="hljs-number">0</span>] * <span class="hljs-number">0.3</span>)width = int(img2.shape[<span class="hljs-number">1</span>] * <span class="hljs-number">0.3</span>)img2 = cv2.resize(img2, (width, height))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, height):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, width):        img1[<span class="hljs-number">100</span> + i, <span class="hljs-number">100</span> + j] = img2[i, j]cv2.imshow(<span class="hljs-string">'img1'</span>, img1)cv2.waitKey()</code></pre></div><h1 id="第6章-机器学习"><a href="#第6章-机器学习" class="headerlink" title="第6章 机器学习"></a>第6章 机器学习</h1><h2 id="6-1-视频分解图片"><a href="#6-1-视频分解图片" class="headerlink" title="6.1 视频分解图片"></a>6.1 视频分解图片</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2.cv2 <span class="hljs-keyword">as</span> cvcap = cv.VideoCapture(<span class="hljs-string">'../fruits.mp4'</span>)isOpened = cap.isOpenedprint(isOpened)i = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> isOpened:    <span class="hljs-keyword">if</span> i == <span class="hljs-number">100</span>:        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">else</span>:        i = i + <span class="hljs-number">1</span>    (flag, frame) = cap.read()    frame = cv.flip(frame, <span class="hljs-number">-1</span>)    filename = <span class="hljs-string">'image'</span>+str(i)+<span class="hljs-string">'.jpg'</span>    print(filename)    <span class="hljs-keyword">if</span> flag:        cv.imwrite(filename, frame, [cv.IMWRITE_JPEG_QUALITY, <span class="hljs-number">100</span>])print(<span class="hljs-string">'end!'</span>)</code></pre></div><h2 id="6-2-图片合成"><a href="#6-2-图片合成" class="headerlink" title="6.2 图片合成"></a>6.2 图片合成</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2.cv2 <span class="hljs-keyword">as</span> cv<span class="hljs-keyword">import</span> ospicexp = <span class="hljs-string">r'F:\yolo\keras-yolo3-underwater\VOCdevkit\VOC2007\JPEGImages\000000.jpg'</span>img = cv.imread(picexp, <span class="hljs-number">1</span>)path = <span class="hljs-string">r'F:\yolo\keras-yolo3-underwater\VOCdevkit\VOC2007\JPEGImages'</span>size = (img.shape[<span class="hljs-number">1</span>], img.shape[<span class="hljs-number">0</span>])print(size)fourcc = cv.VideoWriter_fourcc(*<span class="hljs-string">'MJPG'</span>)VideoWriter = cv.VideoWriter(<span class="hljs-string">'../sea.avi'</span>, fourcc, <span class="hljs-number">30.0</span>, size)filelist = os.listdir(path)<span class="hljs-keyword">for</span> picfile <span class="hljs-keyword">in</span> filelist:    picpath = os.path.join(path, picfile)    print(picpath)    img = cv.imread(picpath, <span class="hljs-number">1</span>)    VideoWriter.write(img)    cv.imshow(<span class="hljs-string">'frame'</span>, img)    <span class="hljs-keyword">if</span> cv.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == ord(<span class="hljs-string">'q'</span>):        <span class="hljs-keyword">break</span>print(<span class="hljs-string">'end!'</span>)VideoWriter.release()cv.destroyAllWindows()</code></pre></div><h2 id="6-3-Haar特征"><a href="#6-3-Haar特征" class="headerlink" title="6.3 Haar特征"></a>6.3 Haar特征</h2><p>Haar特征是一种反映图像的灰度变化的，像素分模块求差值的一种特征。它分为三类：边缘特征、线性特征、中心特征和对角线特征。用黑白两种矩形框组合成特征模板，在特征模板内用 黑色矩形像素和 减去 白色矩形像素和来表示这个模版的特征值。例如：脸部的一些特征能由矩形模块差值特征简单的描述，如：眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。但矩形特征只对一些简单的图形结构，如边缘、线段较敏感，所以只能描述在特定方向（水平、垂直、对角）上有明显像素模块梯度变化的图像结构。</p><p><img src="/2020/07/22/OpenCV%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/20160816165648862.jpg" srcset="/img/loading.gif" alt></p><p>如上图A、B、D模块的图像Haar特征为：<br>$$<br>v=Sum白-Sum黑<br>$$<br>C 模块的图像Haar特征为：<br>$$<br>v=Sum白(左)+Sum白(右)-2*Sum黑<br>$$<br>这里要保证白色矩形模块中的像素与黑色矩形的模块的像素数相同，所以乘2</p>]]></content>
    
    
    <categories>
      
      <category>OpenCV</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenCV</tag>
      
      <tag>Image</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matplotlib快速入门</title>
    <link href="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="第一节-基本用法"><a href="#第一节-基本用法" class="headerlink" title="第一节 基本用法"></a>第一节 基本用法</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npx = np.arange(<span class="hljs-number">10</span>)y = x * <span class="hljs-number">2</span> + <span class="hljs-number">4</span>plt.plot(x, y)plt.show()</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/pic1.png" srcset="/img/loading.gif" style="zoom:60%;"><p>注意要点：</p><ol><li><p>首先导入画图工具类，和numpy计算包产生x,y数据</p></li><li><p><strong><code>plt.plot()</code>绘制函数图像，每一个<code>plot()</code>都是对应的一个图形。</strong></p></li><li><p>最后通过<code>plt.show()</code>将图像展示出来</p></li></ol><h1 id="第二节-figure图像"><a href="#第二节-figure图像" class="headerlink" title="第二节 figure图像"></a>第二节 figure图像</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> math<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawcurve</span><span class="hljs-params">(x, y)</span>:</span>    <span class="hljs-keyword">return</span> math.pow(x,y)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawcircle</span><span class="hljs-params">(x, r)</span>:</span>    <span class="hljs-keyword">return</span> math.sqrt(r**<span class="hljs-number">2</span> - x**<span class="hljs-number">2</span>), - math.sqrt(r**<span class="hljs-number">2</span> - x**<span class="hljs-number">2</span>)plt.figure(<span class="hljs-string">'Red Dotted Curve'</span>)x = np.linspace(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)convert = np.vectorize(drawcurve)y = convert(x, <span class="hljs-number">2</span>)+convert(x, <span class="hljs-number">3</span>)plt.plot(x,y, color=<span class="hljs-string">'red'</span>, linewidth=<span class="hljs-string">'2'</span>, linestyle=<span class="hljs-string">'--'</span>)plt.figure(<span class="hljs-string">'Circle'</span>)x = np.linspace(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>,<span class="hljs-number">1000</span>)convertCircle = np.vectorize(drawcircle)positive, negative = convertCircle(x, <span class="hljs-number">5</span>)plt.plot(x, positive, color=<span class="hljs-string">'blue'</span>, linewidth=<span class="hljs-string">'3'</span>, linestyle=<span class="hljs-string">'-'</span>)plt.plot(x, negative, color=<span class="hljs-string">'blue'</span>, linewidth=<span class="hljs-string">'3'</span>, linestyle=<span class="hljs-string">'-'</span>)plt.show()</code></pre></div><div style="display:flex;justify-content: center;"><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Red_Dotted_Curve.png" srcset="/img/loading.gif" style="zoom: 60%;"><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Circle.png" srcset="/img/loading.gif" style="zoom: 60%;"></div><p>注意要点：</p><ol><li>首先导入画图工具类，和numpy计算包产生x,y数据</li><li>定义两个函数，<code>drawcurve</code>和<code>drawcircle</code>。分别对两个函数进行了向量化操作。</li><li><strong><code>plt.figure()</code>会单独开辟出一个画图的窗体，每个f<code>igure()</code>都是独立的。</strong></li></ol><p><code>plt.figure</code> 调用方法：</p><div class="hljs"><pre><code class="hljs python">plt.figure(num=<span class="hljs-literal">None</span>, figsize=<span class="hljs-literal">None</span>, dpi=<span class="hljs-literal">None</span>,    facecolor=<span class="hljs-literal">None</span>, edgecolor=<span class="hljs-literal">None</span>, frameon=<span class="hljs-literal">True</span>,    FigureClass=&lt;class 'matplotlib.figure.Figure'&gt;,    clear=<span class="hljs-literal">False</span>, **kwargs)</code></pre></div><p>参考文档：<a href="https://matplotlib.org/api/_as_gen/matplotlib.pyplot.figure.html#matplotlib.pyplot.figure" target="_blank" rel="noopener">matplotlib.pyplot.figure</a></p><p>参数说明：</p><ul><li><code>num</code> 当给它一个数字时，就作为画板的编号，相当于 ID 号；当给它一个字符串时，就作为画板的名称</li><li><code>figsize</code> 画板的宽、高，单位为英寸 (2.5cm)</li><li><code>dpi</code> 指定在该画板上绘制的图像的分辨率，即每英寸多少个像素</li><li><code>facecolor</code> 画板的背景颜色</li><li><code>edgecolor</code> 画板的边框颜色</li><li><code>frameon</code> 是否显示边框</li></ul><h1 id="第三节-设置坐标轴"><a href="#第三节-设置坐标轴" class="headerlink" title="第三节 设置坐标轴"></a>第三节 设置坐标轴</h1><p>还是根据上一个画曲线和画圆的例子来看，我们的横轴和数轴的竖轴不是成比例的。所有导致画出来的图型在横轴或竖轴上都有些拉伸，因此我们可以设置在横轴和竖轴上的刻度范围。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment">#定义一个图像</span>plt.figure(<span class="hljs-string">'Demo of xlim,ylim'</span>)x = np.linspace(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)y = x**<span class="hljs-number">3</span><span class="hljs-comment">#设置x轴和y轴的刻度范围</span>plt.xlim((<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>))plt.ylim((<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>))<span class="hljs-comment">#设置x轴和y轴的标签</span>plt.xlabel(<span class="hljs-string">'x = [-5,5]'</span>)plt.ylabel(<span class="hljs-string">'y'</span>)plt.plot(x, y, color=<span class="hljs-string">'red'</span>, linewidth=<span class="hljs-string">'2'</span>, linestyle=<span class="hljs-string">'--'</span>)plt.show()</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Demo_of_xlim,ylim.png" srcset="/img/loading.gif" style="zoom:60%;"><p>x轴和y轴都限制在了【-5， 5】的范围，这样的图像画出来才更符合我们平时看到的图像，对吧！</p><p>但是x轴和y轴的刻度是每两个数来显示的，我们可以自定义显示的刻度，下面我们来设置下坐标轴的刻度值，我们将设定为每一个显示一个刻度：</p><div class="hljs"><pre><code class="hljs python">...<span class="hljs-comment">#设置x轴和y轴的标签</span>plt.xlabel(<span class="hljs-string">'x = [-3,3]'</span>)plt.ylabel(<span class="hljs-string">'y'</span>)<span class="hljs-comment">#设置x轴和y轴的刻度</span>plt.xticks(np.arange(<span class="hljs-number">-3</span>, <span class="hljs-number">4</span>))plt.yticks(np.arange(<span class="hljs-number">-3</span>, <span class="hljs-number">4</span>))...</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Demo_of_xlim,ylim（1）.png" srcset="/img/loading.gif" style="zoom:60%;"><p>这样看起来是不是更好了，下面我们把坐标轴移动到中心：</p><div class="hljs"><pre><code class="hljs python">...<span class="hljs-comment">#设置x轴和y轴的刻度</span>plt.xticks(np.arange(<span class="hljs-number">-3</span>, <span class="hljs-number">4</span>))plt.yticks(np.arange(<span class="hljs-number">-3</span>, <span class="hljs-number">4</span>))<span class="hljs-comment">#设置坐标轴</span>ax = plt.gca()ax.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)ax.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)ax.xaxis.set_ticks_position(<span class="hljs-string">'bottom'</span>)ax.yaxis.set_ticks_position(<span class="hljs-string">'left'</span>)ax.spines[<span class="hljs-string">'bottom'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax.spines[<span class="hljs-string">'left'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))...</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Demo_of_xlim,ylim（2）.png" srcset="/img/loading.gif" style="zoom:60%;"><p>这里介绍一下代码：</p><p>plt.plot()实际上会通过plt.gca()获得当前的Axes对象ax，然后再调用ax.plot()方法实现真正的绘图。</p><p>首先搞清楚了一直以来的疑惑（借用官方文档的一幅图说明）：<strong>Figure</strong>，<strong>Axes</strong>，<strong>Axis</strong> 这三个是什么关系。</p><div style="display:flex;justify-content: center;"><img src="https://img-blog.csdnimg.cn/20200311202147484.png" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom: 67%;"></div><ul><li>Figure： 红色的外框，其实可以把它理解为一个大画板，我们所有的内容都会画在这个“画板”上</li><li>Axes： 蓝色的内框，有人这么解释：</li></ul><p>​    Axis 指 x、y 坐标轴等（如果有三维那就还有 z 轴），代表的是 “坐标轴”。而 Axes 在英文里是 Axis 的复数形式，也就是说 axes 代表的其实是 figure 当中的一套坐标轴。之所以说一套而不是两个坐标轴，是因为如果你画三维的图，axes 就代表 3 根坐标轴了。所以，在一个 figure 当中，每添加一次 subplot ，其实就是添加了一套坐标轴，也就是添加了一个 axes，放在二维坐标里就是你添加了两根坐标轴，分别是 x 轴和 y 轴。所以当你只画一个图的时候，plt.xxx 与 ax.xxx 其实都是作用在相同的图上的。</p><p>​    <strong>说话的方式简单点… 要不就把 Axes 理解为子图（画布）吧，一张大画板 figure 上可以有一个或多个子图（画布）Axes，当只有一个 axes 时，<code>plt.plot()</code> 和 <code>ax.plot()</code> 自然就作用的是同一张图了！</strong></p><ul><li>Axis： 绿色的横纵坐标轴，这个才是正儿八经的坐标轴！</li></ul><h1 id="第四节-绘制子图"><a href="#第四节-绘制子图" class="headerlink" title="第四节 绘制子图"></a>第四节 绘制子图</h1><p>类似于下面这样，定义 4 个 subplot，自然就有 4 个 Axes：</p><img src="https://img-blog.csdnimg.cn/2020031120392648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzQ3ODY5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:67%;"><p>总结一下： <strong>figure 是作图时给你的一个大画板，而 axes 是在这个画板上的很多幅画布（子图），绘制的所有图都在画布（axes）上。</strong>比如上面的漫画布局，就可以用：</p><div class="hljs"><pre><code class="hljs python">plt.figure()plt.gcf().subplots(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)</code></pre></div><p>来完成。其中 <code>.gcf()</code> 的作用是获取当前 figure，即 get current figure。另外对应的 .gca() 就是获取当前 axes，即 get current axes。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npx = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)<span class="hljs-comment">#将figure分为4个子图（Axes)</span>fig, axes = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)ax1 = axes[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]    <span class="hljs-comment"># 根据索引［0，0］从Axes对象数组中获取第1个子图</span>ax2 = axes[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]    <span class="hljs-comment"># 根据索引［0，1］从Axes对象数组中获取第2个子图</span>ax3 = axes[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]    <span class="hljs-comment"># 根据索引［1，0］从Axes对象数组中获取第3个子图</span>ax4 = axes[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]    <span class="hljs-comment"># 根据索引［1，1］从Axes对象数组中获取第4个子图</span>ax1.plot(x, x**<span class="hljs-number">2</span>)ax2.plot(x, -x)ax3.plot(x, np.sqrt(x))ax4.plot(x, np.log(x))plt.show()</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/Figure_1.png" srcset="/img/loading.gif" alt="img" style="zoom:67%;"><p>我们根据之前所学丰富一下坐标轴信息：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> mx = np.linspace(<span class="hljs-number">0.1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)<span class="hljs-comment">#将figure分为4个子图（Axes)</span>fig, axes = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)ax1 = axes[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]    <span class="hljs-comment"># 根据索引［0，0］从Axes对象数组中获取第1个子图</span>ax2 = axes[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]    <span class="hljs-comment"># 根据索引［0，1］从Axes对象数组中获取第2个子图</span>ax3 = axes[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]    <span class="hljs-comment"># 根据索引［1，0］从Axes对象数组中获取第3个子图</span>ax4 = axes[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]    <span class="hljs-comment"># 根据索引［1，1］从Axes对象数组中获取第4个子图</span><span class="hljs-comment">#ax1的坐标设置</span>ax1.set_title(<span class="hljs-string">r'$y=x^2$'</span>)ax1.set_xlim((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>))ax1.set_ylim((<span class="hljs-number">0</span>, <span class="hljs-number">25</span>))ax1.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)ax1.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)ax1.plot(x, x**<span class="hljs-number">2</span>)<span class="hljs-comment">#ax2的坐标设置</span>ax2.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)ax2.spines[<span class="hljs-string">'bottom'</span>].set_color(<span class="hljs-string">'none'</span>)ax2.xaxis.set_ticks_position(<span class="hljs-string">'top'</span>)ax2.yaxis.set_ticks_position(<span class="hljs-string">'left'</span>)ax2.spines[<span class="hljs-string">'top'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax2.spines[<span class="hljs-string">'left'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax2.set_title(<span class="hljs-string">r'$y=-x$'</span>)ax2.set_xticks([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])ax2.plot(x, -x)<span class="hljs-comment">#ax3的坐标设置</span>ax3.set_title(<span class="hljs-string">r'$y=\sqrt&#123;x&#125;$'</span>)ax3.set_xlim((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>))ax3.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)ax3.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)ax3.xaxis.set_ticks([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])ax3.yaxis.set_ticks([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, m.sqrt(<span class="hljs-number">2</span>), m.sqrt(<span class="hljs-number">3</span>), m.sqrt(<span class="hljs-number">4</span>), m.sqrt(<span class="hljs-number">5</span>)])ax3.plot(x, np.sqrt(x))<span class="hljs-comment">#ax4的坐标设置</span>ax4.set_title(<span class="hljs-string">r'$y=log(x)$'</span>)ax4.set_xlim((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>))ax4.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)ax4.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)ax4.xaxis.set_ticks([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])ax4.spines[<span class="hljs-string">'left'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax4.spines[<span class="hljs-string">'bottom'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax4.plot(x, np.log(x))plt.show()</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/function.png" srcset="/img/loading.gif" style="zoom: 67%;"><h1 id="第五节-Legend图例"><a href="#第五节-Legend图例" class="headerlink" title="第五节 Legend图例"></a>第五节 Legend图例</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> mx = np.linspace(<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)y = <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + m.e**(-x))ax = plt.gca()ax.set_xlim((<span class="hljs-number">-5</span>, <span class="hljs-number">5</span>))ax.set_ylim((<span class="hljs-number">0</span>, <span class="hljs-number">1.1</span>))ax.set_yticks([<span class="hljs-number">1</span>])ax.set_xticks(np.arange(<span class="hljs-number">-5</span>, <span class="hljs-number">6</span>))ax.spines[<span class="hljs-string">'top'</span>].set_color(<span class="hljs-string">'none'</span>)ax.spines[<span class="hljs-string">'right'</span>].set_color(<span class="hljs-string">'none'</span>)ax.xaxis.set_ticks_position(<span class="hljs-string">'bottom'</span>)ax.yaxis.set_ticks_position(<span class="hljs-string">'left'</span>)ax.spines[<span class="hljs-string">'left'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax.spines[<span class="hljs-string">'bottom'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax.plot(x, y)ax.legend([<span class="hljs-string">'Sigmoid Function'</span>], loc=<span class="hljs-string">'best'</span>)plt.show()</code></pre></div><p>效果如下：</p><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/sigmoid_fun.png" srcset="/img/loading.gif" style="zoom:67%;"><p>左上角出现了一个标记。</p><p>还有其他的表达方式，可以自动添加图例</p><div class="hljs"><pre><code class="hljs python">ax.plot(x, y, label=<span class="hljs-string">'Sigmoid Function'</span>)ax.legend()</code></pre></div><h1 id="第六节-ticks标注"><a href="#第六节-ticks标注" class="headerlink" title="第六节 ticks标注"></a>第六节 ticks标注</h1><div class="hljs"><pre><code class="hljs python">...ax.spines[<span class="hljs-string">'left'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))ax.spines[<span class="hljs-string">'bottom'</span>].set_position((<span class="hljs-string">'data'</span>, <span class="hljs-number">0</span>))<span class="hljs-keyword">for</span> label <span class="hljs-keyword">in</span> ax.get_xticklabels()+ax.get_yticklabels():    label.set_fontsize(<span class="hljs-number">10</span>)    label.set_bbox(dict(facecolor=<span class="hljs-string">'yellow'</span>, edgecolor=<span class="hljs-string">'None'</span>, alpha=<span class="hljs-number">0.7</span>))ax.plot(x, y, label=<span class="hljs-string">'Sigmoid Function'</span>)...</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/sigmoid_fun（2）.png" srcset="/img/loading.gif" style="zoom:67%;"><p>这样就在刻度上画出了一个矩形，改变了样式。</p><h1 id="第七节-散点图"><a href="#第七节-散点图" class="headerlink" title="第七节 散点图"></a>第七节 散点图</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib.font_manager <span class="hljs-keyword">import</span> FontPropertiesfont = FontProperties(fname=<span class="hljs-string">r"C:\Windows\Fonts\simhei.ttf"</span>, size=<span class="hljs-number">14</span>)X1 = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">512</span>)Y1 = np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">512</span>)X2 = np.random.normal(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">512</span>)Y2 = np.random.normal(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">512</span>)plt.title(<span class="hljs-string">u'散点图示例'</span>, FontProperties=font)plt.scatter(X1, Y1, marker=<span class="hljs-string">'o'</span>, c=<span class="hljs-string">'y'</span>, edgecolors=<span class="hljs-string">'r'</span>, alpha=<span class="hljs-number">0.6</span>)plt.scatter(X2, Y2, marker=<span class="hljs-string">'o'</span>, c=<span class="hljs-string">'m'</span>, edgecolors=<span class="hljs-string">'g'</span>, alpha=<span class="hljs-number">0.6</span>)plt.show()</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/scatter.png" srcset="/img/loading.gif" style="zoom:67%;"><h1 id="第八节-image图片"><a href="#第八节-image图片" class="headerlink" title="第八节 image图片"></a>第八节 image图片</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npx = np.random.randint(<span class="hljs-number">155</span>, <span class="hljs-number">255</span>, size=[<span class="hljs-number">255</span>, <span class="hljs-number">255</span>])plt.imshow(x, interpolation=<span class="hljs-string">'nearest'</span>, cmap=<span class="hljs-string">'bone'</span>, origin=<span class="hljs-string">'upper'</span>)plt.colorbar(shrink=<span class="hljs-number">0.9</span>)plt.show()</code></pre></div><img src="/2020/07/22/Matplotlib%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/img.png" srcset="/img/loading.gif" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Matplotlib</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Matplotlib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基本命令</title>
    <link href="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p class="note note-danger">掌握使用一个分散式版本控制软件</p><h2 id="Git流程图"><a href="#Git流程图" class="headerlink" title="Git流程图"></a>Git流程图</h2><h3 id="1-初始化仓库"><a href="#1-初始化仓库" class="headerlink" title="1.初始化仓库"></a>1.初始化仓库</h3><div class="hljs"><pre><code class="hljs git">$git init</code></pre></div><p>包含<strong>.git</strong>文件的文件夹是<strong>工作区（Workspace）</strong>,也就是工作目录。</p><h3 id="2-本地仓库添加文件"><a href="#2-本地仓库添加文件" class="headerlink" title="2.本地仓库添加文件"></a>2.本地仓库添加文件</h3><p>如果在工作区添加了一个“hello.txt”的文件，我们通过”git add “hello.txt””命令添加到<strong>暂存区</strong>中。此时还需要<strong>commit命令</strong>将修改添加到<strong>本地仓库</strong>中。</p><div class="hljs"><pre><code class="hljs git">$git add &quot;hello.txt&quot;$ git commit -m &quot;第一次添加了hello.txtx的文件&quot;</code></pre></div><p>其中引号中的内容为日志信息</p><h3 id="3-本地仓库删除文件"><a href="#3-本地仓库删除文件" class="headerlink" title="3.本地仓库删除文件"></a>3.本地仓库删除文件</h3><p>另在仓库中新建haowan.txt文件，并按照上述方法添加到本地仓库中。下面进行删除操作。</p><div class="hljs"><pre><code class="hljs git">$ git rm haowan.txtrm &#39;haowan.txt&#39;</code></pre></div><p>这里是类似Linux系统的删除命令，仅仅是在工作区删除了haowan.txt文件。若要从本地仓库删除文件，还要commit命令。</p><div class="hljs"><pre><code class="hljs git">$ git commit -m &quot;删除了hello.txt文件&quot;[master 729fd2b] 删除了hello.txt文件 1 file changed, 1 deletion(-) delete mode 100644 hello.txt</code></pre></div><h3 id="4-将Python项目添加到本地版本库中"><a href="#4-将Python项目添加到本地版本库中" class="headerlink" title="4.将Python项目添加到本地版本库中"></a>4.将Python项目添加到本地版本库中</h3><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200123204234619.png" srcset="/img/loading.gif" alt="image-20200123204234619"></p><p>如将这个项目添加到本地仓库，同理先add到暂存区</p><div class="hljs"><pre><code class="hljs git">$ git add Python_GUI</code></pre></div><div class="hljs"><pre><code class="hljs git">$ git commit -a -m &quot;添加了Python项目&quot;</code></pre></div><p>-a表示将所有的修改的文件一同commit到本地仓库中。</p><div class="hljs"><pre><code class="hljs git">[master c1e8c12] 添加了Python项目 21 files changed, 1141 insertions(+) create mode 100644 Python_GUI&#x2F;.idea&#x2F;encodings.xml create mode 100644 Python_GUI&#x2F;.idea&#x2F;misc.xml create mode 100644 Python_GUI&#x2F;.idea&#x2F;modules.xml create mode 100644 Python_GUI&#x2F;.idea&#x2F;other.xml create mode 100644 Python_GUI&#x2F;.idea&#x2F;workspace.xml create mode 100644 Python_GUI&#x2F;Python_GUI.iml create mode 100644 Python_GUI&#x2F;window&#x2F;Window1.py create mode 100644 Python_GUI&#x2F;window&#x2F;Window2.py create mode 100644 Python_GUI&#x2F;window&#x2F;__init__.py create mode 100644 Python_GUI&#x2F;window&#x2F;__pycache__&#x2F;Window1.cpython-37.pyc create mode 100644 Python_GUI&#x2F;window&#x2F;__pycache__&#x2F;Window2.cpython-37.pyc create mode 100644 Python_GUI&#x2F;window&#x2F;__pycache__&#x2F;__init__.cpython-37.pyc create mode 100644 Python_GUI&#x2F;window&#x2F;chestimouse.ui create mode 100644 Python_GUI&#x2F;window&#x2F;img&#x2F;background.png create mode 100644 Python_GUI&#x2F;window&#x2F;img&#x2F;logo-mini.svg create mode 100644 Python_GUI&#x2F;window&#x2F;img&#x2F;logo.svg create mode 100644 Python_GUI&#x2F;window&#x2F;loginwindow.py create mode 100644 Python_GUI&#x2F;window&#x2F;main.py create mode 100644 Python_GUI&#x2F;window&#x2F;pic.qrc create mode 100644 Python_GUI&#x2F;window&#x2F;quit.png create mode 100644 Python_GUI&#x2F;window&#x2F;test.py</code></pre></div><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200123205024038.png" srcset="/img/loading.gif" alt="image-20200123205024038"></p><h3 id="5-使用-gitignore忽略本地文件"><a href="#5-使用-gitignore忽略本地文件" class="headerlink" title="5.使用.gitignore忽略本地文件"></a>5.使用.gitignore忽略本地文件</h3><p>gitignore：在Git工作区的根目录下创建一个特殊的.gitignore文件，可以把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>.gitignore文件：</p><p>#My configurations:<br>node_modules<br>*.log<br>*.jpg<br>!icon.jpg</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>注释<br>*.log  *为通配符，所有.log都会被忽略<br>!icon.jpg  !为该文件不被忽略 取反<br>node_modules文件夹整个都被忽略</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><div class="hljs"><pre><code class="hljs git">$ cd Python_GUIAdministrator@PC20190401w MINGW64 &#x2F;d&#x2F;360MoveData&#x2F;Users&#x2F;Administrator&#x2F;Desktop&#x2F;gittt&#x2F;Python_GUI (master)$ touch .gitignore</code></pre></div><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200123210105778.png" srcset="/img/loading.gif" alt="image-20200123210105778"></p><p>在文件中添加以下文字</p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200123210307399.png" srcset="/img/loading.gif" alt="image-20200123210307399"></p><p>之后add,commit到本地仓库中</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="1-添加远程库"><a href="#1-添加远程库" class="headerlink" title="1.添加远程库"></a>1.添加远程库</h3><h4 id="与远程仓库建立https的链接"><a href="#与远程仓库建立https的链接" class="headerlink" title="与远程仓库建立https的链接"></a>与远程仓库建立https的链接</h4><div class="hljs"><pre><code class="hljs git">$ git remote add origin https:&#x2F;&#x2F;github.com&#x2F;LehiChiang&#x2F;NeteaseMusicDownloader.git$ git push -u origin master</code></pre></div><h4 id="与远程仓库建立SSH的链接"><a href="#与远程仓库建立SSH的链接" class="headerlink" title="与远程仓库建立SSH的链接"></a>与远程仓库建立SSH的链接</h4><p>创建公钥</p><div class="hljs"><pre><code class="hljs git">$ ssh-keygen -t rsa</code></pre></div><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200123232754463.png" srcset="/img/loading.gif" alt="image-20200123232754463"></p><p>然后在id_rsa.pub文件，复制其中的密钥，在用户中心中，找到设置选项，找到”SSH and GPG keys”，点击“New SSH key”按钮，添加密钥。然后标题随便写一个，在下面粘贴上刚刚复制的密钥，然后保存。截图如下：</p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200123233446717.png" srcset="/img/loading.gif" alt="image-20200123233446717" style="zoom: 67%;"><p>最后就可以使用以下命令建立ssh链接，将代码push到远程仓库中了。</p><div class="hljs"><pre><code class="hljs git">$ git remote add origin git@github.com:LehiChiang&#x2F;NeteaseMusicDownloader.git$ git push -u origin master</code></pre></div><h3 id="2-推送修改的文件及冲突解决"><a href="#2-推送修改的文件及冲突解决" class="headerlink" title="2.推送修改的文件及冲突解决"></a>2.推送修改的文件及冲突解决</h3><p>在本地仓库修改的文件，推送到远程，在git GUI中进行，选择菜单栏中的”remote”中的”push”按钮，push到远程后成功的截图如下：</p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124000001891.png" srcset="/img/loading.gif" alt="image-20200124000001891"></p><h3 id="3-从远程仓库拉取修改"><a href="#3-从远程仓库拉取修改" class="headerlink" title="3.从远程仓库拉取修改"></a>3.从远程仓库拉取修改</h3><div class="hljs"><pre><code class="hljs git">$ git pull -v --progress &quot;origin&quot;</code></pre></div><p>或者</p><div class="hljs"><pre><code class="hljs git">$ git pull origin master</code></pre></div><h3 id="4-克隆远程仓库到本地"><a href="#4-克隆远程仓库到本地" class="headerlink" title="4.克隆远程仓库到本地"></a>4.克隆远程仓库到本地</h3><div class="hljs"><pre><code class="hljs git">$ git clone https:&#x2F;&#x2F;github.com&#x2F;LehiChiang&#x2F;NeteaseMusicDownloader.git</code></pre></div><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124003839861.png" srcset="/img/loading.gif" alt="image-20200124003839861"></p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124003944853.png" srcset="/img/loading.gif" alt="image-20200124003944853"></p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124004311357.png" srcset="/img/loading.gif" alt="image-20200124004311357"></p><h3 id="1-在GUI中创建分支"><a href="#1-在GUI中创建分支" class="headerlink" title="1.在GUI中创建分支"></a>1.在GUI中创建分支</h3><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124004738468.png" srcset="/img/loading.gif" alt="image-20200124004738468"></p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124004909629.png" srcset="/img/loading.gif" alt="image-20200124004909629"></p><h3 id="2-分支的合并与删除"><a href="#2-分支的合并与删除" class="headerlink" title="2.分支的合并与删除"></a>2.分支的合并与删除</h3><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124005815294.png" srcset="/img/loading.gif" alt="image-20200124005815294"></p><p><img src="/2020/07/22/Git%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/image-20200124005835231.png" srcset="/img/loading.gif" alt="image-20200124005835231"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解析爬虫</title>
    <link href="/2020/07/22/%E8%A7%A3%E6%9E%90%E7%88%AC%E8%99%AB/"/>
    <url>/2020/07/22/%E8%A7%A3%E6%9E%90%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="（一）发起HTTP-HTTPS请求"><a href="#（一）发起HTTP-HTTPS请求" class="headerlink" title="（一）发起HTTP/HTTPS请求"></a>（一）发起HTTP/HTTPS请求</h2><h3 id="一：方法一：urllib"><a href="#一：方法一：urllib" class="headerlink" title="一：方法一：urllib"></a>一：方法一：urllib</h3><p>​    urllib是python内置的HTTP请求库，无需安装即可使用，它包含了4个模块：</p><ul><li><p>request：它是最基本的http请求模块，用来模拟发送请求</p></li><li><p>error：异常处理模块，如果出现错误可以捕获这些异常</p></li><li><p>parse：一个工具模块，提供了许多URL处理方法，如：拆分、解析、合并等</p></li><li><p>robotparser：主要用来识别网站的robots.txt文件，然后判断哪些网站可以爬</p><p><strong>快速爬取一个网页</strong></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request <span class="hljs-keyword">as</span> urresponse=ur.urlopen(<span class="hljs-string">"https://www.baidu.com"</span>)html=response.read().decode(<span class="hljs-string">"utf-8"</span>)print(html)</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">location.replace(location.href.replace(<span class="hljs-string">"https://"</span>,<span class="hljs-string">"http://"</span>));</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"refresh"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"0;url=http://www.baidu.com/"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div></li></ul><h4 id="1、urllib-request-urlopen"><a href="#1、urllib-request-urlopen" class="headerlink" title="1、urllib.request.urlopen()"></a>1、urllib.request.urlopen()</h4><p>urllib.request.urlopen(<strong>url,data=None,[timeout,</strong>],cafile=None,capath=None,cadefault=False,context=None)</p><p>urlopen()方法可传递参数：</p><p><strong>url：</strong>网站地址，str类型，<strong><u><em>也可以是一个request对象</em></u></strong></p><p><strong>data：</strong>data参数是可选的，内容为字节流编码格式的即bytes类型，如果传递data参数，urlopen将使用Post方式请求</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen<span class="hljs-keyword">import</span> urllib.parsedata = bytes(urllib.parse.urlencode(&#123;<span class="hljs-string">'word'</span>:<span class="hljs-string">'hello'</span>&#125;),encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-comment">#data需要字节类型的参数，使用bytes()函数转换为字节，使用urllib.parse模块里的urlencode()方法来讲参数字典转换为字符串并指定编码</span>response = urlopen(<span class="hljs-string">'http://httpbin.org/post'</span>,data=data)print(response.read())</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#output</span><span class="hljs-string">b'&#123;</span><span class="hljs-string">........</span><span class="hljs-string">"form":&#123;"word":"hello"&#125;,  #form字段表明模拟以表单的方法提交数据，post方式传输数据</span><span class="hljs-string">"headers":&#123;"Accept-Encoding":"identity",</span><span class="hljs-string"> .......&#125;'</span></code></pre></div><p><strong>timeout参数：</strong>用于设置超时时间，单位为秒，如果请求超出了设置时间还未得到响应则抛出异常，支持HTTP,HTTPS,FTP请求</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.requestresponse=urllib.request.urlopen(<span class="hljs-string">'http://httpbin.org/get'</span>,timeout=<span class="hljs-number">0.1</span>)  <span class="hljs-comment">#设置超时时间为0.1秒,将抛出异常</span>print(response.read())</code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#output</span>urllib.error.URLError: &lt;urlopen error timed out&gt;</code></pre></div><p>可以使用异常处理来捕获异常</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> urllib.error<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">try</span>:    response=urllib.request.urlopen(<span class="hljs-string">'http://httpbin.org/get'</span>,timeout=<span class="hljs-number">0.1</span>)    print(response.read())<span class="hljs-keyword">except</span> urllib.error.URLError <span class="hljs-keyword">as</span> e:    <span class="hljs-keyword">if</span> isinstance(e.reason,socket.timeout): <span class="hljs-comment">#判断对象是否为类的实例</span>        print(e.reason) <span class="hljs-comment">#返回错误信息</span></code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#output</span>timed out</code></pre></div><p>其他参数：context参数，她必须是ssl.SSLContext类型，用来指定SSL设置，此外,cafile和capath这两个参数分别指定CA证书和它的路径，会在https链接时用到。</p><h4 id="2-返回HTTPResponse对象"><a href="#2-返回HTTPResponse对象" class="headerlink" title="2.返回HTTPResponse对象"></a>2.返回HTTPResponse对象</h4><p>urlopen()方法返回一个HTTPResponse类型的对象，该对象包含的方法和属性：</p><p>方法：read()、readinto()、getheader(name)、getheaders()、fileno()</p><p>属性：msg、version、status、reason、bebuglevel、closed</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.requestresponse=urllib.request.urlopen(<span class="hljs-string">'https://www.python.org'</span>)  <span class="hljs-comment">#请求站点获得一个HTTPResponse对象</span>print(response.read().decode(<span class="hljs-string">'utf-8'</span>))   <span class="hljs-comment">#返回网页内容</span>print(response.getheader(<span class="hljs-string">'server'</span>)) <span class="hljs-comment">#返回响应头中的server值</span>print(response.getheaders()) <span class="hljs-comment">#以列表元祖对的形式返回响应头信息</span>print(response.fileno()) <span class="hljs-comment">#返回文件描述符</span>print(response.version)  <span class="hljs-comment">#返回版本信息</span>print(response.status)  <span class="hljs-comment">#返回状态码200，404代表网页未找到</span>print(response.debuglevel) <span class="hljs-comment">#返回调试等级</span>print(response.closed)  <span class="hljs-comment">#返回对象是否关闭布尔值</span>print(response.geturl()) <span class="hljs-comment">#返回检索的URL</span>print(response.info()) <span class="hljs-comment">#返回网页的头信息</span>print(response.getcode()) <span class="hljs-comment">#返回响应的HTTP状态码</span>print(response.msg)  <span class="hljs-comment">#访问成功则返回ok</span>print(response.reason) <span class="hljs-comment">#返回状态信息</span></code></pre></div><h4 id="3-构造Request对象"><a href="#3-构造Request对象" class="headerlink" title="3.构造Request对象"></a>3.构造Request对象</h4><p>如果希望执行更为复杂的操作（如增加HTTP报头），则必须创建一个Request()对象作为urlopen()的参数。</p><p>urllib.request.Request(<strong>url,data=None,headers={}</strong>,origin_req_host=None,unverifiable=False,method=None)</p><p>参数：</p><p><strong>url：</strong>请求的URL，必须传递的参数，其他都是可选参数</p><p><strong>data：</strong>上传的数据，必须传bytes字节流类型的数据，如果它是字典，可以先用urllib.parse模块里的urlencode()编码</p><p><strong>headers：</strong>它是一个字典，传递的是请求头数据，可以通过它构造请求头，也可以通过调用请求实例的方法add_header()来添加</p><p><em>例如：修改User_Agent头的值来伪装浏览器，比如火狐浏览器可以这样设置：</em></p><p><em>{‘User-Agent’:’Mozilla/5.0 (compatible; MSIE 5.5; Windows NT)’}</em></p><p>origin_req_host：指请求方的host名称或者IP地址</p><p>unverifiable：表示这个请求是否是无法验证的，默认为False，如我们请求一张图片如果没有权限获取图片那它的值就是true</p><p>method：是一个字符串，用来指示请求使用的方法，如：GET,POST,PUT等</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> urllib.parseurl=<span class="hljs-string">'http://www.itcast.cn'</span>header=&#123;<span class="hljs-string">"User-Agent"</span>:<span class="hljs-string">'Mozilla/5.0 (compatible; MSIE 5.5; Windows NT)'</span>&#125;data=bytes(urllib.parse.urlencode(&#123;<span class="hljs-string">"name"</span>:<span class="hljs-string">"itcast"</span>&#125;).encode(<span class="hljs-string">'utf-8'</span>))request=urllib.request.Request(url,headers=header,data=data)response=urllib.request.urlopen(request)print(response.read().decode(<span class="hljs-string">"utf-8"</span>))</code></pre></div><h4 id="4-如何发送get请求？"><a href="#4-如何发送get请求？" class="headerlink" title="4.如何发送get请求？"></a>4.如何发送get请求？</h4><p>如果使用urlopen()方法中的data属性发送的话属于POST请求，所有只能通过修改url的方式来发送GET请求，如:</p><div class="hljs"><pre><code class="hljs python">word=&#123;<span class="hljs-string">"wd"</span>:<span class="hljs-string">"itcast"</span>&#125;word=urllib.parse.urlencode(word)new_url=url+<span class="hljs-string">"?"</span>+word</code></pre></div><h4 id="5-添加特定Headers"><a href="#5-添加特定Headers" class="headerlink" title="5.添加特定Headers"></a>5.添加特定Headers</h4><p>可以调用request.add_header(“Connection”,”keep-alive”)</p><p>可以调用request.get_header(header_name=”Connection”)</p><h4 id="6-代理服务器"><a href="#6-代理服务器" class="headerlink" title="6.代理服务器"></a>6.代理服务器</h4><p> 之前的urlopen()方法就是urllib提供的一个opener， 它是urllib.request.OpenerDirector类的对象。但urlopen()方法不支持代理，Cookie等其他的HTTP/HTTPS高级功能。所有需要自定义一个Opener，需要执行以下几步：</p><ol><li>使用相关的Handler处理器创建特定功能的处理器对象</li><li>通过urllib.request.build_opener()方法创建自定义的opener对象</li><li>使用自定义的opener对象，调用open()方法发送请求</li></ol><p><strong><em>注意：如果想使用全局的opener发送请求的话，可以使用urllib2.install_opener()将自定义的opener对象定义为全局opener</em></strong></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.requesthttp_handler = urllib.request.HTTPHandler()opener = urllib.request.build_opener(http_handler)request=urllib.request.Request(<span class="hljs-string">"http://itcast.cn"</span>)response=opener.open(request)print(response.read().decode(<span class="hljs-string">"utf-8"</span>))</code></pre></div><p>设置代理服务器</p><p>用户可以用urllib.request.ProxyHandler方法来设置代理服务器</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.error <span class="hljs-keyword">import</span> URLError<span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> ProxyHandler,build_openerproxy_handler=ProxyHandler(&#123;    <span class="hljs-string">'http'</span>:<span class="hljs-string">'http://127.0.0.1:8888'</span>,    <span class="hljs-string">'https'</span>:<span class="hljs-string">'http://127.0.0.1:9999'</span>&#125;)opener=build_opener(proxy_handler) <span class="hljs-comment">#构造一个Opener</span><span class="hljs-keyword">try</span>:    response=opener.open(<span class="hljs-string">'https://www.baidu.com'</span>)    print(response.read().decode(<span class="hljs-string">'utf-8'</span>))<span class="hljs-keyword">except</span> URLError <span class="hljs-keyword">as</span> e:    print(e.reason)</code></pre></div><p>提供几个免费的代理网站：</p><ol><li>西刺免费代理IP</li><li>快代理免费代理</li><li>Proxy360代理</li><li>全网代理IP</li></ol><p>获取网站的Cookies</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment">#coding:utf8</span><span class="hljs-keyword">import</span> http.cookiejar,urllib.requestcookie=http.cookiejar.CookieJar() <span class="hljs-comment">#实例化cookiejar对象</span>handler=urllib.request.HTTPCookieProcessor(cookie) <span class="hljs-comment">#构建一个handler</span>opener=urllib.request.build_opener(handler) <span class="hljs-comment">#构建Opener</span>response=opener.open(<span class="hljs-string">'http://www.baidu.com'</span>) <span class="hljs-comment">#请求</span>print(cookie)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cookie:    print(item.name+<span class="hljs-string">"="</span>+item.value)</code></pre></div><h4 id="7-异常处理"><a href="#7-异常处理" class="headerlink" title="7.异常处理"></a>7.异常处理</h4><p>urllib的error模块定义了由request模块产生的异常，如果出现问题，request模块便会抛出error模块中定义的异常。</p><p>1）URLError</p><p>URLError类来自urllib库的error模块，它继承自OSError类，是error异常模块的基类，由request模块产生的异常都可以通过捕获这个类来处理，它只有一个属性reason，即返回错误的原因</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request,error<span class="hljs-keyword">try</span>:    response=request.urlopen(<span class="hljs-string">'https://hehe,com/index'</span>)<span class="hljs-keyword">except</span> error.URLError <span class="hljs-keyword">as</span> e:    print(e.reason)  <span class="hljs-comment">#如果网页不存在不会抛出异常，而是返回捕获的异常错误的原因(Not Found)</span></code></pre></div><p> reason如超时则返回一个对象 </p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> urllib.error<span class="hljs-keyword">try</span>:    response=urllib.request.urlopen(<span class="hljs-string">'https://www.baidu.com'</span>,timeout=<span class="hljs-number">0.001</span>)<span class="hljs-keyword">except</span> urllib.error.URLError <span class="hljs-keyword">as</span> e:    print(e.reason)    <span class="hljs-keyword">if</span> isinstance(e.reason,socket.timeout):        print(<span class="hljs-string">'time out'</span>)</code></pre></div><p>2）HTTPError</p><p>它是URLError的子类，专门用来处理HTTP请求错误，比如认证请求失败，它有3个属性：</p><p>code：返回HTTP的状态码，如404页面不存在，500服务器错误等</p><p>reason：同父类，返回错误的原因</p><p>headers：返回请求头</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> request,error<span class="hljs-keyword">try</span>:    response=request.urlopen(<span class="hljs-string">'http://cuiqingcai.com/index.htm'</span>)<span class="hljs-keyword">except</span> error.HTTPError <span class="hljs-keyword">as</span> e:  <span class="hljs-comment">#先捕获子类异常</span>    print(e.reason,e.code,e.headers,sep=<span class="hljs-string">'\n'</span>)<span class="hljs-keyword">except</span> error.URLError <span class="hljs-keyword">as</span> e:  <span class="hljs-comment">#再捕获父类异常</span>    print(e.reason)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'request successfully'</span>)</code></pre></div><h3 id="二：方法二：requests"><a href="#二：方法二：requests" class="headerlink" title="二：方法二：requests"></a>二：方法二：requests</h3><p>requests是python实现的简单易用的HTTP库，使用起来比urllib简洁很多。因为是第三方库，所以使用前需要cmd安装：<strong>pip install requests</strong></p><p>安装完成后import一下，正常则说明可以开始使用了。</p><h4 id="1-发起请求"><a href="#1-发起请求" class="headerlink" title="1.发起请求"></a>1.发起请求</h4><p>基本用法：<strong>requests.get()用于请求目标网站，类型是一个HTTPresponse类型</strong></p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsurl=<span class="hljs-string">"http://httpbin.org/get"</span>data=&#123;<span class="hljs-string">"keywords"</span>:<span class="hljs-string">"itcast"</span>&#125;headers=&#123;<span class="hljs-string">"User-Agent"</span>:<span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36"</span>&#125;response = requests.get(url,headers=headers,params=data)print(response.text)</code></pre></div><div class="hljs"><pre><code class="hljs python">&#123;  <span class="hljs-string">"args"</span>: &#123;    <span class="hljs-string">"keywords"</span>: <span class="hljs-string">"itcast"</span>  &#125;,   <span class="hljs-string">"headers"</span>: &#123;    <span class="hljs-string">"Accept"</span>: <span class="hljs-string">"*/*"</span>,     <span class="hljs-string">"Accept-Encoding"</span>: <span class="hljs-string">"gzip, deflate"</span>,     <span class="hljs-string">"Host"</span>: <span class="hljs-string">"httpbin.org"</span>,     <span class="hljs-string">"User-Agent"</span>: <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36"</span>  &#125;,   <span class="hljs-string">"origin"</span>: <span class="hljs-string">"118.123.252.136, 118.123.252.136"</span>,   <span class="hljs-string">"url"</span>: <span class="hljs-string">"https://httpbin.org/get?keywords=itcast"</span>&#125;</code></pre></div><p>还可以将参数放在url中发送get请求</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsresponse = requests.get(http://httpbin.org/get?name=gemey&amp;age=22)print(response.text)</code></pre></div><p>除了提出get请求，还可以发出以下几个请求：</p><div class="hljs"><pre><code class="hljs python">requests.get(<span class="hljs-string">'http://httpbin.org/get'</span>)requests.post(<span class="hljs-string">'http://httpbin.org/post'</span>)requests.put(<span class="hljs-string">'http://httpbin.org/put'</span>)requests.delete(<span class="hljs-string">'http://httpbin.org/delete'</span>)requests.head(<span class="hljs-string">'http://httpbin.org/get'</span>)requests.options(<span class="hljs-string">'http://httpbin.org/get'</span>)</code></pre></div><h4 id="2-带参数的请求"><a href="#2-带参数的请求" class="headerlink" title="2.带参数的请求"></a>2.带参数的请求</h4><p><strong>1.URL参数</strong></p><p>使用方法：</p><div class="hljs"><pre><code class="hljs python">requests.get(url,params=&#123;<span class="hljs-string">'key1'</span>:<span class="hljs-string">'value1'</span>&#125;,proxies=proxy)</code></pre></div><p><strong>2.表单参数提交</strong></p><p>Content-Type:application.x-www-form-urlencoded <em>(表单默认的提交数据格式)</em></p><p>内容：key1=value1&amp;key2=value2</p><div class="hljs"><pre><code class="hljs python">requests.post(url,data=&#123;<span class="hljs-string">'key1'</span>:<span class="hljs-string">'value1'</span>,<span class="hljs-string">'key2'</span>:<span class="hljs-string">'value2'</span>&#125;,proxies=proxy)</code></pre></div><p><strong>3.json参数提交</strong></p><p>Content-Type: appliction/json <em>(json数据格式)</em></p><p>内容：’{“key”:”value1”,”key2”:”value2”}’</p><div class="hljs"><pre><code class="hljs python">requests.post(url,json=&#123;<span class="hljs-string">'key1'</span>:<span class="hljs-string">'value1'</span>,<span class="hljs-string">'key2'</span>:<span class="hljs-string">'value2'</span>&#125;,proxies=proxy)</code></pre></div><h4 id="3-Response对象"><a href="#3-Response对象" class="headerlink" title="3.Response对象"></a>3.Response对象</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requestsresponse = requests.get(<span class="hljs-string">'http://www.baidu.com'</span>)print(response.status_code)  <span class="hljs-comment"># 打印状态码</span>print(response.url)          <span class="hljs-comment"># 打印请求url</span>print(response.headers)      <span class="hljs-comment"># 打印头信息</span>print(response.cookies)      <span class="hljs-comment"># 打印cookie信息</span>print(response.text)  <span class="hljs-comment">#以文本形式打印网页源码</span>print(response.content) <span class="hljs-comment">#以字节流形式打印</span></code></pre></div><h4 id="4-异常捕获"><a href="#4-异常捕获" class="headerlink" title="4.异常捕获"></a>4.异常捕获</h4><p>在你不确定会发生什么错误时，尽量使用try…except来捕获异常。所有的requests.exception：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> requests.exceptions <span class="hljs-keyword">import</span> ReadTimeout,HTTPError,RequestException<span class="hljs-keyword">try</span>:    response = requests.get(<span class="hljs-string">'http://www.baidu.com'</span>,timeout=<span class="hljs-number">0.5</span>)    print(response.status_code)<span class="hljs-keyword">except</span> ReadTimeout:    print(<span class="hljs-string">'timeout'</span>)<span class="hljs-keyword">except</span> HTTPError:    print(<span class="hljs-string">'httperror'</span>)<span class="hljs-keyword">except</span> RequestException:    print(<span class="hljs-string">'reqerror'</span>)</code></pre></div><p> requests库将常见的http错误打了一个包，就是exceptions，通过使用exceptions可以处理项目中各种异常 </p><div class="hljs"><pre><code class="hljs python">RequestException:HTTPError(RequestException) 　UnrewindableBodyError(RequestException) 　RetryError(RequestException) 　ConnectionError(RequestException) ProxyError(ConnectionError)SSLError(ConnectionError)ConnectTimeout(ConnectionError, Timeout)Timeout(RequestException) ReadTimeoutURLRequired(RequestException) 　TooManyRedirects(RequestException) 　MissingSchema(RequestException, ValueError) 　InvalidSchema(RequestException,ValueError) 　InvalidURL(RequestException,ValueError) 　InvalidHeader(RequestException,ValueError) 　ChunkedEncodingError(RequestException) 　StreamConsumedError(RequestException,TypeError) 　ContentDecodingError(RequestException,BaseHTTPError)</code></pre></div><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><img src="/2020/07/22/%E8%A7%A3%E6%9E%90%E7%88%AC%E8%99%AB/image-20191205102155060.png" srcset="/img/loading.gif" alt="image-20191205102155060" style="zoom:67%;"><p>爬取“沈阳化工大学”贴吧的帖子回复数，主题和发帖人的信息</p><p>分析url地址：</p><div class="hljs"><pre><code class="hljs python">http://tieba.baidu.com/f?kw=xxx&amp;ie=utf-8&amp;pn=0 #第一页的内容http://tieba.baidu.com/f?kw=xxx&amp;ie=utf-8&amp;pn=50 #第二页的内容http://tieba.baidu.com/f?kw=xxx&amp;ie=utf-8&amp;pn=100 #第三页的内容</code></pre></div><p>下面使用两种方法进行页面信息的爬取</p><h4 id="1-使用requests方法"><a href="#1-使用requests方法" class="headerlink" title="1.使用requests方法"></a>1.使用requests方法</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree <span class="hljs-keyword">as</span> et<span class="hljs-keyword">import</span> json<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSpider</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.keyword=input(<span class="hljs-string">"输入要爬取的贴吧名："</span>)        self.start_page=int(input(<span class="hljs-string">"输入起始页码："</span>))        self.end_page=int(input(<span class="hljs-string">"输入结束页码："</span>))        self.base_url=<span class="hljs-string">"http://tieba.baidu.com/"</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_page</span><span class="hljs-params">(self)</span>:</span>        user_agent=<span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36"</span>        header=&#123;<span class="hljs-string">"User-Agent"</span>:user_agent&#125;        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(self.start_page,self.end_page+<span class="hljs-number">1</span>):            <span class="hljs-comment">#newkeyword=bytes(self.keyword).encode('utf-8')</span>            new_url=self.base_url+<span class="hljs-string">"f?kw="</span>+self.keyword+<span class="hljs-string">"&amp;ie=utf-8&amp;pn="</span>+str((page<span class="hljs-number">-1</span>)*<span class="hljs-number">50</span>)            print(new_url)            response = requests.get(new_url,headers=header)            self.parse_page(response.text)                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_page</span><span class="hljs-params">(self,html)</span>:</span>        html_new=html.replace(<span class="hljs-string">r'&lt;!--'</span>,<span class="hljs-string">'"'</span>).replace(<span class="hljs-string">r'--&gt;'</span>,<span class="hljs-string">'"'</span>)        root=et.HTML(html_new)        replynum=root.xpath(<span class="hljs-string">"//ul[@id='thread_list']/li/div/div[1]//span/text()"</span>)        title=root.xpath(<span class="hljs-string">"//ul[@id='thread_list']/li/div//a[@class='j_th_tit ']/text()"</span>)        <span class="hljs-comment">#//ul[@id='thread_list']/li/div/div[2]/div[2]/div[1]/div/text()</span>        url=root.xpath(<span class="hljs-string">"//ul[@id='thread_list']/li/div//a[@class='j_th_tit ']/@href"</span>)        author=root.xpath(<span class="hljs-string">"//ul[@id='thread_list']/li/div/div[2]/div[1]/div[2]/span[1]/@title"</span>)        self.append_page(replynum,title,url,author)            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append_page</span><span class="hljs-params">(self,replynum,title,url,author)</span>:</span>        minsize=min(len(replynum),len(title),len(url),len(author))        items=[]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(minsize):            item=&#123;&#125;            item[<span class="hljs-string">"回复人数"</span>]=replynum[i]            item[<span class="hljs-string">"帖子题目"</span>]=title[i]            item[<span class="hljs-string">"帖子链接"</span>]=self.base_url+url[i]            item[<span class="hljs-string">"作者"</span>]=author[i]            items.append(item)        self.save_json(items)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_json</span><span class="hljs-params">(self,items)</span>:</span>        <span class="hljs-keyword">try</span>:            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(items)):                strr = json.dumps(items[i],ensure_ascii=<span class="hljs-literal">False</span>)                ff = open(self.keyword+<span class="hljs-string">".json"</span>,<span class="hljs-string">"a"</span>,encoding=<span class="hljs-string">'utf-8'</span>)                ff.write(strr)                ff.write(<span class="hljs-string">"\n\n"</span>)                ff.close()            print(<span class="hljs-string">"保存完毕"</span>)        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> ex:            print(<span class="hljs-string">"保存失败"</span>)            print(ex)            <span class="hljs-keyword">if</span> __name__==<span class="hljs-string">"__main__"</span>:    spider = WebSpider()    spider.load_page()</code></pre></div><img src="/2020/07/22/%E8%A7%A3%E6%9E%90%E7%88%AC%E8%99%AB/image-20191205211731504.png" srcset="/img/loading.gif" alt="image-20191205102155060"><h4 id="2-使用urllib方法"><a href="#2-使用urllib方法" class="headerlink" title="2.使用urllib方法"></a>2.使用urllib方法</h4><p>代码主体与上面的一样，下面只列出不同的函数</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> urllib.request<span class="hljs-keyword">import</span> urllib.parse<span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree <span class="hljs-keyword">as</span> et<span class="hljs-keyword">import</span> json<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_page</span><span class="hljs-params">(self)</span>:</span>        user_agent=<span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36"</span>        header=&#123;<span class="hljs-string">"User-Agent"</span>:user_agent&#125;        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> range(self.start_page,self.end_page+<span class="hljs-number">1</span>):            new_url=self.base_url+<span class="hljs-string">"f?kw="</span>+self.keyword+<span class="hljs-string">"&amp;ie=utf-8&amp;pn="</span>+str((page<span class="hljs-number">-1</span>)*<span class="hljs-number">50</span>)            print(new_url)            response = urllib.request.urlopen(urllib.request.Request(new_url,headers=header))            self.parse_page(response.read().decode(<span class="hljs-string">"utf-8"</span>))</code></pre></div><h2 id="（二）爬取动态内容"><a href="#（二）爬取动态内容" class="headerlink" title="（二）爬取动态内容"></a>（二）爬取动态内容</h2><p>提前安装好Selenium+chromedriver</p><h3 id="一：入门操作"><a href="#一：入门操作" class="headerlink" title="一：入门操作"></a>一：入门操作</h3><p>通常所有的操作与页面交互都将通过WebElement接口，常见的操作元素方法如下：</p><div class="hljs"><pre><code class="hljs python">clear() <span class="hljs-comment">#清除元素的内容</span>send_keys() <span class="hljs-comment">#模拟按键输入</span>click() <span class="hljs-comment">#点击元素</span>submit() <span class="hljs-comment">#提交表单</span></code></pre></div><p>通过WebElement接口可以获取常用的值，这些值同样非常重要。</p><div class="hljs"><pre><code class="hljs python">size <span class="hljs-comment">#获取元素的尺寸</span>text <span class="hljs-comment">#获取元素的文本  !!!</span>get_attribute(name) <span class="hljs-comment">#获取属性值  !!!!!!</span>location <span class="hljs-comment">#获取元素坐标，先找到要获取的元素，再调用该方法</span>page_source <span class="hljs-comment">#返回页面源码  !!!</span>driver.title <span class="hljs-comment">#返回页面标题 !!!</span>current_url <span class="hljs-comment">#获取当前页面的URL  !!!</span>is_displayed() <span class="hljs-comment">#设置该元素是否可见</span>is_enabled() <span class="hljs-comment">#判断元素是否被使用</span>is_selected() <span class="hljs-comment">#判断元素是否被选中</span>tag_name <span class="hljs-comment">#返回元素的tagName</span></code></pre></div><p>下面一次进行演示:</p><h4 id="1-打开页面"><a href="#1-打开页面" class="headerlink" title="1.打开页面"></a>1.打开页面</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriverbrowser=webdriver.Chrome()<span class="hljs-comment">#获取页面</span>browser.get(<span class="hljs-string">"http://baidu.com/"</span>)</code></pre></div><p>这一步执行完会自动打开一个浏览器，浏览器中打开相应的百度页面，如果出现data;，这样的Tab，那么说明你的chrome浏览器和chromedriver的版本不一致造成的。</p><h4 id="2-获取页面名为wrapper的id标签的文本内容"><a href="#2-获取页面名为wrapper的id标签的文本内容" class="headerlink" title="2.获取页面名为wrapper的id标签的文本内容"></a>2.获取页面名为wrapper的id标签的文本内容</h4><div class="hljs"><pre><code class="hljs python">data=browser.find_element_by_id(<span class="hljs-string">"wrapper"</span>).textprint(data)</code></pre></div><h4 id="3-打印页面标题"><a href="#3-打印页面标题" class="headerlink" title="3.打印页面标题"></a>3.打印页面标题</h4><div class="hljs"><pre><code class="hljs python">print(browser.title)</code></pre></div><h4 id="4-打印页面源代码（浏览器执行完后的页面）"><a href="#4-打印页面源代码（浏览器执行完后的页面）" class="headerlink" title="4.打印页面源代码（浏览器执行完后的页面）"></a>4.打印页面源代码（浏览器执行完后的页面）</h4><div class="hljs"><pre><code class="hljs python">print(browser.page_source)</code></pre></div><h4 id="5-向表单添加内容，并进行搜索，截图"><a href="#5-向表单添加内容，并进行搜索，截图" class="headerlink" title="5.向表单添加内容，并进行搜索，截图"></a>5.向表单添加内容，并进行搜索，截图</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<span class="hljs-keyword">import</span> timebrowser.get(<span class="hljs-string">"http://baidu.com/"</span>)browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(<span class="hljs-string">u"沈阳化工大学"</span>)browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(Keys.RETURN)time.sleep(<span class="hljs-number">2</span>)browser.save_screenshot(<span class="hljs-string">"baidu.png"</span>)</code></pre></div><p>send_keys()方法的作用就是往页面元素上添加内容。此时，再次打开baidu.png时，可以看到“长城”已经添加带百度页面的搜索框中，并截下图了。</p><h4 id="6-模拟点击页面上的按钮"><a href="#6-模拟点击页面上的按钮" class="headerlink" title="6.模拟点击页面上的按钮"></a>6.模拟点击页面上的按钮</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> timebrowser.get(<span class="hljs-string">"http://baidu.com/"</span>)browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(<span class="hljs-string">u"沈阳化工大学"</span>)browser.find_element_by_id(<span class="hljs-string">"su"</span>).click()time.sleep(<span class="hljs-number">2</span>)browser.save_screenshot(<span class="hljs-string">"baidu1.png"</span>)</code></pre></div><p>结果同上图一样</p><h4 id="7-调用键盘操作Keys包"><a href="#7-调用键盘操作Keys包" class="headerlink" title="7.调用键盘操作Keys包"></a>7.调用键盘操作Keys包</h4><p> 前面讲述了鼠标操作，现在讲述键盘操作。在webdriver的Keys类中提供了键盘所有的按键操作，当然也包括一些常见的组合键操作如Ctrl+A(全选)、Ctrl+C(复制)、Ctrl+V(粘贴)。更多键参考官方文档对应的编码。</p><div class="hljs"><pre><code class="hljs python">send_keys(Keys.ENTER) <span class="hljs-comment">#按下回车键</span>send_keys(Keys.TAB) <span class="hljs-comment">#按下Tab制表键</span>send_keys(Keys.SPACE) <span class="hljs-comment">#按下空格键space</span>send_keys(Kyes.ESCAPE) <span class="hljs-comment">#按下回退键Esc</span>send_keys(Keys.BACK_SPACE) <span class="hljs-comment">#按下删除键BackSpace</span>send_keys(Keys.SHIFT) <span class="hljs-comment">#按下shift键</span>send_keys(Keys.CONTROL) <span class="hljs-comment">#按下Ctrl键</span>send_keys(Keys.ARROW_DOWN) <span class="hljs-comment">#按下鼠标光标向下按键</span>send_keys(Keys.CONTROL,<span class="hljs-string">'a'</span>) <span class="hljs-comment">#组合键全选Ctrl``+``A</span>send_keys(Keys.CONTROL,<span class="hljs-string">'c'</span>) <span class="hljs-comment">#组合键复制Ctrl``+``C</span>send_keys(Keys.CONTROL,<span class="hljs-string">'x'</span>) <span class="hljs-comment">#组合键剪切Ctrl``+``X</span>send_keys(Keys.CONTROL,<span class="hljs-string">'v'</span>) <span class="hljs-comment">#组合键粘贴Ctrl``+``V</span></code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys</code></pre></div><h5 id="通过模拟【Ctrl-A】键全选输入框内容"><a href="#通过模拟【Ctrl-A】键全选输入框内容" class="headerlink" title="通过模拟【Ctrl+A】键全选输入框内容"></a>通过模拟【Ctrl+A】键全选输入框内容</h5><div class="hljs"><pre><code class="hljs python">browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(Keys.CONTROL,<span class="hljs-string">'a'</span>)</code></pre></div><h5 id="通过模拟【Ctrl-C】键复制输入框内容"><a href="#通过模拟【Ctrl-C】键复制输入框内容" class="headerlink" title="通过模拟【Ctrl+C】键复制输入框内容"></a>通过模拟【Ctrl+C】键复制输入框内容</h5><div class="hljs"><pre><code class="hljs python">browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(Keys.CONTROL,<span class="hljs-string">'c'</span>)</code></pre></div><h5 id="通过模拟【Enter】键复制输入框内容"><a href="#通过模拟【Enter】键复制输入框内容" class="headerlink" title="通过模拟【Enter】键复制输入框内容"></a>通过模拟【Enter】键复制输入框内容</h5><div class="hljs"><pre><code class="hljs python">browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(<span class="hljs-string">u"沈阳化工大学"</span>)browser.find_element_by_id(<span class="hljs-string">"kw"</span>).send_keys(Keys.RETURN)</code></pre></div><h4 id="8-清除输入框内容"><a href="#8-清除输入框内容" class="headerlink" title="8.清除输入框内容"></a>8.清除输入框内容</h4><div class="hljs"><pre><code class="hljs python">browser.find_element_by_id(<span class="hljs-string">"kw"</span>).clear()</code></pre></div><h4 id="9-提交表单"><a href="#9-提交表单" class="headerlink" title="9.提交表单"></a>9.提交表单</h4><div class="hljs"><pre><code class="hljs python">driver.find_element_by_id(<span class="hljs-string">"loginBtn"</span>).click()driver.find_element_by_id(<span class="hljs-string">"loginBtn"</span>).submit()</code></pre></div><h4 id="10-获取当前页面的Cookie"><a href="#10-获取当前页面的Cookie" class="headerlink" title="10.获取当前页面的Cookie"></a>10.获取当前页面的Cookie</h4><div class="hljs"><pre><code class="hljs python">browser.get_cookies()</code></pre></div><h4 id="11-获取当前URL"><a href="#11-获取当前URL" class="headerlink" title="11.获取当前URL"></a>11.获取当前URL</h4><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">browser</span><span class="hljs-selector-class">.current_url</span></code></pre></div><h4 id="12-关闭"><a href="#12-关闭" class="headerlink" title="12.关闭"></a>12.关闭</h4><div class="hljs"><pre><code class="hljs python">browser.close()<span class="hljs-comment">#关闭当前页面，如果只有一个页面，关闭浏览器</span>browser.quit()<span class="hljs-comment">#关闭浏览器</span></code></pre></div><h3 id="二-定位UI元素"><a href="#二-定位UI元素" class="headerlink" title="二:定位UI元素"></a>二:定位UI元素</h3><p>这里有各种策略用于定位网页中的元素(locate elements)，你可以选择最适合的方案，Selenium提供了一下方法来定义一个页面中的元素：</p><h4 id="1-查找单个元素"><a href="#1-查找单个元素" class="headerlink" title="1.查找单个元素"></a>1.查找单个元素</h4><div class="hljs"><pre><code class="hljs python">find_element_by_idfind_element_by_namefind_element_by_xpathfind_element_by_link_text <span class="hljs-comment">#根据链接文本定位到页面元素</span>find_element_by_partial_link_text<span class="hljs-comment">#根据部分链接文本定位到页面元素</span>find_element_by_tag_namefind_element_by_class_namefind_element_by_css_selector<span class="hljs-comment">#在这个函数中写选择器语句，比如：“#food span.dairy.aged”</span></code></pre></div><h4 id="2-查找多个元素"><a href="#2-查找多个元素" class="headerlink" title="2.查找多个元素"></a>2.查找多个元素</h4><p> 下面是查找多个元素（这些方法将返回一个列表）：</p><div class="hljs"><pre><code class="hljs python">find_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector</code></pre></div><h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h4><p>常用方法是通过xpath相对路径进行定位，同时CSS也是比较好的方法。举例：</p><div class="hljs"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"loginForm"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"continue"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Login"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"continue"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Clear"</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>定位username元素的方法如下：</p><div class="hljs"><pre><code class="hljs python">username = driver.find_element_by_xpath(<span class="hljs-string">"//form[input/@name='username']"</span>)username = driver.find_element_by_xpath(<span class="hljs-string">"//form[@id='loginForm']/input[1]"</span>)username = driver.find_element_by_xpath(<span class="hljs-string">"//input[@name='username']"</span>)</code></pre></div><p>​    [1] 第一个form元素通过一个input子元素，name属性和值为username实现<br>​    [2] 通过id=loginForm值的form元素找到第一个input子元素<br>​    [3] 属性名为name且值为username的第一个input元素</p><h3 id="三-鼠标操作"><a href="#三-鼠标操作" class="headerlink" title="三:鼠标操作"></a>三:鼠标操作</h3><p>在现实的自动化测试中关于鼠标的操作不仅仅是click()单击操作，还有很多包含在<em>ActionChains类</em>中的操作。如下：</p><div class="hljs"><pre><code class="hljs python">click(elem) <span class="hljs-comment">#鼠标点击元素elem</span>context_click(elem) <span class="hljs-comment">#右击鼠标点击元素elem，另存为等行为</span>double_click(elem) <span class="hljs-comment">#双击鼠标点击元素elem，地图web可实现放大功能</span>drag_and_drop(source,target) <span class="hljs-comment">#拖动鼠标，源元素按下左键移动至目标元素释放</span>move_to_element(elem) <span class="hljs-comment">#鼠标移动到一个元素上</span>click_and_hold(elem) <span class="hljs-comment">#按下鼠标左键在一个元素上并保持住</span>perform() <span class="hljs-comment">#在通过调用该函数执行ActionChains中存储行为</span></code></pre></div><p>举例如下图所示，获取通过鼠标右键另存为百度图片logo。代码：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys<span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChainsdriver = webdriver.Chrome()driver.get(<span class="hljs-string">"http://www.baidu.com"</span>)<span class="hljs-comment">#鼠标移动至图片上 右键保存图片</span>elem_pic = driver.find_element_by_xpath(<span class="hljs-string">"//div[@id='lg']/img[1]"</span>)print(elem_pic.get_attribute(<span class="hljs-string">"src"</span>))action = ActionChains(driver).move_to_element(elem_pic).context_click(elem_pic)<span class="hljs-comment">#重点:当右键鼠标点击键盘光标向下则移动至右键菜单第一个选项</span>action.send_keys(Keys.ARROW_DOWN)time.sleep(<span class="hljs-number">3</span>)action.send_keys(<span class="hljs-string">'v'</span>) <span class="hljs-comment">#另存为</span>action.perform()</code></pre></div><h3 id="四-填充表单"><a href="#四-填充表单" class="headerlink" title="四:填充表单"></a>四:填充表单</h3><p>对于下拉菜单（Select）的操作，Selenium有专门的类Select进行处理。</p><p>页面HTML源码如下所示：</p><select id="nr" name="NR"><option value="10" selected>每页显示10条</option><option value="20">每页显示20条</option><option value="50">每页显示50条</option></select><h4 id="1-Select提供了三种选择方法："><a href="#1-Select提供了三种选择方法：" class="headerlink" title="1.Select提供了三种选择方法："></a>1.Select提供了三种选择方法：</h4><div class="hljs"><pre><code class="hljs python">select_by_index(index) <span class="hljs-comment">#通过选项的顺序，第一个为 0</span>select_by_value(value) <span class="hljs-comment">#通过value属性</span>select_by_visible_text(text) <span class="hljs-comment">#通过选项可见文本</span></code></pre></div><h4 id="2-Select提供了四种方法取消选择："><a href="#2-Select提供了四种方法取消选择：" class="headerlink" title="2.Select提供了四种方法取消选择："></a>2.Select提供了四种方法取消选择：</h4><div class="hljs"><pre><code class="hljs python">deselect_by_index(index)deselect_by_value(value)deselect_by_visible_text(text)deselect_all()</code></pre></div><h4 id="3-Select提供了三个属性方法提供信息："><a href="#3-Select提供了三个属性方法提供信息：" class="headerlink" title="3.Select提供了三个属性方法提供信息："></a>3.Select提供了三个属性方法提供信息：</h4><div class="hljs"><pre><code class="hljs python">options <span class="hljs-comment">#提供所有的选项的列表，其中都是选项的WebElement元素</span>all_selected_options <span class="hljs-comment">#提供所有被选中的选项的列表，其中也均为选项的WebElement元素</span>first_selected_option <span class="hljs-comment">#提供第一个被选中的选项，也是下拉框的默认值</span></code></pre></div><p>通过Select提供的方法和属性，我们可以对标准select下拉框进行任何操作，但是对于非select标签的伪下拉框，需要使用XPath定位；</p><h4 id="4-示例"><a href="#4-示例" class="headerlink" title="4.示例"></a>4.示例</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<span class="hljs-keyword">from</span> selenium.webdriver.support.select <span class="hljs-keyword">import</span> Select<span class="hljs-keyword">import</span> time driver = webdriver.Chrome()driver.get(<span class="hljs-string">"https://www.baidu.com/"</span>)driver.implicitly_wait(<span class="hljs-number">20</span>) mouse = driver.find_element_by_link_text(<span class="hljs-string">"设置"</span>)ActionChains(driver).move_to_element(mouse).perform()driver.find_element_by_link_text(<span class="hljs-string">"搜索设置"</span>).click()time.sleep(<span class="hljs-number">2</span>)<span class="hljs-comment"># 实例化select</span>s = Select(driver.find_element_by_id(<span class="hljs-string">"nr"</span>))<span class="hljs-comment"># 定位选项</span>s.select_by_value(<span class="hljs-string">"20"</span>)  <span class="hljs-comment"># 选择value="20"的项：通过value属性</span>time.sleep(<span class="hljs-number">2</span>)   <span class="hljs-comment">#为了明显的看出变化</span>s.select_by_index(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 选择第一项选项：通过选项的顺序选择，第一个为 0</span>time.sleep(<span class="hljs-number">2</span>)   <span class="hljs-comment">#为了明显的看出变化</span>s.select_by_visible_text(<span class="hljs-string">"每页显示50条"</span>)  <span class="hljs-comment"># 选择text="每页显示50条"的值，即在下拉时我们可以看到的文本</span></code></pre></div><h3 id="五-弹窗处理"><a href="#五-弹窗处理" class="headerlink" title="五:弹窗处理"></a>五:弹窗处理</h3><p>弹出框有两种：页面弹出框（可定位元素能操作）、Windows弹出框（不能直接定位）</p><h4 id="1-页面弹出框"><a href="#1-页面弹出框" class="headerlink" title="1.页面弹出框"></a><strong>1.页面弹出框</strong></h4><p>等待弹出框出现之后，定位弹出框，操作其中元素</p><div class="hljs"><pre><code class="hljs python">driver = webdriver.Chrome()driver.get(<span class="hljs-string">"https://www.baidu.com"</span>)driver.maximize_window()<span class="hljs-comment">#点击百度登录按钮</span>driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="u1"]//a[@name="tj_login"]'</span>).click()<span class="hljs-comment">#等待百度登录弹出框中 要出现的元素可见</span>ele_id = <span class="hljs-string">"TANGRAM__PSP_10__footerULoginBtn"</span>param = (By.ID,ele_id)<span class="hljs-comment">#元素可见时，再进行后续操作</span>WebDriverWait(driver,<span class="hljs-number">10</span>).until(EC.visibility_of_element_located(param))driver.find_element_by_id(ele_id).click()time.sleep(<span class="hljs-number">5</span>)driver.quit()</code></pre></div><h4 id="2-Windows弹出框"><a href="#2-Windows弹出框" class="headerlink" title="2.Windows弹出框"></a><strong>2.Windows弹出框</strong></h4><p>使用 driver.switch_to.alert 切换到Windows弹出框,Alert类提供了一系列操作方法：</p><div class="hljs"><pre><code class="hljs python">accept() <span class="hljs-comment">#确定</span>dismiss() <span class="hljs-comment">#取消</span>text() <span class="hljs-comment">#获取弹出框里面的内容</span>send_keys(keysToSend) <span class="hljs-comment">#输入字符串</span></code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#1:定位alert弹出框</span><span class="hljs-comment">#点击页面元素，触发alert弹出框</span>driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="alert"]'</span>).click()time.sleep(<span class="hljs-number">3</span>)<span class="hljs-comment">#等待alert弹出框可见</span>WebDriverWait(driver,<span class="hljs-number">20</span>).until(EC.alert_is_present())<span class="hljs-comment">#从html页面切换到alert弹框 </span>alert = driver.switch_to.alert<span class="hljs-comment">#获取alert的文本内容</span>print(alert.text)<span class="hljs-comment">#接受--选择“确定”</span>alert.accept()<span class="hljs-comment">#2:定位confirm弹出框</span>driver.find_element_by_xpath(<span class="hljs-string">'//*[@id="confirm"]'</span>).click()time.sleep(<span class="hljs-number">3</span>)WebDriverWait(driver,<span class="hljs-number">20</span>).until(EC.alert_is_present())alert =driver.switch_to.alertprint(alert.text)<span class="hljs-comment"># 接受--选择“取消”</span>alert.dismiss()<span class="hljs-comment">#3:定位prompt弹出框</span>driver.find_element_by_id(<span class="hljs-string">"prompt"</span>).click()time.sleep(<span class="hljs-number">3</span>)WebDriverWait(driver,<span class="hljs-number">20</span>).until(EC.alert_is_present())alert =driver.switch_to.alertalert.send_keys(<span class="hljs-string">"jaja"</span>)time.sleep(<span class="hljs-number">5</span>)print(alert.text)<span class="hljs-comment"># alert.dismiss()</span>alert.accept()</code></pre></div><h3 id="六-页面切换"><a href="#六-页面切换" class="headerlink" title="六:页面切换"></a>六:页面切换</h3><p>在打开新的浏览器窗口时，如果要定位新窗口的元素，需要先切换到这个新打开的窗口中，才能定位到该窗口下的元素。</p><h4 id="1-获取当前句柄"><a href="#1-获取当前句柄" class="headerlink" title="1.获取当前句柄"></a>1.获取当前句柄</h4><p>current_window_handle：获取当前句柄。可以把句柄理解成窗口的身份证</p><h4 id="2-获取所有打开窗口的句柄"><a href="#2-获取所有打开窗口的句柄" class="headerlink" title="2.获取所有打开窗口的句柄"></a>2.获取所有打开窗口的句柄</h4><p>window_handles：获取所有打开窗口的句柄</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">import</span> timedr = webdriver.Chrome()dr.get(<span class="hljs-string">'https://www.baidu.com'</span>)<span class="hljs-comment"># dr.maximize_window()</span>win_handle = dr.current_window_handle<span class="hljs-comment">#获取当前窗口句柄</span>print(win_handle)js = <span class="hljs-string">'window.open("http://news.baidu.com")'</span><span class="hljs-comment">#js打开新窗口</span>dr.execute_script(js)<span class="hljs-comment">#执行js</span>handles = dr.window_handles<span class="hljs-comment">#获取所有窗口句柄</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> handles:    <span class="hljs-keyword">if</span> i != win_handle:<span class="hljs-comment">#如果句柄不是当前窗口的句柄</span>        dr.switch_to.window(i)<span class="hljs-comment">#切换窗口</span>ww = dr.find_element_by_id(<span class="hljs-string">'ww'</span>)<span class="hljs-comment">#新闻页面的搜索输入框</span>ww.send_keys(<span class="hljs-string">'selenium'</span>)time.sleep(<span class="hljs-number">2</span>)dr.switch_to.window(win_handle)<span class="hljs-comment">#切换到百度首页的句柄</span>tr = dr.find_element_by_id(<span class="hljs-string">'kw'</span>)<span class="hljs-comment">#百度首页搜索框</span>tr.send_keys(<span class="hljs-string">'selenium'</span>)</code></pre></div><img src="/2020/07/22/%E8%A7%A3%E6%9E%90%E7%88%AC%E8%99%AB/70.jpg" srcset="/img/loading.gif" alt="i70.jpg"><p>这是打印出来的句柄</p><p>因为使用WebDriver点击百度新闻不会新打开一个页面，所以就通过js来模拟打开一个新网页了。通过循环所有句柄，当句柄不是当前窗口的句柄，就切换到这个窗口去。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<span class="hljs-keyword">import</span> timedr = webdriver.Chrome()dr.get(<span class="hljs-string">'https://www.baidu.com'</span>)dr.maximize_window()js = <span class="hljs-string">'window.open("http://news.baidu.com")'</span>dr.execute_script(js)handles = dr.window_handles<span class="hljs-comment">#获取所有窗口句柄</span>dr.switch_to.window(handles[<span class="hljs-number">1</span>])ww = dr.find_element_by_id(<span class="hljs-string">'ww'</span>)<span class="hljs-comment">#新闻页面的搜索输入框</span>ww.send_keys(<span class="hljs-string">'selenium'</span>)time.sleep(<span class="hljs-number">2</span>)dr.switch_to.window(handles[<span class="hljs-number">0</span>])tr = dr.find_element_by_id(<span class="hljs-string">'kw'</span>)<span class="hljs-comment">#百度首页搜索框</span>tr.send_keys(<span class="hljs-string">'selenium'</span>)dr.quit()</code></pre></div><p>所有窗口句柄是一个数组，可以通过数组的下标来访问相应的句柄，默认是按照打开窗口的顺序存的。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>爬虫</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Numpy中的高级索引</title>
    <link href="/2020/07/22/Numpy%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/07/22/Numpy%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p class="note note-primary">NumPy 比一般的 Python 序列提供更多的索引方式。除了基本的用整数和切片的索引外，数组可以由**整数数组索引**、**布尔索引**及**花式索引**。</p><h1 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h1><h2 id="（一）一维数组的索引"><a href="#（一）一维数组的索引" class="headerlink" title="（一）一维数组的索引"></a>（一）一维数组的索引</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  x = np.array([[<span class="hljs-number">1</span>,  <span class="hljs-number">2</span>],  [<span class="hljs-number">3</span>,  <span class="hljs-number">4</span>],  [<span class="hljs-number">5</span>,  <span class="hljs-number">6</span>]]) print(<span class="hljs-string">"原数组为:"</span>)print(x)<span class="hljs-comment">#行索引为[0,1,2],列索引为[0,1,0]</span>y = x[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>]] <span class="hljs-comment">#x[[0,1,2],  [0,1,0]]等价于：取出x中(0,0),(1,1),(2,0)位置的元素</span><span class="hljs-comment">#索引数组为[[0,0],[1,1],[2,0]]</span><span class="hljs-keyword">print</span> (<span class="hljs-string">"索引结果："</span>)<span class="hljs-keyword">print</span> (y)</code></pre></div><p>原数组为:<br>[[1 2]<br> [3 4]<br> [5 6]]<br>索引结果：<br>[1 4 5]</p><p>以上实例获取数组中(0,0)，(1,1)和(2,0)位置处的元素。</p><h2 id="（二）二维数组的索引"><a href="#（二）二维数组的索引" class="headerlink" title="（二）二维数组的索引"></a>（二）二维数组的索引</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  x = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]])<span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)<span class="hljs-comment">#行索引为[[0,0],[3,3]],列索引为[[0,2],[0,2]]</span>rows = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]]) cols = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]) y = x[rows,cols]  <span class="hljs-comment">#索引数组为[[0,0],[0,2],</span><span class="hljs-comment">#           [3,0],[3,2]]</span><span class="hljs-keyword">print</span>  (<span class="hljs-string">"索引结果："</span>)<span class="hljs-keyword">print</span> (y)</code></pre></div><p>原数组为:<br>[[ 0  1  2]<br> [ 3  4  5]<br> [ 6  7  8]<br> [ 9 10 11]]<br>索引结果：<br>[[ 0  2]<br> [ 9 11]]</p><h2 id="（三）切片索引"><a href="#（三）切片索引" class="headerlink" title="（三）切片索引"></a>（三）切片索引</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np a = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]])b = a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>]print(<span class="hljs-string">"切片索引："</span>)print(b)c = a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]]print(<span class="hljs-string">"切片索引+列表列索引："</span>)print(c)d = a[...,<span class="hljs-number">1</span>:]print(<span class="hljs-string">"...索引："</span>)print(d)</code></pre></div><p>切片索引：<br>[[5 6]<br> [8 9]]<br>切片索引+列表列索引：<br>[[5 6]<br> [8 9]]<br>…索引：<br>[[2 3]<br> [5 6]<br> [8 9]]</p><h1 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h1><p>我们可以通过一个布尔数组来索引目标数组。</p><p>布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。</p><p>以下实例获取大于 5 的元素：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  x = np.array([[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>],[<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>]])  <span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)<span class="hljs-comment"># 现在我们会打印出大于 5 的元素  </span>print(<span class="hljs-string">"布尔索引结果："</span>)print(x[x&gt;<span class="hljs-number">5</span>])</code></pre></div><p>原数组为:<br>[[ 0  1  2]<br> [ 3  4  5]<br> [ 6  7  8]<br> [ 9 10 11]]<br>布尔索引结果：<br>[ 6  7  8  9 10 11]</p><p>选去数组中不等于0的元素：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  x = np.array([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>])  <span class="hljs-keyword">print</span> (x[x!=<span class="hljs-number">0</span>])</code></pre></div><p>[1 2 3 4 5]</p><h2 id="（一）一维数组的索引-1"><a href="#（一）一维数组的索引-1" class="headerlink" title="（一）一维数组的索引"></a>（一）一维数组的索引</h2><p>布尔数组中，下标为0,3,4的位置是True，因此将会取出目标数组中对应位置的元素。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np x=np.arange(<span class="hljs-number">7</span>)<span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)boolean= np.array([<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>])print(<span class="hljs-string">"索引结果："</span>)print(x[boolean])</code></pre></div><p>原数组为:<br>[0 1 2 3 4 5 6]<br>索引结果：<br>[0 3 4]</p><h2 id="（二）二维数组的索引-1"><a href="#（二）二维数组的索引-1" class="headerlink" title="（二）二维数组的索引"></a>（二）二维数组的索引</h2><p>布尔数组中，下标为0,3,4的位置是True，因此将会取出目标数组中第0,3,4行。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np x=np.arange(<span class="hljs-number">28</span>).reshape((<span class="hljs-number">7</span>,<span class="hljs-number">4</span>))<span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)boolean=np.array([<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">True</span>,<span class="hljs-literal">False</span>,<span class="hljs-literal">False</span>])<span class="hljs-comment">#布尔数组的维度要与原数组的维度相同</span>print(<span class="hljs-string">"索引结果："</span>)print(x[boolean])</code></pre></div><p>原数组为:<br>[[ 0  1  2  3]<br> [ 4  5  6  7]<br> [ 8  9 10 11]<br> [12 13 14 15]<br> [16 17 18 19]<br> [20 21 22 23]<br> [24 25 26 27]]<br>索引结果：<br>[[ 0  1  2  3]<br> [12 13 14 15]<br> [16 17 18 19]]</p><h1 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h1><p>花式索引指的是利用整数数组进行索引。</p><p>花式索引根据索引数组的值作为目标数组的某个轴的下标来取值。对于使用一维整型数组作为索引，如果目标是一维数组，那么索引的结果就是对应位置的元素；如果目标是二维数组，那么就是对应下标的行。</p><p>花式索引跟切片不一样，它总是将数据复制到新数组中。</p><h2 id="（一）一维数组的花式索引"><a href="#（一）一维数组的花式索引" class="headerlink" title="（一）一维数组的花式索引"></a>（一）一维数组的花式索引</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np x=np.array([<span class="hljs-string">'0'</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'2'</span>,<span class="hljs-string">'3'</span>,<span class="hljs-string">'4'</span>])<span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)print(<span class="hljs-string">"索引结果："</span>)print(x[[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]])</code></pre></div><p>原数组为:<br>[‘0’ ‘1’ ‘2’ ‘3’ ‘4’]<br>索引结果：<br>[‘1’ ‘4’]</p><h2 id="（二）二维数组的花式索引"><a href="#（二）二维数组的花式索引" class="headerlink" title="（二）二维数组的花式索引"></a>（二）二维数组的花式索引</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  x=np.empty((<span class="hljs-number">8</span>,<span class="hljs-number">4</span>),dtype=np.int)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    x[i]=i<span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)print(<span class="hljs-string">"索引结果1："</span>)print(x[[<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">6</span>]])print(<span class="hljs-string">"索引结果2："</span>)print(x[[<span class="hljs-number">-3</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">-7</span>]])</code></pre></div><p>原数组为:<br>[[0 0 0 0]<br> [1 1 1 1]<br> [2 2 2 2]<br> [3 3 3 3]<br> [4 4 4 4]<br> [5 5 5 5]<br> [6 6 6 6]<br> [7 7 7 7]]<br>索引结果1：<br>[[4 4 4 4]<br> [3 3 3 3]<br> [0 0 0 0]<br> [6 6 6 6]]<br>索引结果2：<br>[[5 5 5 5]<br> [3 3 3 3]<br> [1 1 1 1]]</p><p>对于使用两个整型数组作为索引的时候，那么结果是按照顺序取出对应轴的对应下标的值。<strong>特别注意</strong>，这两个整型数组的shape应该一致，或者其中一个数组应该是长度为1的一维数组（与NumPy的Broadcasting机制于关系）。例如，以[1,3,5],[2,4,6]这两个整型数组作为索引，那么对于二维数组，则取出(1,2),(3,4),(5,6)这些坐标对应的元素。</p><div class="hljs"><pre><code class="hljs python">x=np.arange(<span class="hljs-number">42</span>).reshape(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)<span class="hljs-keyword">print</span> (<span class="hljs-string">"原数组为:"</span>)<span class="hljs-keyword">print</span> (x)print(<span class="hljs-string">"索引结果："</span>)print(x[[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>]])</code></pre></div><p>原数组为:<br>[[ 0  1  2  3  4  5  6]<br> [ 7  8  9 10 11 12 13]<br> [14 15 16 17 18 19 20]<br> [21 22 23 24 25 26 27]<br> [28 29 30 31 32 33 34]<br> [35 36 37 38 39 40 41]]<br>索引结果：<br>[ 9 25 41]</p><p>结果与整数数组索引的相同</p><p>传入多个索引数组（要使用np.ix_）</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np  x=np.arange(<span class="hljs-number">32</span>).reshape((<span class="hljs-number">8</span>,<span class="hljs-number">4</span>))<span class="hljs-comment">#np.ix_()里扔进两个一维数组[1,5,7,2]，[0,3,1,2]，就能先按我们要求选取行，再按顺序将列排序</span><span class="hljs-keyword">print</span> (x[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])])</code></pre></div><p>[[ 4  7  5  6]<br> [20 23 21 22]<br> [28 31 29 30]<br> [ 8 11  9 10]]</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
      <category>Numpy</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
      <tag>NumPy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flutter-页面布局（一）</title>
    <link href="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Align组件"><a href="#1-Align组件" class="headerlink" title="1.Align组件"></a>1.Align组件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般来说，Align的使用都是其他控件的一个参数，目的是为了设置子child的对齐方式，比如居中，左上，右下等多个对齐方向，其本身用法也多灵活。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><div class="hljs"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> Align(&#123; Key key, <span class="hljs-keyword">this</span>.alignment = Alignment.center, <span class="hljs-keyword">this</span>.widthFactor, <span class="hljs-keyword">this</span>.heightFactor, Widget child &#125;)</code></pre></div><ul><li><p>alignment 设置对齐方向，使有多种使用方式：<br>比如：<code>FractionalOffset(0.5, 0.5)</code> == <code>Alignment(0.0,0.0)</code> == <code>Alignment.center</code> ，都是将子child居中对齐的控制方式</p><p>Alignment(0.0,0.0)表示矩形的中心。从-1.0到+1.0的距离是矩形的一边到另一边的距离。<br>而Alignment中还可以这样使用对齐方式的控制，也是较为常用的使用方式：</p><p>即本质就是类似于语法糖将各个方向的对齐方式简单封装了下。<br><u>FractionalOffset(1, 1) 类似Alignment() 但是坐标起点是左上角，且范围为0~1 比如 FractionalOffset(0.5, 0.5) 代表中间位置</u></p></li><li><p>widthFactor 如果非空，则将其宽度设置为子元素的宽度乘以该因子，可以大于或小于1.0，但必须是正数。</p></li><li><p>heightFactor 如果非空，则将其高度设置为子元素的高度乘以该因子，可以大于或小于1.0，但必须是正数。</p></li></ul><h1 id="2-Expanded组件"><a href="#2-Expanded组件" class="headerlink" title="2.Expanded组件"></a>2.Expanded组件</h1><p>按比例将父容器分成若干份！！！！！！</p><div class="hljs"><pre><code class="hljs dart">Row(  children: &lt;Widget&gt;[    Expanded(      child: Container(        color: Colors.red,        padding: EdgeInsets.all(<span class="hljs-number">5.0</span>),      ),      flex: <span class="hljs-number">1</span>,    ),    Expanded(      child: Container(        color: Colors.yellow,        padding: EdgeInsets.all(<span class="hljs-number">5.0</span>),      ),      flex: <span class="hljs-number">2</span>,    ),    Expanded(      child: Container(        color: Colors.blue,        padding: EdgeInsets.all(<span class="hljs-number">5.0</span>),      ),      flex: <span class="hljs-number">1</span>,    ),  ],)</code></pre></div><p>一个很简单的例子，使用Expanded控件，将一行的宽度分成四个等分，第一、三个child占1/4的区域，第二个child占1/2区域，由flex属性控制。</p><h1 id="3-Row组件"><a href="#3-Row组件" class="headerlink" title="3.Row组件"></a>3.Row组件</h1><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p1.jpg" srcset="/img/loading.gif" alt="img" style="zoom: 67%;"><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><div class="hljs"><pre><code class="hljs dart">Row(&#123;  Key key,  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,  MainAxisSize mainAxisSize = MainAxisSize.max,  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,  TextDirection textDirection,  VerticalDirection verticalDirection = VerticalDirection.down,  TextBaseline textBaseline,  <span class="hljs-built_in">List</span>&lt;Widget&gt; children = <span class="hljs-keyword">const</span> &lt;Widget&gt;[],&#125;)</code></pre></div><h3 id="MainAxisAlignment"><a href="#MainAxisAlignment" class="headerlink" title="MainAxisAlignment"></a><strong>MainAxisAlignment</strong></h3><p>主轴方向上的对齐方式，会对child的位置起作用，默认是start。</p><p>其中MainAxisAlignment枚举值：</p><ul><li>center：将children放置在主轴的中心；</li><li>end：将children放置在主轴的末尾；</li><li>spaceAround：将主轴方向上的空白区域均分，使得children之间的空白区域相等，<strong>但是首尾child的空白区域为1/2；</strong></li><li>spaceBetween：将主轴方向上的空白区域均分，使得children之间的空白区域相等，<strong>首尾child都靠近首尾，没有间隙；</strong></li><li>spaceEvenly：将主轴方向上的空白区域均分，使得children之间的空白区域相等，<strong>包括首尾child；</strong></li><li>start：将children放置在主轴的起点；</li></ul><p><strong>其中spaceAround、spaceBetween以及spaceEvenly的区别，就是对待首尾child的方式。其距离首尾的距离分别是空白区域的1/2、0、1。</strong></p><h3 id="MainAxisSize"><a href="#MainAxisSize" class="headerlink" title="MainAxisSize"></a><strong>MainAxisSize</strong></h3><p>在主轴方向占有空间的值，默认是max。</p><p>MainAxisSize的取值有两种：</p><ul><li>max：根据传入的布局约束条件，最大化主轴方向的可用空间；</li><li>min：与max相反，是最小化主轴方向的可用空间；</li></ul><p><strong>CrossAxisAlignment</strong>：children在交叉轴方向的对齐方式，与MainAxisAlignment略有不同。</p><p>CrossAxisAlignment枚举值有如下几种：</p><ul><li>baseline：在交叉轴方向，使得children的baseline对齐；</li><li>center：children在交叉轴上居中展示；</li><li>end：children在交叉轴上末尾展示；</li><li>start：children在交叉轴上起点处展示；</li><li>stretch：让children填满交叉轴方向；</li></ul><p><strong>TextDirection</strong>：阿拉伯语系的兼容设置，一般无需处理。</p><p><strong>VerticalDirection</strong>：定义了children摆放顺序，默认是down。</p><p>VerticalDirection枚举值有两种：</p><ul><li>down：从top到bottom进行布局；</li><li>up：从bottom到top进行布局。</li></ul><p>top对应Row以及Column的话，就是左边和顶部，bottom的话，则是右边和底部。</p><p><strong>TextBaseline</strong>：使用的TextBaseline的方式，有两种，前面已经介绍过。</p><h2 id="关于Flex的构造函数"><a href="#关于Flex的构造函数" class="headerlink" title="关于Flex的构造函数"></a>关于Flex的构造函数</h2><div class="hljs"><pre><code class="hljs dart">Flex(&#123;  Key key,  <span class="hljs-meta">@required</span> <span class="hljs-keyword">this</span>.direction,  <span class="hljs-keyword">this</span>.mainAxisAlignment = MainAxisAlignment.start,  <span class="hljs-keyword">this</span>.mainAxisSize = MainAxisSize.max,  <span class="hljs-keyword">this</span>.crossAxisAlignment = CrossAxisAlignment.center,  <span class="hljs-keyword">this</span>.textDirection,  <span class="hljs-keyword">this</span>.verticalDirection = VerticalDirection.down,  <span class="hljs-keyword">this</span>.textBaseline,  <span class="hljs-built_in">List</span>&lt;Widget&gt; children = <span class="hljs-keyword">const</span> &lt;Widget&gt;[],&#125;)</code></pre></div><p>可以看出，Flex的构造函数就比Row和Column的多了一个参数。Row跟Column的区别，正是这个direction参数的不同。当为Axis.horizontal的时候，则是Row，当为Axis.vertical的时候，则是Column。</p><h1 id="4-Stack组件"><a href="#4-Stack组件" class="headerlink" title="4.Stack组件"></a>4.Stack组件</h1><p>Stack 这个是Flutter中布局用到的组件，跟Android中FrameLayout很像，都是可以叠加的现实View，具体的使用细节还是有些不同的，我们一一说来</p><div class="hljs"><pre><code class="hljs dart">Stack(&#123;  Key key,  <span class="hljs-keyword">this</span>.alignment = AlignmentDirectional.topStart,  <span class="hljs-keyword">this</span>.textDirection,  <span class="hljs-keyword">this</span>.fit = StackFit.loose,  <span class="hljs-keyword">this</span>.overflow = Overflow.clip,  <span class="hljs-built_in">List</span>&lt;Widget&gt; children = <span class="hljs-keyword">const</span> &lt;Widget&gt;[],&#125;)</code></pre></div><ul><li><p>alignment : 指的是子Widget的对其方式，默认情况是以左上角为开始点 ，这个属性是最难理解的，它区分为使用了Positioned和未使用Positioned定义两种情况，没有使用Positioned情况还是比较好理解的，下面会详细讲解的</p></li><li><p>fit :用来决定没有Positioned方式时候子Widget的大小，StackFit.loose 指的是子Widget 多大就多大，StackFit.expand使子Widget的大小和父组件一样大</p></li><li><p>overflow :指子Widget 超出Stack时候如何显示，默认值是Overflow.clip，子Widget超出Stack会被截断，</p><p>Overflow.visible超出部分还会显示的</p></li></ul><h2 id="初探Stack组件的使用"><a href="#初探Stack组件的使用" class="headerlink" title="初探Stack组件的使用"></a>初探Stack组件的使用</h2><div class="hljs"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> <span class="hljs-string">'package:flutter/material.dart'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span></span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"stack title"</span>),      ),      body: Stack(        children: &lt;Widget&gt;[          Container(            width: <span class="hljs-number">100</span>,            height: <span class="hljs-number">100</span>,            color: Colors.red,          ),          Container(            width: <span class="hljs-number">90</span>,            height: <span class="hljs-number">90</span>,            color: Colors.blue,          ),          Container(            width: <span class="hljs-number">80</span>,            height: <span class="hljs-number">80</span>,            color: Colors.green,          ),        ],      ),    );  &#125;&#125;</code></pre></div><p>上面的代码Stack做为根布局，叠加的方式展示3个组件，第一个组件比较大100<em>100，第二个组件稍微小点90**</em>90</p><p>，第三个组件最小80*80，显示的方式是能看见第一个和第二个组件的部分区域，第三个组件是能全部显示出来</p><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p2.jpg" srcset="/img/loading.gif" alt="img" style="zoom:25%;"><h2 id="fit-属性使用"><a href="#fit-属性使用" class="headerlink" title="fit 属性使用"></a>fit 属性使用</h2><p>如果指定是StackFit.expand，所以的子组件会和Stack一样大的</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"stack title"</span>),        actions: &lt;Widget&gt;[          RaisedButton(            onPressed: () &#123;              Navigator.push(context,                  MaterialPageRoute(builder: (context) =&gt; PositionScreen()));            &#125;,            color: Colors.blue,            child: Icon(Icons.add),          ),        ],      ),      body: Stack(        fit: StackFit.expand,        children: &lt;Widget&gt;[          Container(            width: <span class="hljs-number">100</span>,            height: <span class="hljs-number">100</span>,            color: Colors.red,          ),          Container(            width: <span class="hljs-number">90</span>,            height: <span class="hljs-number">90</span>,            color: Colors.blue,          ),          Container(            width: <span class="hljs-number">80</span>,            height: <span class="hljs-number">80</span>,            color: Colors.green,          ),        ],      ),    );  &#125;&#125;</code></pre></div><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p3.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><p>显示内容就只最后一个组件，虽然我们给这个组件指定了一个80*80的宽高是不会 生效的，因为我们已经指定了子元素和Stack一样大小，也就是说设置了StackFit.expand，StackFit.expand的效果优先</p><h2 id="Positioned"><a href="#Positioned" class="headerlink" title="Positioned"></a>Positioned</h2><p>这个使用控制Widget的位置，通过他可以随意摆放一个组件，有点像绝对布局</p><div class="hljs"><pre><code class="hljs dart">Positioned(&#123;  Key key,  <span class="hljs-keyword">this</span>.left,  <span class="hljs-keyword">this</span>.top,  <span class="hljs-keyword">this</span>.right,  <span class="hljs-keyword">this</span>.bottom,  <span class="hljs-keyword">this</span>.width,  <span class="hljs-keyword">this</span>.height,  <span class="hljs-meta">@required</span> Widget child,&#125;)</code></pre></div><p>left、top 、right、 bottom分别代表离Stack左、上、右、底四边的距离</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"Postion Title"</span>),      ),      body: Stack(        children: &lt;Widget&gt;[          Positioned(            top: <span class="hljs-number">100.0</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            top: <span class="hljs-number">200</span>,            right: <span class="hljs-number">100</span>,            child: Container(              color: Colors.yellow,              child: Text(<span class="hljs-string">"第二个组件"</span>),            ),          ),          Positioned(            left: <span class="hljs-number">100.0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),        ],      ),    );  &#125;&#125;</code></pre></div><p>这个例子的效果就是</p><ul><li>第一个组件距离顶部Stack 有100的间距</li><li>第二个组件距离顶部200，距离右边100间距</li><li>第三个组件距离左边100间距</li></ul><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p4.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><p>这个地方有注意地方，例如说第一个组件我指定距离左边0个距离，距离右边0个距离，那么这个组件的宽度就是屏幕这么宽，因为你指定的左右间距都是0，也就是没有间距</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"Postion Title"</span>),      ),      body: Stack(        children: &lt;Widget&gt;[          Positioned(            top: <span class="hljs-number">100.0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            top: <span class="hljs-number">200</span>,            right: <span class="hljs-number">100</span>,            child: Container(              color: Colors.yellow,              child: Text(<span class="hljs-string">"第二个组件"</span>),            ),          ),          Positioned(            bottom: <span class="hljs-number">0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),        ],      ),    );  &#125;&#125;</code></pre></div><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p5.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><p>第一个组件和第三个组件宽度都是整个屏幕这个宽度，第三组件我又指定了距离底部bottom为0，所以第三组件是在最底下</p><p>那么我们如果指定了left&amp;&amp;right&amp;&amp;top&amp;bottom都是0的情况呢?</p><p>那么这个组件就是和Stack大小一样填满它</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"Postion Title"</span>),      ),      body: Stack(        children: &lt;Widget&gt;[          Positioned(            left: <span class="hljs-number">0</span>,            top: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            bottom: <span class="hljs-number">0</span>,            child: Container(              color: Colors.black45,            ),          ),          Positioned(            top: <span class="hljs-number">100.0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            top: <span class="hljs-number">200</span>,            right: <span class="hljs-number">100</span>,            child: Container(              color: Colors.yellow,              child: Text(<span class="hljs-string">"第二个组件"</span>),            ),          ),          Positioned(            bottom: <span class="hljs-number">0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),        ],      ),    );  &#125;&#125;</code></pre></div><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p6.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><p>为了演示这个效果，我在第一个组件上加上了一个黑色的标记，代码中添加的第一组件就是和Stack一样大的，系统也提供了一个方法Positioned.fill 这个方法的效果和图片上是一样的</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"Postion Title"</span>),      ),      body: Stack(        children: &lt;Widget&gt;[          Positioned.fill(            child: Container(              color: Colors.black45,            ),          ),          Positioned(            top: <span class="hljs-number">100.0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            top: <span class="hljs-number">200</span>,            right: <span class="hljs-number">100</span>,            child: Container(              color: Colors.yellow,              child: Text(<span class="hljs-string">"第二个组件"</span>),            ),          ),          Positioned(            bottom: <span class="hljs-number">0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),        ],      ),    );  &#125;&#125;</code></pre></div><p>效果是等价的</p><h2 id="alignment-属性理解"><a href="#alignment-属性理解" class="headerlink" title="alignment 属性理解"></a>alignment 属性理解</h2><h3 id="没有使用Positioned定位情况"><a href="#没有使用Positioned定位情况" class="headerlink" title="没有使用Positioned定位情况"></a>没有使用Positioned定位情况</h3><p>在我们初探Stack组件中讲解的例子就是没有使用Positioned定位的情况，默认的子组件的对齐方式就是以左上角为起点开始排列子Widget</p><h3 id="AlignmentDirectional-bottomEnd-对齐方式"><a href="#AlignmentDirectional-bottomEnd-对齐方式" class="headerlink" title="AlignmentDirectional.bottomEnd 对齐方式"></a>AlignmentDirectional.bottomEnd 对齐方式</h3><p>所有的Widget 以Stack的右下角为起点开始对齐</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"stack title"</span>),        actions: &lt;Widget&gt;[          RaisedButton(            onPressed: () &#123;              Navigator.push(context,                  MaterialPageRoute(builder: (context) =&gt; PositionScreen()));            &#125;,            color: Colors.blue,            child: Icon(Icons.add),          ),        ],      ),      body: Stack(<span class="hljs-comment">//        fit: StackFit.expand,</span>       alignment: AlignmentDirectional.bottomEnd,        children: &lt;Widget&gt;[          Container(            width: <span class="hljs-number">100</span>,            height: <span class="hljs-number">100</span>,            color: Colors.red,          ),          Container(            width: <span class="hljs-number">90</span>,            height: <span class="hljs-number">90</span>,            color: Colors.blue,          ),          Container(            width: <span class="hljs-number">80</span>,            height: <span class="hljs-number">80</span>,            color: Colors.green,          ),        ],      ),    );  &#125;&#125;</code></pre></div><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p7.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><h3 id="AlignmentDirectional-topEnd-对齐方式"><a href="#AlignmentDirectional-topEnd-对齐方式" class="headerlink" title="AlignmentDirectional.topEnd 对齐方式"></a>AlignmentDirectional.topEnd 对齐方式</h3><p>所有的Widget 以Stack的右上角为起点开始对齐</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"stack title"</span>),        actions: &lt;Widget&gt;[          RaisedButton(            onPressed: () &#123;              Navigator.push(context,                  MaterialPageRoute(builder: (context) =&gt; PositionScreen()));            &#125;,            color: Colors.blue,            child: Icon(Icons.add),          ),        ],      ),      body: Stack(<span class="hljs-comment">//        fit: StackFit.expand,</span>       alignment: AlignmentDirectional.topEnd,        children: &lt;Widget&gt;[          Container(            width: <span class="hljs-number">100</span>,            height: <span class="hljs-number">100</span>,            color: Colors.red,          ),          Container(            width: <span class="hljs-number">90</span>,            height: <span class="hljs-number">90</span>,            color: Colors.blue,          ),          Container(            width: <span class="hljs-number">80</span>,            height: <span class="hljs-number">80</span>,            color: Colors.green,          ),        ],      ),    );  &#125;&#125;</code></pre></div><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p8.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><h3 id="AlignmentDirectional-center-对齐方式"><a href="#AlignmentDirectional-center-对齐方式" class="headerlink" title="AlignmentDirectional.center 对齐方式"></a>AlignmentDirectional.center 对齐方式</h3><p>所有的Widget 以Stack的中心位置</p><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p9.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><h3 id="AlignmentDirectional-centerEnd-对齐方式"><a href="#AlignmentDirectional-centerEnd-对齐方式" class="headerlink" title="AlignmentDirectional.centerEnd 对齐方式"></a>AlignmentDirectional.centerEnd 对齐方式</h3><p>所有的Widget 在Stack的中心位置并且右边跟stack右边挨着</p><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p10.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><h3 id="使用Positioned情况下"><a href="#使用Positioned情况下" class="headerlink" title="使用Positioned情况下"></a>使用Positioned情况下</h3><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"Postion Title"</span>),      ),      body: Stack(<span class="hljs-comment">//        alignment: AlignmentDirectional.bottomEnd,</span>        overflow: Overflow.visible,        children: &lt;Widget&gt;[          Positioned.fill(            child: Container(              color: Colors.black45,            ),          ),          Positioned(            top: <span class="hljs-number">100.0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">20</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            top: <span class="hljs-number">200</span>,            bottom: <span class="hljs-number">20</span>,            child: Container(              color: Colors.yellow,              child: Text(<span class="hljs-string">"第二个组件"</span>),            ),          ),          Positioned(            bottom: <span class="hljs-number">0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),        ],      ),    );  &#125;&#125;</code></pre></div><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p11.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><p>这种情况是alignment 是默认值的效果，下面我们修改一下alignment的对应的值</p><h4 id="AlignmentDirectional-bottomEnd"><a href="#AlignmentDirectional-bottomEnd" class="headerlink" title="AlignmentDirectional.bottomEnd"></a>AlignmentDirectional.bottomEnd</h4><p>bottomEnd是子Widget的底部和Stack底部对齐，并且子Widget的右边和Stack右边对齐</p><div class="hljs"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PositionScreen</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>&#123;  <span class="hljs-meta">@override</span>  Widget build(BuildContext context) &#123;    <span class="hljs-keyword">return</span> Scaffold(      appBar: AppBar(        title: Text(<span class="hljs-string">"Postion Title"</span>),      ),      body: Stack(        alignment: AlignmentDirectional.bottomEnd,        overflow: Overflow.visible,        children: &lt;Widget&gt;[          Positioned.fill(            child: Container(              color: Colors.black45,            ),          ),          Positioned(            top: <span class="hljs-number">100.0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">20</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            top: <span class="hljs-number">200</span>,            bottom: <span class="hljs-number">20</span>,            child: Container(              color: Colors.yellow,              child: Text(<span class="hljs-string">"第二个组件"</span>),            ),          ),          Positioned(            bottom: <span class="hljs-number">0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),        ],      ),    );  &#125;&#125;</code></pre></div><p>显示效果</p><img src="/2020/07/22/Flutter-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%EF%BC%88%E4%B8%80%EF%BC%89/p12.jpg" srcset="/img/loading.gif" alt="img" style="zoom:33%;"><p>大家会发现这个图的效果和上一个图的效果唯一区别就是黄色的第二个组件的位置有变化，这是为什么呢？</p><p>先说第一个组件和第三组件的位置为什么没有改变</p><div class="hljs"><pre><code class="hljs dart">Positioned(            top: <span class="hljs-number">100.0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">20</span>,            child: Container(              color: Colors.blue,              child: Text(<span class="hljs-string">"第一个组件"</span>),            ),          ),          Positioned(            bottom: <span class="hljs-number">0</span>,            left: <span class="hljs-number">0</span>,            right: <span class="hljs-number">0</span>,            child: Container(              color: Colors.red,              child: Text(<span class="hljs-string">"第三个组件"</span>),            ),          ),</code></pre></div><p>第一个组件top是100，说明这个组件距离顶部的距离是固定的，虽然Stack的aligment=AlignmentDirectional.bottomEnd，是不生效的，当这两个属性冲突时，以Positioned的距离为主，为什么第一组件右边也没有Stack的右边对齐呢？因为right=20，第一个组件右边距离已经可以确认了，所以也不受到aligment=AlignmentDirectional.bottomEnd的影响</p><p>第三个组件也是一样的，第三个组件的宽度是Stack的宽度，高度取决于Text组件的高度，最关键的是它的bottom=0，也就是第三个组件要和Stack组件的低边界对齐，所以它的效果和上面的图是没有变化的</p><div class="hljs"><pre><code class="hljs dart">Positioned(  top: <span class="hljs-number">200</span>,  bottom: <span class="hljs-number">20</span>,  child: Container(    color: Colors.yellow,    child: Text(<span class="hljs-string">"第二个组件"</span>),  ),),</code></pre></div><p>第二个组件为什么会跑到右边呢？</p><p>因为第二个组件的高度是可以确认出来的，top=200，bottom=20，设置这两个属性就能推断出第二组的高度是多大，但是第二个组件的宽度取决于Text(“第二个组件”) 的宽度，显然是水平方向上是不能填满Stack的，这个时候AlignmentDirectional.bottomEnd属性起作用了，bottom的距离已经确定了，所以底部的对齐方式是不会变化了，但是第二组件右边的对齐方式是可以收到AlignmentDirectional.bottomEnd影响的，所以第二组件展示的位置就是图片上展示的位置</p><h2 id="总结一下使用Positioned-定位方式aligment-方式对它的影响"><a href="#总结一下使用Positioned-定位方式aligment-方式对它的影响" class="headerlink" title="总结一下使用Positioned 定位方式aligment 方式对它的影响"></a>总结一下使用Positioned 定位方式aligment 方式对它的影响</h2><p>Positioned 有四个属性top、bottom、left、right，（top、bottom）决定了垂直方向上的位置了，（left、right）决定了水平方向上的位置，不管水平方向上还是垂直方向上只要设定了一个值该方向上位置就已经确定过了，aligment对这这个方向上就不会起作用了，如果Positioned 设置了其中任意三个方向的值，这个Widget的位置就是固定的，aligment对它不会起任何作用</p>]]></content>
    
    
    <categories>
      
      <category>Flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dart</tag>
      
      <tag>Layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-中级]删除排序链表中的重复元素</title>
    <link href="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><div class="notranslate"><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中&nbsp;<em>没有重复出现&nbsp;</em>的数字。</p><p><strong>示例&nbsp;1:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<strong>输出:</strong> 1-&gt;2-&gt;5</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> 1-&gt;1-&gt;1-&gt;2-&gt;3<strong>输出:</strong> 2-&gt;3</div></pre></div><p class="note note-danger">问题的描述是删除重复的节点。在解决这个问题之前，我们先解决一个简单的问题，问题描述如下：</p><div class="notranslate"><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><strong>示例&nbsp;1:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> 1-&gt;1-&gt;2<strong>输出:</strong> 1-&gt;2</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;3<strong>输出:</strong> 1-&gt;2-&gt;3</div></pre></div><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于仅保留一个重复元素的问题，我们可以每个节点依次与其下一个节点比较，如下：</p><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716144940378.png" srcset="/img/loading.gif" alt="image-20200716144940378" style="zoom: 50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716145329577.png" srcset="/img/loading.gif" alt="image-20200716145329577" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716145432503.png" srcset="/img/loading.gif" alt="image-20200716145432503" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716145540253.png" srcset="/img/loading.gif" alt="image-20200716145540253" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716145640859.png" srcset="/img/loading.gif" alt="image-20200716145640859" style="zoom:50%;"><p>从图中可以看到整个算法的流程很简单，算法的实现如下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(self, head: ListNode)</span> -&gt; ListNode:</span>        current = head        <span class="hljs-keyword">while</span> current <span class="hljs-keyword">and</span> current.next:            <span class="hljs-keyword">if</span> current.val == current.next.val:                current.next = current.next.next            <span class="hljs-keyword">else</span>:                current = current.next        <span class="hljs-keyword">return</span> head</code></pre></div><p>我们回头再来看标题的问题，我们使用什么样的手法将出现重复的节点全部删除呢？解决思路和上面这个问题的思路不太相同。换个角度想，我们也要删除第一次出现的节点，这是我们需要在这之前再定义一个变量。</p><p>基本思路就是每一次区间<code>[l,r)</code>（左闭右开）中的数字相同，然后判断该区间的长度是否为1，若长度为1则通过尾插法插入到答案中（这一步看图）。</p><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/6ed9f10ba17ab7836663b330b846e8cb4dd3b9a82c39bd3dd19844025da334e2-62a6ee34555d112eb7e92ed9f66baba41aa0b9deec893ddfcc0ad07677d929ba-lc82.png" srcset="/img/loading.gif" alt="62a6ee34555d112eb7e92ed9f66baba41aa0b9deec893ddfcc0ad07677d929ba-lc82.png"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716152823083.png" srcset="/img/loading.gif" alt="image-20200716152823083" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716152740919.png" srcset="/img/loading.gif" alt="image-20200716152740919" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716153125362.png" srcset="/img/loading.gif" alt="image-20200716153125362" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716153803881.png" srcset="/img/loading.gif" alt="image-20200716153803881" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716153831941.png" srcset="/img/loading.gif" alt="image-20200716153831941" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716153909732.png" srcset="/img/loading.gif" alt="image-20200716153909732" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716153931693.png" srcset="/img/loading.gif" alt="image-20200716153931693" style="zoom:50%;"><img src="/2020/07/16/LeetCode-%E4%B8%AD%E7%BA%A7-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/image-20200716154022279.png" srcset="/img/loading.gif" alt="image-20200716154022279" style="zoom:50%;"><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(self, head: ListNode)</span> -&gt; ListNode:</span>        pre = head        p = head        node = ListNode(<span class="hljs-number">-1</span>)        tail = node        <span class="hljs-keyword">while</span> pre <span class="hljs-keyword">and</span> p:            <span class="hljs-keyword">while</span> p <span class="hljs-keyword">and</span> pre.val == p.val:                p = p.next            <span class="hljs-keyword">if</span> pre.next == p:                tail.next = pre                tail = pre                tail.next = <span class="hljs-literal">None</span>            pre = p        <span class="hljs-keyword">return</span> node.next</code></pre></div><p>这道题需要思考的地方就是如何将重复的节点全部略过去，算法的时间复杂度是n，并不是n^2!!! 外层循环控制扫描整个链表，内部循环负责移动指针避开所有重复的节点。这种算法并没有进行原地操作，取而代之的是新建了链表，将不重复的元素尾插到新的链表中，最后返回这个新的链表。当然对于这种题目来说，第一反应可能得到的不是最优的解法。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>在结题的过程中，我页参考了其他人的一些做法，算法实现如下：</p><p>这里要求的是去重，那简单。用一个哈希表记录每个值出现的频率就可以了。<br>具体做法如下:</p><ol><li>遍历链表，将每个节点的值放到哈希表中，哈希表的key就是节点的值，value是这个值出现的频率</li><li>遍历哈希表，将所有频率==1的key放到集合中</li><li>对集合进行排序</li><li>遍历集合，然后不断创建新的链表节点</li></ol><p>当然这里可以优化一下，比如使用<code>LinkedHashMap</code>或者<code>OrderedDict</code>这样的数据结构，可以省去排序环节。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;        <span class="hljs-keyword">if</span>(head==<span class="hljs-keyword">null</span> || head.next==<span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> head;        &#125;        <span class="hljs-comment">//用哈希表记录每个节点值的出现频率</span>        HashMap&lt;Integer,Integer&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();        ArrayList&lt;Integer&gt; arr = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        ListNode p = head;        <span class="hljs-keyword">while</span>(p!=<span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">int</span> val = p.val;            <span class="hljs-keyword">if</span>(cache.containsKey(val)) &#123;                cache.put(val,cache.get(val)+<span class="hljs-number">1</span>);            &#125; <span class="hljs-keyword">else</span> &#123;                cache.put(val,<span class="hljs-number">1</span>);            &#125;            p = p.next;        &#125;        <span class="hljs-comment">//将所有只出现一次的值放到arr中，之后再对这个arr排序</span>        <span class="hljs-keyword">for</span>(Integer k : cache.keySet()) &#123;            <span class="hljs-keyword">if</span>(cache.get(k)==<span class="hljs-number">1</span>) &#123;                arr.add(k);            &#125;        &#125;        Collections.sort(arr);        ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);        p = dummy;        <span class="hljs-comment">//创建长度为arr.length长度的链表，依次将arr中的值赋给每个链表节点</span>        <span class="hljs-keyword">for</span>(Integer i : arr) &#123;            ListNode tmp = <span class="hljs-keyword">new</span> ListNode(i);            p.next = tmp;            p = p.next;        &#125;        <span class="hljs-keyword">return</span> dummy.next;    &#125;&#125;</code></pre></div></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>中级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]寻找数组的中心索引</title>
    <link href="/2020/07/14/LeetCode-%E5%88%9D%E7%BA%A7-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/07/14/LeetCode-%E5%88%9D%E7%BA%A7-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定一个整数类型的数组&nbsp;<code>nums</code>，请编写一个能够返回数组 <strong>“中心索引” </strong>的方法。</p><p>我们是这样定义数组<strong> 中心索引 </strong>的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>&nbsp;</p><p><strong>示例 1：</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入：</strong>nums = [1, 7, 3, 6, 5, 6]<strong>输出：</strong>3<strong>解释：</strong>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。同时, 3 也是第一个符合要求的中心索引。</div></pre></div><p><strong>示例 2：</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入：</strong>nums = [1, 2, 3]<strong>输出：</strong>-1<strong>解释：</strong>数组中不存在满足此条件的中心索引。</div></pre></div><p>&nbsp;</p><p><strong>说明：</strong></p><ul>    <li><code>nums</code> 的长度范围为&nbsp;<code>[0, 10000]</code>。</li>    <li>任何一个&nbsp;<code>nums[i]</code> 将会是一个范围在&nbsp;<code>[-1000, 1000]</code>的整数。</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h4 id="方法：前缀和"><a class="header-anchor" href="#方法：前缀和"></a> 方法：前缀和</h4><ul><li><code>S</code> 是数组的和，当索引 <code>i</code> 是中心索引时，位于 <code>i</code> 左边数组元素的和 <code>leftsum</code> 满足 <code>S - nums[i] - leftsum</code>。</li><li>我们只需要判断当前索引 <code>i</code> 是否满足 <code>leftsum==S-nums[i]-leftsum</code> 并动态计算 <code>leftsum</code> 的值。</li></ul><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 是 <code>nums</code> 的长度。</li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，使用了 <code>S</code> 和 <code>leftsum</code> 。</li></ul><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(self, nums)</span>:</span>        S = sum(nums)        leftsum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(nums):            <span class="hljs-keyword">if</span> leftsum == (S - leftsum - x):                <span class="hljs-keyword">return</span> i            leftsum += x        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre></div><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pivotIndex</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        Sum = sum(nums)        leftsum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> Sum<span class="hljs-number">-2</span>*leftsum==nums[i]:                <span class="hljs-keyword">return</span> i            leftsum+=nums[i]        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]阶乘尾数</title>
    <link href="/2020/07/14/LeetCode-%E5%88%9D%E7%BA%A7-%E9%98%B6%E4%B9%98%E5%B0%BE%E6%95%B0/"/>
    <url>/2020/07/14/LeetCode-%E5%88%9D%E7%BA%A7-%E9%98%B6%E4%B9%98%E5%B0%BE%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>设计一个算法，算出 n 阶乘有多少个尾随零。</p><p><strong>示例 1:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> 3<strong>输出:</strong> 0<strong>解释:</strong>&nbsp;3! = 6, 尾数中没有零。</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> 5<strong>输出:</strong> 1<strong>解释:</strong>&nbsp;5! = 120, 尾数中有 1 个零.</div></pre></div><p><strong>说明: </strong>你算法的时间复杂度应为&nbsp;<em>O</em>(log&nbsp;<em>n</em>)<em>&nbsp;</em>。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>10 是由 2 * 5 得到的, 因此我们求 n！的过程中就是求其中存在多少个 2 * 5。因为 2 的个数必定比 5 的个数多（偶数都是2的倍数），因此我们只求 5 的个数即可！</p><div class="hljs"><pre><code class="hljs java"> <span class="hljs-comment">//如果直接一个一个遍历，即 </span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; i &lt;= n; i++)&#123;    <span class="hljs-keyword">int</span> temp = i;    <span class="hljs-keyword">while</span>(temp % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>)&#123;        count++;        temp /= <span class="hljs-number">5</span>;    &#125;&#125;</code></pre></div><p>那么 n 过大时，从 1 遍历到 n, 那么会超时,因此我们修改下规律</p><p>$$<br>n! = 1 * 2 * 3 * 4 * (1 * 5) * … * (2 * 5) * … * (3 * 5) …<br>$$</p><ul><li>我们发现，每隔 5 个数就会出现 一个 5，因此我们只需要通过 n / 5 来计算存在存在多少个 5 个数，那么就对应的存在多少个 5<br>但是；</li><li>我们也会发现，每隔 25 个数会出现 一个 25， 而 25 存在 两个 5，我们上面只计算了 25 的一个 5，因此我们需要 n / 25 来计算存在多少个 25，加上它遗漏的 5；</li><li>同时，我们还会发现，每隔 125 个数会出现一个 125，而 125 存在 三个 5，我们上面只计算了 125 的两个 5，因此我们需要 n / 125 来计算存在多少个 125，加上它遗漏的 5；<br>…</li></ul><p>因此我们<br>$$<br>count = n / 5 + n / 25 + n / 125 + …<br>$$<br>最终分母可能过大溢出，上面的式子可以进行转换<br>$$<br>count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + …<br>$$<br>因此，我们这样进行循环</p><p>这样，第一次加上的就是 每隔 5 个数的 5 的个数，第二次加上的就是 每隔 25 个数的 5 的个数 …</p><div class="hljs"><pre><code class="hljs java">n /= <span class="hljs-number">5</span>;count += n;</code></pre></div><p>这样，第一次加上的就是 每隔 5 个数的 5 的个数，第二次加上的就是 每隔 25 个数的 5 的个数 …</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="python语言版本"><a href="#python语言版本" class="headerlink" title="python语言版本"></a>python语言版本</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(self, n: int)</span> -&gt; int:</span>        mul = <span class="hljs-number">0</span>        <span class="hljs-keyword">while</span> n&gt;=<span class="hljs-number">5</span>:            n //= <span class="hljs-number">5</span>            mul += n        <span class="hljs-keyword">return</span> mul</code></pre></div><h2 id="java语言实现"><a href="#java语言实现" class="headerlink" title="java语言实现"></a>java语言实现</h2><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trailingZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">5</span>)&#123;            n /= <span class="hljs-number">5</span>;            count += n;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;&#125;</code></pre></div></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>阶乘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]最大子序和</title>
    <link href="/2020/07/08/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <url>/2020/07/08/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定一个整数数组 <code>nums</code>&nbsp;，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入:</strong> [-2,1,-3,4,-1,2,1,-5,4],<strong>输出:</strong> 6<strong>解释:</strong>&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</div></pre></div><p><strong>进阶:</strong></p><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p class="note note-success">使用动态规划思想</p><p style="text-indent: 2em;">假设列表中的第一个数为最大子序和，然后逐个将列表后的元素叠加到最大子序和中。如何最大子序和变大了，就修改最大子序和的值，继续往下叠加。如果变小了，就放弃最后叠加的那个数（这个数一定是个负数！）。从最后叠加的那个数（负数）之后，重新开始叠加计算最大子序和，一直到列表遍历完毕。如果重新计算的最大子序和比之前的最大子序和大，就替换掉前面的最大子序和。最后得到的就是整个列表的最大子序和。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        maxSum = nums[<span class="hljs-number">0</span>]        subSum = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            subSum += nums[i]            <span class="hljs-keyword">if</span> subSum&gt;maxSum:                maxSum = subSum            <span class="hljs-keyword">if</span> subSum&lt;<span class="hljs-number">0</span>:                subSum = <span class="hljs-number">0</span>        <span class="hljs-keyword">return</span> maxSum</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]最长公共前缀</title>
    <link href="/2020/07/05/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"/>
    <url>/2020/07/05/LeetCode-%E5%88%9D%E7%BA%A7-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串&nbsp;<code>""</code>。</p><p><strong>示例&nbsp;1:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入: </strong>["flower","flow","flight"]<br><strong>输出:</strong> "fl"</div></pre></div><p><strong>示例&nbsp;2:</strong></p><div class="hljs"><pre><div style="color:white;"><strong>输入: </strong>["dog","racecar","car"]<br><strong>输出:</strong> ""<br><strong>解释:</strong> 输入不存在公共前缀。<div style="color:white;"></div></div></pre></div><p><strong>说明:</strong></p></div><p class="note note-primary">所有输入只包含小写字母&nbsp;<code>a-z</code>&nbsp;。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><ol><li><p>穷举法</p><p>这种方法是最容易理解的一种方法。首先获取到列表中长度最小的字符串暂定作为最长的匹配前缀，然后用这个前缀依次和列表里的字符串判断是否包含这个前缀。发现不是前缀的时候，暂定前缀就缩短一个字符。如此反复进行比较，直到前缀字符串变为空串。当然这个方法的时间复杂度是很高的O(m*n)。</p></li></ol><h2 id="穷举法实现"><a href="#穷举法实现" class="headerlink" title="穷举法实现"></a>穷举法实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(self, strs: List[str])</span> -&gt; str:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> strs:            <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>        strs.sort(key=<span class="hljs-keyword">lambda</span> i:len(i))        reg=strs[<span class="hljs-number">0</span>]        <span class="hljs-keyword">for</span> i, c <span class="hljs-keyword">in</span> enumerate(reg):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> strs:                <span class="hljs-keyword">if</span> c != j[i]:                    <span class="hljs-keyword">return</span> reg[:i]        <span class="hljs-keyword">return</span> reg</code></pre></div><ol start="2"><li><p>ASCII排值法</p><p>利用python的max()和min()，在Python里字符串是可以比较的，按照ascII值排，举例abb， aba，abac，最大为abb，最小为aba。所以只需要比较最大最小的公共前缀就是整个数组的公共前缀。</p></li></ol><h2 id="排值法实现"><a href="#排值法实现" class="headerlink" title="排值法实现"></a>排值法实现</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(self, strs: List[str])</span> -&gt; str:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> strs: <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>        s1 = min(strs)        s2 = max(strs)        <span class="hljs-keyword">for</span> i,x <span class="hljs-keyword">in</span> enumerate(s1):            <span class="hljs-keyword">if</span> x != s2[i]:                <span class="hljs-keyword">return</span> s2[:i]        <span class="hljs-keyword">return</span> s1</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LeetCode-初级]括号匹配问题</title>
    <link href="/2020/07/04/LeetCode-%E5%88%9D%E7%BA%A7-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/04/LeetCode-%E5%88%9D%E7%BA%A7-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><div class="notranslate"><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code>&nbsp;的字符串，判断字符串是否有效。</p>    <p>有效字符串需满足：</p>    <ol>        <li>左括号必须用相同类型的右括号闭合。</li>        <li>左括号必须以正确的顺序闭合。</li>    </ol>    <p>注意空字符串可被认为是有效字符串。</p>    <p><strong>示例 1:</strong></p>    <div class="hljs"><pre><div style="color: white;"><strong style="color: white;">输入:</strong> "()"<strong style="color: white;">输出:</strong> true</div></pre></div>    <p><strong>示例&nbsp;2:</strong></p>    <div class="hljs"><pre><div style="color: white;"><strong style="color: white;">输入:</strong> "()[]{}"<strong>输出:</strong> true</div></pre></div>    <p><strong>示例&nbsp;3:</strong></p>    <div class="hljs"><pre><div style="color: white;"><strong style="color: white;">输入:</strong> "(]"<strong>输出:</strong> false</div></pre></div>    <p><strong>示例&nbsp;4:</strong></p>    <div class="hljs"><pre><div style="color: white;"><strong style="color: white;">输入:</strong> "([)]"<strong>输出:</strong> false</div></pre></div>    <p><strong>示例&nbsp;5:</strong></p>    <div class="hljs"><pre><div style="color: white;"><strong style="color: white;">输入:</strong> "{[]}"<strong>输出:</strong> true</div></pre></div></div><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>栈的应用，但是比较的是左括号。入栈的是右括号。</p><p>同时注意空字符串的时候也是有效字符串</p><p>那么对于这一问题，还有一个更为机巧的做法，有效的括号字符都满足 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的成对出现。那么我们可以用字符串替换的思想，将成对出现的括号用空串“”替换，如果最后替换的结果为空字符串，那么则表示所有的成对括号都被替换掉，那么这个括号串就是有效的。否则就是无效的字符串。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        Stack&lt;Character&gt;stack = <span class="hljs-keyword">new</span> Stack&lt;Character&gt;();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c: s.toCharArray())&#123;            <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'('</span>) stack.push(<span class="hljs-string">')'</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'['</span>) stack.push(<span class="hljs-string">']'</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(c==<span class="hljs-string">'&#123;'</span>) stack.push(<span class="hljs-string">'&#125;'</span>);            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(stack.isEmpty() || c!=stack.pop()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">return</span> stack.isEmpty();    &#125;&#125;</code></pre></div><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;        <span class="hljs-keyword">while</span>(s.contains(<span class="hljs-string">"()"</span>) || s.contains(<span class="hljs-string">"&#123;&#125;"</span>) || s.contains(<span class="hljs-string">"[]"</span>))            s = s.replace(<span class="hljs-string">"()"</span>,<span class="hljs-string">""</span>).replace(<span class="hljs-string">"&#123;&#125;"</span>,<span class="hljs-string">""</span>).replace(<span class="hljs-string">"[]"</span>,<span class="hljs-string">""</span>);        <span class="hljs-keyword">return</span> s.equals(<span class="hljs-string">""</span>);    &#125;&#125;</code></pre></div><p>注意这种方法在使用的过程中，要用循环来判断字符串中是否还包含括号对子串！</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        stack = [<span class="hljs-string">'?'</span>]        dicts = &#123;<span class="hljs-string">'('</span>:<span class="hljs-string">')'</span>,<span class="hljs-string">'['</span>:<span class="hljs-string">']'</span>,<span class="hljs-string">'&#123;'</span>:<span class="hljs-string">'&#125;'</span>,<span class="hljs-string">'?'</span>:<span class="hljs-string">'?'</span>&#125;        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:            <span class="hljs-keyword">if</span> c <span class="hljs-keyword">in</span> dicts:                stack.append(c)            <span class="hljs-keyword">elif</span> dicts[stack.pop()]!=c:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> len(stack) == <span class="hljs-number">1</span></code></pre></div><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span><span class="hljs-params">(self, s: str)</span> -&gt; bool:</span>        <span class="hljs-keyword">while</span> <span class="hljs-string">'()'</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">or</span> <span class="hljs-string">'&#123;&#125;'</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">or</span> <span class="hljs-string">'[]'</span> <span class="hljs-keyword">in</span> s:            s = s.replace(<span class="hljs-string">'()'</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-string">'&#123;&#125;'</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-string">'[]'</span>, <span class="hljs-string">''</span>)        <span class="hljs-keyword">return</span> s==<span class="hljs-string">''</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>初级</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
